<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阿犇</title>
  
  <subtitle>记录生活中的点点滴滴</subtitle>
  <link href="https://benyang0506.github.io/atom.xml" rel="self"/>
  
  <link href="https://benyang0506.github.io/"/>
  <updated>2021-10-14T05:54:57.558Z</updated>
  <id>https://benyang0506.github.io/</id>
  
  <author>
    <name>杨犇</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>离散化</title>
    <link href="https://benyang0506.github.io/2021/10/14/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    <id>https://benyang0506.github.io/2021/10/14/%E7%A6%BB%E6%95%A3%E5%8C%96/</id>
    <published>2021-10-14T05:41:41.000Z</published>
    <updated>2021-10-14T05:54:57.558Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h5><p>传送门：<a href="https://www.acwing.com/problem/content/804/">https://www.acwing.com/problem/content/804/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>假定有一个无限长的数轴，数轴上每个坐标上的数都是 00。</p><p>现在，我们首先进行 nn 次操作，每次操作将某一位置 xx 上的数加 cc。</p><p>接下来，进行 mm 次询问，每个询问包含两个整数 ll 和 rr，你需要求出在区间 [l,r][l,r] 之间的所有数的和。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 nn 和 mm。</p><p>接下来 nn 行，每行包含两个整数 xx 和 cc。</p><p>再接下来 mm 行，每行包含两个整数 ll 和 rr。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 mm 行，每行输出一个询问中所求的区间内数字和。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$-1e9≤x≤1e9$</p><p>$1≤n,m≤1e5$</p><p>$-1e9≤l≤r≤1e9$</p><p>$−10000≤c≤10000$</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">3 6</span><br><span class="line">7 5</span><br><span class="line">1 3</span><br><span class="line">4 6</span><br><span class="line">7 8</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">0</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>离散化基础模板题</p><p>$x$的范围非常大，数组开不出来，但是实际用到的点不多，可以将这些用到的点映射到较小的数组中（保序），就是离散化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PIR;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有坐标的点的个数，add最大1e5个点，query最多1e5次，每次两个点</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">300000</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有坐标的点的个数</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; alls;</span><br><span class="line"></span><br><span class="line">vector&lt;PIR&gt; query;</span><br><span class="line">vector&lt;PIR&gt; add;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 离散化后的原数组</span></span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="comment">// 离散化后的前缀和数组</span></span><br><span class="line"><span class="keyword">int</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分找映射后的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=alls.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(alls[mid]&gt;=x)&#123;</span><br><span class="line">            r=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使离散化后的原数组从1开始，方便求前缀和</span></span><br><span class="line">    <span class="keyword">return</span> l+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,c;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;c;</span><br><span class="line">        add.<span class="built_in">push_back</span>(&#123;x,c&#125;);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        query.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(l);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//保序离散化+去重</span></span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>());</span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>()),alls.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// add</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;add.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=add[i].first;</span><br><span class="line">        <span class="keyword">int</span> c=add[i].second;</span><br><span class="line">        a[<span class="built_in">find</span>(x)]+=c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 预处理前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=alls.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// query</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;query.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l=query[i].first;</span><br><span class="line">        <span class="keyword">int</span> r=query[i].second;</span><br><span class="line">        cout&lt;&lt;s[<span class="built_in">find</span>(r)]-s[<span class="built_in">find</span>(l)<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;区间和&quot;&gt;&lt;a href=&quot;#区间和&quot; class=&quot;headerlink&quot; title=&quot;区间和&quot;&gt;&lt;/a&gt;区间和&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://www.acwing.com/problem/content/804/&quot;&gt;https://www.acwing.com/problem/content/804/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="模板题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%A8%A1%E6%9D%BF%E9%A2%98/"/>
    
    
    <category term="离散化" scheme="https://benyang0506.github.io/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="https://benyang0506.github.io/2021/10/14/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>https://benyang0506.github.io/2021/10/14/%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2021-10-14T03:47:38.000Z</published>
    <updated>2021-10-14T05:49:34.258Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="连通块中点的数量"><a href="#连通块中点的数量" class="headerlink" title="连通块中点的数量"></a>连通块中点的数量</h5><p>传送门：<a href="https://www.acwing.com/problem/content/839/">https://www.acwing.com/problem/content/839/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给定一个包含 nn 个点（编号为 1∼n1∼n）的无向图，初始时图中没有边。</p><p>现在要进行 mm 个操作，操作共有三种：</p><ol><li><code>C a b</code>，在点 aa 和点 bb 之间连一条边，aa 和 bb 可能相等；</li><li><code>Q1 a b</code>，询问点 aa 和点 bb 是否在同一个连通块中，aa 和 bb 可能相等；</li><li><code>Q2 a</code>，询问点 aa 所在连通块中点的数量；</li></ol><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入整数 nn 和 mm。</p><p>接下来 mm 行，每行包含一个操作指令，指令为 <code>C a b</code>，<code>Q1 a b</code> 或 <code>Q2 a</code> 中的一种。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个询问指令 <code>Q1 a b</code>，如果 aa 和 bb 在同一个连通块中，则输出 <code>Yes</code>，否则输出 <code>No</code>。</p><p>对于每个询问指令 <code>Q2 a</code>，输出一个整数表示点 aa 所在连通块中点的数量</p><p>每个结果占一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1≤n,m≤1e5</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 5</span><br><span class="line">C 1 2</span><br><span class="line">Q1 1 2</span><br><span class="line">Q2 1</span><br><span class="line">C 2 5</span><br><span class="line">Q2 5</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>并查集基础模板题</p><p>$cnt[N]$：记录每个集合中元素个数</p><p>$p[N]$：存当前节点父结点，路径压缩后存根结点</p><p>合并集合时先合并数量，再连边。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p[i]：节点i的根节点</span></span><br><span class="line"><span class="comment">// p[i]=i，i为根节点</span></span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="comment">// 记录每个集合中的元素个数</span></span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找x的根节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果x不是根节点</span></span><br><span class="line">    <span class="keyword">if</span>(x!=p[x]) </span><br><span class="line">        <span class="comment">// 将p[x]设置为根节点</span></span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="comment">// 返回根节点</span></span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">// 每个点都是根节点，各自为一个集合</span></span><br><span class="line">        p[i]=i;</span><br><span class="line">        <span class="comment">// 每个集合一开始只有1个点（自己）</span></span><br><span class="line">        cnt[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">&quot;Q2&quot;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            cout&lt;&lt;cnt[<span class="built_in">find</span>(x)]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">&quot;Q1&quot;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x)==<span class="built_in">find</span>(y))&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// x与y不能再同一个集合</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x)!=<span class="built_in">find</span>(y))&#123;</span><br><span class="line">                <span class="comment">// 先更新cnt</span></span><br><span class="line">                cnt[<span class="built_in">find</span>(y)]+=cnt[<span class="built_in">find</span>(x)];</span><br><span class="line">                <span class="comment">// 将根节点连起来</span></span><br><span class="line">                p[<span class="built_in">find</span>(x)]=<span class="built_in">find</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$find()$时间复杂度可以看成$O(1)$。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;连通块中点的数量&quot;&gt;&lt;a href=&quot;#连通块中点的数量&quot; class=&quot;headerlink&quot; title=&quot;连通块中点的数量&quot;&gt;&lt;/a&gt;连通块中点的数量&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://www.acwing.com/problem/content/839/&quot;&gt;https://www.acwing.com/problem/content/839/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="模板题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%A8%A1%E6%9D%BF%E9%A2%98/"/>
    
    
    <category term="并查集" scheme="https://benyang0506.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>linux基本操作</title>
    <link href="https://benyang0506.github.io/2021/09/29/linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>https://benyang0506.github.io/2021/09/29/linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</id>
    <published>2021-09-29T12:52:11.000Z</published>
    <updated>2021-10-01T03:10:48.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux基本操作"><a href="#Linux基本操作" class="headerlink" title="Linux基本操作"></a>Linux基本操作</h2><h5 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h5><p>列出目标目录中所有子目录和文件的信息</p><p>命令语法：ls [选项] [目录或文件名]</p><span id="more"></span><p>命令示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -a</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /etc</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>-a：—all的缩写，显示所有的文件，包括隐藏文件(以.开头的文件)</li><li>-l：列出长数据串，显示出文件的属性与权限等数据信息</li></ul><h5 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h5><p>显示当前工作目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure><h5 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h5><p>切换当前工作目录至目标目录</p><p>命令语法：cd [dirName]</p><p>命令示例：切换至/etc/目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /etc</span><br></pre></td></tr></table></figure><p>参数dirName常用解释：</p><ul><li>绝对路径：从根目录开始,依次将各级子目录的名字组合起来，路径的写法一定是由根目录 / 写起，例如 /usr/local/ ”</li><li>相对路径：相对当前所在路径的位置，路径的写法不是由根目录“ / ”写起，例如“ work/test ”</li><li>. ：”.” 表示目前所在的目录</li><li>.. : “..” 表示目前目录位置的上一层目录</li><li>～：表示当前用户的home目录，也就是刚 login 时所在的目录</li></ul><p>命令示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd sbin/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd .</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br></pre></td></tr></table></figure><h5 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h5><p>拷贝文件或目录</p><p>命令语法：cp [options] source dest</p><p>命令示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r abc cba</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/inittab ./</span><br></pre></td></tr></table></figure><p>常用参数</p><ul><li>-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。</li></ul><h5 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h5><p>创建目录</p><p>命令语法：mkdir [参数][目录名称]</p><p>命令示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir work</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir work/test</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p abc/test</span><br></pre></td></tr></table></figure><ul><li>-p：如果目录路径中的某级目录不存在，则自动创建</li></ul><h5 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h5><p>删除文件或目录</p><p>命令语法：mkdir [参数][目录名称]</p><p>命令示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm inittab</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -r abc</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf cba</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>-r：删除目录用的选项,使用命令rm删除目录时，一定要加-r选项</li><li>-f：表示强制删除</li></ul><p>注意：rm -rf命令非常危险，使用时一定要确保命令正确，路径不要以/开头。</p><p>如果不小心执行了“ rm -rf / ”，后果很严重，哭都来不及了</p><h5 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h5><p>将文件输出到标准输出</p><p>命令语法：cat [选项] [文件]</p><p>命令示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat inittab</span><br></pre></td></tr></table></figure><h5 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h5><p>移动文件或目录</p><p>命令语法：mv [选项] source dest</p><p>命令示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv inittab abc/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv work/ abc/</span><br></pre></td></tr></table></figure><h5 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h5><p>修改文件或目录的权限</p><p>命令语法：chmod [选项] [文件]</p><ul><li>上图中红色圈中的“rwx r-x r-x”，r代表读、w代表写、x代表执行、-代表没有权限。</li><li>第一个root代表该文件的所有者是root用户</li><li>第二个root代表该文件所属群组为root群组</li><li>rwx代表该文件所有者有读写执行权限</li><li>第一个r-x代表所在组的用户对该文件有读和执行的权限，没有写的权限</li><li>第二个r-x代表其他用户对该文件有读和执行的权限，没有写的权限</li></ul><p>解释说明：</p><ul><li>文件或目录权限控制分为读取(r)、写入(w)、执行(x)3种</li><li>具有全部权限的二进制可理解为 “111” 即 十进制的 “7”</li><li>只有读写权限二进制可理解为 “100” 即 十进制的 “4”</li></ul><p>命令示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 abc</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a-x abc</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x abc</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 755 abc</span><br></pre></td></tr></table></figure><p>常用参数解释：</p><ul><li>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是</li><li>+ 表示增加权限、- 表示取消权限</li><li>r 表示可读取，w 表示可写入，x 表示可执行</li><li>-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)</li></ul><h5 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h5><p>打包压缩或解压</p><p>命令语法：tar [选项] [文件…]</p><p>命令示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf abc.tar.gz abc/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf abc.tar.gz</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Linux基本操作&quot;&gt;&lt;a href=&quot;#Linux基本操作&quot; class=&quot;headerlink&quot; title=&quot;Linux基本操作&quot;&gt;&lt;/a&gt;Linux基本操作&lt;/h2&gt;&lt;h5 id=&quot;ls命令&quot;&gt;&lt;a href=&quot;#ls命令&quot; class=&quot;headerlink&quot; title=&quot;ls命令&quot;&gt;&lt;/a&gt;ls命令&lt;/h5&gt;&lt;p&gt;列出目标目录中所有子目录和文件的信息&lt;/p&gt;
&lt;p&gt;命令语法：ls [选项] [目录或文件名]&lt;/p&gt;</summary>
    
    
    
    <category term="互联网软件开发技术与实践" scheme="https://benyang0506.github.io/categories/%E4%BA%92%E8%81%94%E7%BD%91%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="linux" scheme="https://benyang0506.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>寻找重复数</title>
    <link href="https://benyang0506.github.io/2021/09/16/%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/"/>
    <id>https://benyang0506.github.io/2021/09/16/%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/</id>
    <published>2021-09-16T02:00:56.000Z</published>
    <updated>2021-09-16T08:27:56.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><p>传送门：<a href="&lt;https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">&lt;https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a>&gt;</p><p><a href="http://10.129.27.27/contest/9/problem/1002">http://10.129.27.27/contest/9/problem/1002</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p><p>要求算法空间复杂度为 O(1) (不包括输入数组).</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>输入包含两行, 第一行为一个正整数 n, 第二行为 n + 1 个正整数.</p><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>输出为单独一行, 即所有给出的数中重复的数.</p><h5 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 3 4 2 2</span><br></pre></td></tr></table></figure><h5 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h5 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">3 1 3 4 2</span><br></pre></td></tr></table></figure><h5 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="方法一：二分"><a href="#方法一：二分" class="headerlink" title="方法一：二分"></a>方法一：二分</h4><p>我们用$cnt[i]$来记录原数组中小于等于$i$的个数，假设重复的数为$ans$，则<code>1&lt;i&lt;ans</code>时，<code>cnt[i]&lt;=i</code>，<code>ans&lt;=i&lt;=n</code>时，<code>cnt[i]&gt;i</code>；</p><p>已知答案一定在1到$n$之间，二分的思路是每次猜一个数$mid$，然后统计原数组中小于等于$mid$的个数$cnt$，利用上述性质进行二分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 二分</span></span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&lt;=mid)&#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 符合条件</span></span><br><span class="line">            <span class="keyword">if</span>(cnt&gt;mid)&#123;</span><br><span class="line">                r=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(nlgn)$，空间复杂度$O(1)$。</p><h4 id="方法二：位运算"><a href="#方法二：位运算" class="headerlink" title="方法二：位运算"></a>方法二：位运算</h4><p>我们定义数组$v1$，$v1[i]$记录数字1~n的二进制表示中，第$i$位为1的数量；</p><p>接着定义数组$v2$，$v2[i]$记录$nums$数组中所有数的二进制表示中，第$i$位为1的数量。</p><p>因为重复的数会多次出现，所以存在$i$，有$v1[i]&gt;v2[i]$，所有这些$i$的二进制表示组成的和即为重复的数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// 最大位数</span></span><br><span class="line">        <span class="keyword">int</span> bit_Max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(t)&#123;</span><br><span class="line">            t&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            bit_Max++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bit_Max;i++)&#123;</span><br><span class="line">            v1.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">            v2.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bit_Max;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((j&gt;&gt;i)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                    v1[i]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bit_Max;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((nums[j])&gt;&gt;i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                    v2[i]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bit_Max;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v2[i]&gt;v1[i])&#123;</span><br><span class="line">                ans=ans+(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(nlgn)$，空间复杂度$O(1)$。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;p&gt;传送门：&lt;a href=&quot;&amp;lt;https://leetcode-cn.com/problems/intersection-of-two-linked-lists/&quot;&gt;&amp;lt;https://leetcode-cn.com/problems/intersection-of-two-linked-lists/&lt;/a&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://10.129.27.27/contest/9/problem/1002&quot;&gt;http://10.129.27.27/contest/9/problem/1002&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="课堂作业" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E8%AF%BE%E5%A0%82%E4%BD%9C%E4%B8%9A/"/>
    
    
    <category term="双指针" scheme="https://benyang0506.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="位运算" scheme="https://benyang0506.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="二分" scheme="https://benyang0506.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>大餐计数</title>
    <link href="https://benyang0506.github.io/2021/07/08/%E5%A4%A7%E9%A4%90%E8%AE%A1%E6%95%B0/"/>
    <id>https://benyang0506.github.io/2021/07/08/%E5%A4%A7%E9%A4%90%E8%AE%A1%E6%95%B0/</id>
    <published>2021-07-08T07:33:26.000Z</published>
    <updated>2021-07-08T09:04:30.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><p>7.7 每日一题</p><p>传送门：<a href="https://leetcode-cn.com/problems/count-good-meals/">https://leetcode-cn.com/problems/count-good-meals/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p><strong>大餐</strong> 是指 <strong>恰好包含两道不同餐品</strong> 的一餐，其美味程度之和等于 2 的幂。</p><p>你可以搭配 <strong>任意</strong> 两道餐品做一顿大餐。</p><p>给你一个整数数组 <code>deliciousness</code> ，其中 <code>deliciousness[i]</code> 是第 <code>i</code> 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 <strong>大餐</strong> 的数量。结果需要对 <code>1e9 + 7</code> 取余。</p><p>注意，只要餐品下标不同，就可以认为是不同的餐品，即便它们的美味程度相同。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：deliciousness = [1,3,5,7,9]</span><br><span class="line">输出：4</span><br><span class="line">解释：大餐的美味程度组合为 (1,3) 、(1,7) 、(3,5) 和 (7,9) 。</span><br><span class="line">它们各自的美味程度之和分别为 4 、8 、8 和 16 ，都是 2 的幂。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：deliciousness = [1,1,1,3,3,3,7]</span><br><span class="line">输出：15</span><br><span class="line">解释：大餐的美味程度组合为 3 种 (1,1) ，9 种 (1,3) ，和 3 种 (1,7) 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= deliciousness.length &lt;= 1e5</span><br><span class="line">0 &lt;= deliciousness[i] &lt;= 2的20次方</span><br></pre></td></tr></table></figure><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>朴素做法，两层循环枚举两个点，判断和是否为2的幂。</p><h6 id="优化：判断是否为2的幂，有五种方法。"><a href="#优化：判断是否为2的幂，有五种方法。" class="headerlink" title="优化：判断是否为2的幂，有五种方法。"></a>优化：判断是否为2的幂，有五种方法。</h6><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><p>求出第一个大于等于$x$的2的幂，然后判断是否等于。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(k&lt;x)&#123;</span><br><span class="line">k*=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> k==x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(logx)$。</p><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>思路同方法一，但求第一个大于等于$x$的2的幂时通过位运算实现。</p><p>举个栗子，$x=65$，$x-1=64$，二进制表示为$10000000$</p><p>$x|=x&gt;&gt;1$，$x=10000000|01000000=11000000$</p><p>$x|=x&gt;&gt;2$，$x=11000000|00110000=11110000$</p><p>$x|=x&gt;&gt;4$，$x=11110000|00001111=11111111$</p><p>之后$x$无改变，二进制表示每一位均变为$1$，$+1$为$128$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t=x;</span><br><span class="line">x-=<span class="number">1</span>;</span><br><span class="line">x|=x&gt;&gt;<span class="number">1</span>;</span><br><span class="line">x|=x&gt;&gt;<span class="number">2</span>;</span><br><span class="line">x|=x&gt;&gt;<span class="number">4</span>;</span><br><span class="line">x|=x&gt;&gt;<span class="number">8</span>;</span><br><span class="line">x|=x&gt;&gt;<span class="number">16</span>;</span><br><span class="line">x=x&lt;<span class="number">0</span>?<span class="number">1</span>:x+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> x==t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(1)$。</p><h5 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h5><p>为$0$时需要特判</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> (x&amp;(x<span class="number">-1</span>))==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(1)$。</p><h5 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h5><p>为$0$时需要特判</p><p>$ps$：$’==’$优先级比’&amp;’高，所以要加$’()’$，不然结果会出错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> (x&amp;-x)==x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(1)$。</p><h5 id="方法五"><a href="#方法五" class="headerlink" title="方法五"></a>方法五</h5><p>除此之外此题可以先打表，以便判断是否为2的幂，又$x$最大2的21次幂，所以打到21就好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>&gt; ump1; </span><br><span class="line"><span class="keyword">int</span> tmp=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">21</span>;i++)&#123;</span><br><span class="line">    ump1[tmp]=<span class="literal">true</span>;</span><br><span class="line">    tmp*=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(1)$。</p><p>但枚举的时间复杂度为$O(n^2)$，还是会$TLE$，这里只是趁机总结了几种判断一个数是否为2的幂次的方法。</p><h6 id="优化：对第二层枚举，可以考虑枚举2的幂，然后判断差是否在数组中，此处可以通过哈希表实现。边插入边统计，保证不会重复计算。"><a href="#优化：对第二层枚举，可以考虑枚举2的幂，然后判断差是否在数组中，此处可以通过哈希表实现。边插入边统计，保证不会重复计算。" class="headerlink" title="优化：对第二层枚举，可以考虑枚举2的幂，然后判断差是否在数组中，此处可以通过哈希表实现。边插入边统计，保证不会重复计算。"></a>优化：对第二层枚举，可以考虑枚举2的幂，然后判断差是否在数组中，此处可以通过哈希表实现。边插入边统计，保证不会重复计算。</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 哈希表</span></span><br><span class="line">        <span class="comment">// 两个数之和最大为2的21次方，先打个表，存2的0,1,2...,21次幂，记2的幂次共有c个，c=22</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> cnt=<span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>&gt; ump1; </span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">21</span>;i++)&#123;</span><br><span class="line">            ump1[tmp]=<span class="literal">true</span>;</span><br><span class="line">            tmp*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; ump2; <span class="comment">// d中元素的数量</span></span><br><span class="line">        <span class="comment">// 边插入边统计，保证不会重复计算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:d)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j:ump1)&#123;                </span><br><span class="line">                <span class="keyword">if</span>(ump2.<span class="built_in">count</span>(j.first-i))&#123;</span><br><span class="line">                    cnt=(cnt+ump2[j.first-i])%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ump2[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(n*logC)$，$C$为元素值上限。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;p&gt;7.7 每日一题&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/count-good-meals/&quot;&gt;https://leetcode-cn.com/problems/count-good-meals/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="每日一题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="哈希表" scheme="https://benyang0506.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="位运算" scheme="https://benyang0506.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>单词接龙</title>
    <link href="https://benyang0506.github.io/2021/06/25/%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/"/>
    <id>https://benyang0506.github.io/2021/06/25/%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/</id>
    <published>2021-06-25T07:55:17.000Z</published>
    <updated>2021-07-08T09:02:48.859Z</updated>
    
    <content type="html"><![CDATA[<p>127 单词接龙</p><p>传送门：<a href="https://leetcode-cn.com/problems/minimum-absolute-difference-queries/">https://leetcode-cn.com/problems/minimum-absolute-difference-queries/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>字典 <code>wordList</code> 中从单词 <code>beginWord</code> 和 <code>endWord</code> 的 <strong>转换序列</strong> 是一个按下述规格形成的序列：</p><ul><li>序列中第一个单词是 <code>beginWord</code> 。</li><li>序列中最后一个单词是 <code>endWord</code> 。</li><li>每次转换只能改变一个字母。</li><li>转换过程中的中间单词必须是字典 <code>wordList</code> 中的单词。</li></ul><p>给你两个单词 <code>beginWord</code> 和 <code>endWord</code> 和一个字典 <code>wordList</code> ，找到从 <code>beginWord</code> 到 <code>endWord</code> 的 <strong>最短转换序列</strong> 中的 <strong>单词数目</strong> 。如果不存在这样的转换序列，返回 0。</p><p><strong>示例 1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">输出：5</span><br><span class="line">解释：一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, 返回它的长度 5。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line">输出：0</span><br><span class="line">解释：endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= beginWord.length &lt;= 10</span><br><span class="line">endWord.length == beginWord.length</span><br><span class="line">1 &lt;= wordList.length &lt;= 5000</span><br><span class="line">wordList[i].length == beginWord.length</span><br><span class="line">beginWord、endWord 和 wordList[i] 由小写英文字母组成</span><br><span class="line">beginWord != endWord</span><br><span class="line">wordList 中的所有字符串互不相同</span><br></pre></td></tr></table></figure><h3 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h3><p>可以看作最短路问题，这里的每个单词就是一种状态，可以看作一个点，如何两个单词只相差一个字母，那么这两个字母之间就存在一条边，求两个点之间的最短路。</p><p>首先，如果$endWord$不在$wordList$中，不可能存在一种转换序列，返回0；</p><p>标记$wordList$中单词是否访问可以用$map$，每次扩展考虑当前单词的每一位，每一位有25种替换方法，又1 &lt;= beginWord.length &lt;= 10，第一层就有<code>25*10=250</code>种，第二层有<code>250*250=62500</code>种，第三层…，但最多只有<code>5000*250=1250000</code>。</p><p>直到扩展到$endWord$，返回步数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// bfs</span></span><br><span class="line">    string s,e;</span><br><span class="line">    unordered_map&lt;string,<span class="keyword">bool</span>&gt; ump;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">        queue&lt;string&gt; q;</span><br><span class="line">        unordered_map&lt;string,<span class="keyword">int</span>&gt; d;</span><br><span class="line">        q.<span class="built_in">push</span>(s);</span><br><span class="line">        d[s]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            string t=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(t==e) <span class="keyword">return</span> d[t];</span><br><span class="line">            <span class="keyword">int</span> dis=d[t];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> j=<span class="string">&#x27;a&#x27;</span>;j&lt;=<span class="string">&#x27;z&#x27;</span>;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j==t[i]) <span class="keyword">continue</span>;</span><br><span class="line">                    string tt=t.<span class="built_in">substr</span>(<span class="number">0</span>,i)+j+t.<span class="built_in">substr</span>(i+<span class="number">1</span>,t.<span class="built_in">size</span>()<span class="number">-1</span>-i);</span><br><span class="line">                    <span class="comment">// cout&lt;&lt;t&lt;&lt;&quot; &quot;&lt;&lt;tt&lt;&lt;&quot; &quot;;</span></span><br><span class="line">                    <span class="keyword">if</span>(ump[tt])&#123;</span><br><span class="line">                        <span class="keyword">if</span>(d.<span class="built_in">count</span>(tt)==<span class="number">0</span>)&#123;</span><br><span class="line">                            d[tt]=dis+<span class="number">1</span>;</span><br><span class="line">                            q.<span class="built_in">push</span>(tt);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:wordList)&#123;</span><br><span class="line">            ump[i]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s=beginWord;</span><br><span class="line">        e=endWord;</span><br><span class="line">        <span class="keyword">if</span>(!ump[endWord]) <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">bfs</span>()==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bfs</span>()+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="双向bfs"><a href="#双向bfs" class="headerlink" title="双向bfs"></a>双向bfs</h3><p>为了解决$bfs$搜索空间爆炸的问题，加速查找，可以用双向$bfs$，从$beginWord$和$endWord$分别查找。</p><p>两个方向分别$bfs$，每次选择状态数量较少的队列来扩展，可以使两个队列元素数量分布平均，也为了加快遍历的速度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 双向bfs，解决空间爆炸问题</span></span><br><span class="line">    unordered_map&lt;string,<span class="keyword">bool</span>&gt; ump;</span><br><span class="line">    <span class="comment">// beginWord和endWord</span></span><br><span class="line">    string s,e;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// queue:bfs</span></span><br><span class="line">        queue&lt;string&gt; q1,q2;</span><br><span class="line">        <span class="comment">// 标记步数，防止某一状态被重复访问</span></span><br><span class="line">        <span class="comment">// d1[s]=k：由beginWord转换到s需要k次</span></span><br><span class="line">        <span class="comment">// d2[s]=k：由endWord转换到s需要k次</span></span><br><span class="line">        unordered_map&lt;string,<span class="keyword">int</span>&gt; d1,d2;</span><br><span class="line">        q1.<span class="built_in">push</span>(s);</span><br><span class="line">        d1[s]=<span class="number">0</span>;</span><br><span class="line">        q2.<span class="built_in">push</span>(e);</span><br><span class="line">        d2[e]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果有一个queue为空，说明这一端搜到底都搜不到endWord/beginWord</span></span><br><span class="line">        <span class="comment">// 只有两个queue都为空，才有必要继续搜索</span></span><br><span class="line">        <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>()&amp;&amp;!q2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">// 不是双向各走一步，是每次选择一个方向走一步（入队）</span></span><br><span class="line">            <span class="comment">// 为了使两个队列元素数量分布平均，也为了加快遍历的速度，选择元素较少的队列</span></span><br><span class="line">            <span class="keyword">if</span>(q1.<span class="built_in">size</span>()&lt;=q2.<span class="built_in">size</span>())&#123;</span><br><span class="line">                string t=q1.<span class="built_in">front</span>();</span><br><span class="line">                q1.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(d2.<span class="built_in">count</span>(t)!=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> d1[t]+d2[t];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> j=<span class="string">&#x27;a&#x27;</span>;j&lt;=<span class="string">&#x27;z&#x27;</span>;j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(j!=t[i])&#123;</span><br><span class="line">                            string tt=t.<span class="built_in">substr</span>(<span class="number">0</span>,i)+j+t.<span class="built_in">substr</span>(i+<span class="number">1</span>,t.<span class="built_in">size</span>()<span class="number">-1</span>-i);</span><br><span class="line">                            <span class="keyword">if</span>(ump[tt])&#123;</span><br><span class="line">                                <span class="keyword">if</span>(d1.<span class="built_in">count</span>(tt)==<span class="number">0</span>)&#123;</span><br><span class="line">                                    q1.<span class="built_in">push</span>(tt);</span><br><span class="line">                                    d1[tt]=d1[t]+<span class="number">1</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                string t=q2.<span class="built_in">front</span>();</span><br><span class="line">                q2.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(d1.<span class="built_in">count</span>(t)!=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> d1[t]+d2[t];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> j=<span class="string">&#x27;a&#x27;</span>;j&lt;=<span class="string">&#x27;z&#x27;</span>;j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(j!=t[i])&#123;</span><br><span class="line">                            string tt=t.<span class="built_in">substr</span>(<span class="number">0</span>,i)+j+t.<span class="built_in">substr</span>(i+<span class="number">1</span>,t.<span class="built_in">size</span>()<span class="number">-1</span>-i);</span><br><span class="line">                            <span class="keyword">if</span>(ump[tt])&#123;</span><br><span class="line">                                <span class="keyword">if</span>(d2.<span class="built_in">count</span>(tt)==<span class="number">0</span>)&#123;</span><br><span class="line">                                    q2.<span class="built_in">push</span>(tt);</span><br><span class="line">                                    d2[tt]=d2[t]+<span class="number">1</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i: wordList)&#123;</span><br><span class="line">            ump[i]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!ump[endWord]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        s=beginWord;</span><br><span class="line">        e=endWord;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bfs</span>()+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>计算双向$bfs$的时间复杂度：</p><p>记$wordList$长度为$n$，字符串长度为$m$，搜索的结果都会在$wordList$中出现过（不符合条件的剪枝，不入队），加上起点共$n+1$个，</p><p>最坏情况所有结点两两连通，$n$个结点进入队列，每个结点$n$条出边，时间复杂度$O(n^2)$，每次找出边时，时间复杂度$O(m)$，总时间复杂度$O(m*n^2)$。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;127 单词接龙&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-absolute-difference-queries/&quot;&gt;https://leetcode-cn.com/problems/minimum-absolute-difference-queries/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    
    <category term="bfs" scheme="https://benyang0506.github.io/tags/bfs/"/>
    
    <category term="双向bfs" scheme="https://benyang0506.github.io/tags/%E5%8F%8C%E5%90%91bfs/"/>
    
  </entry>
  
  <entry>
    <title>查询差绝对值的最小值</title>
    <link href="https://benyang0506.github.io/2021/06/23/%E6%9F%A5%E8%AF%A2%E5%B7%AE%E7%BB%9D%E5%AF%B9%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
    <id>https://benyang0506.github.io/2021/06/23/%E6%9F%A5%E8%AF%A2%E5%B7%AE%E7%BB%9D%E5%AF%B9%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</id>
    <published>2021-06-23T06:01:28.000Z</published>
    <updated>2021-06-23T06:26:06.613Z</updated>
    
    <content type="html"><![CDATA[<p>第246场周赛 D</p><p>传送门：<a href="https://leetcode-cn.com/problems/minimum-absolute-difference-queries/">https://leetcode-cn.com/problems/minimum-absolute-difference-queries/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>一个数组 <code>a</code> 的 <strong>差绝对值的最小值</strong> 定义为：<code>0 &lt;= i &lt; j &lt; a.length</code> 且 <code>a[i] != a[j]</code> 的 <code>|a[i] - a[j]|</code> 的 <strong>最小值</strong>。如果 <code>a</code> 中所有元素都 <strong>相同</strong> ，那么差绝对值的最小值为 <code>-1</code> 。</p><ul><li>比方说，数组 <code>[5,**2**,**3**,7,2]</code> 差绝对值的最小值是 <code>|2 - 3| = 1</code> 。注意答案不为 <code>0</code> ，因为 <code>a[i]</code> 和 <code>a[j]</code> 必须不相等。</li></ul><p>给你一个整数数组 <code>nums</code> 和查询数组 <code>queries</code> ，其中 <code>queries[i] = [li, ri]</code> 。对于每个查询 <code>i</code> ，计算 <strong>子数组</strong> <code>nums[li...ri]</code> 中 <strong>差绝对值的最小值</strong> ，子数组 <code>nums[li...ri]</code> 包含 <code>nums</code> 数组（下标从 <strong>0</strong> 开始）中下标在 <code>li</code> 和 <code>ri</code> 之间的所有元素（包含 <code>li</code> 和 <code>ri</code> 在内）。</p><p>请你返回 <code>ans</code> <strong>数组</strong>，其中 <code>ans[i]</code> 是第 <code>i</code> 个查询的答案。</p><p><strong>子数组</strong> 是一个数组中连续的一段元素。</p><p><code>|x|</code> 的值定义为：</p><ul><li>如果 <code>x &gt;= 0</code> ，那么值为 <code>x</code> 。</li><li>如果 <code>x &lt; 0</code> ，那么值为 <code>-x</code> 。</li></ul><p><strong>示例 1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,4,8], queries = [[0,1],[1,2],[2,3],[0,3]]</span><br><span class="line">输出：[2,1,4,1]</span><br><span class="line">解释：查询结果如下：</span><br><span class="line">- queries[0] = [0,1]：子数组是 [1,3] ，差绝对值的最小值为 |1-3| = 2 。</span><br><span class="line">- queries[1] = [1,2]：子数组是 [3,4] ，差绝对值的最小值为 |3-4| = 1 。</span><br><span class="line">- queries[2] = [2,3]：子数组是 [4,8] ，差绝对值的最小值为 |4-8| = 4 。</span><br><span class="line">- queries[3] = [0,3]：子数组是 [1,3,4,8] ，差的绝对值的最小值为 |3-4| = 1 。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,5,2,2,7,10], queries = [[2,3],[0,2],[0,5],[3,5]]</span><br><span class="line">输出：[-1,1,1,3]</span><br><span class="line">解释：查询结果如下：</span><br><span class="line">- queries[0] = [2,3]：子数组是 [2,2] ，差绝对值的最小值为 -1 ，因为所有元素相等。</span><br><span class="line">- queries[1] = [0,2]：子数组是 [4,5,2] ，差绝对值的最小值为 |4-5| = 1 。</span><br><span class="line">- queries[2] = [0,5]：子数组是 [4,5,2,2,7,10] ，差绝对值的最小值为 |4-5| = 1 。</span><br><span class="line">- queries[3] = [3,5]：子数组是 [2,7,10] ，差绝对值的最小值为 |7-10| = 3 。</span><br></pre></td></tr></table></figure><h5 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 &lt;= nums.length &lt;= 1e5</span><br><span class="line">1 &lt;= nums[i] &lt;= 100</span><br><span class="line">1 &lt;= queries.length &lt;= 2 * 1e4</span><br><span class="line">0 &lt;= li &lt; ri &lt; nums.length</span><br></pre></td></tr></table></figure><h4 id="前缀和-哈希"><a href="#前缀和-哈希" class="headerlink" title="前缀和+哈希"></a>前缀和+哈希</h4><ul><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><p>数组中数据范围只有100，可以看作突破口。</p><p>预处理前缀和，我们在判断某个数时，如果出现过记为1，没有出现过记为0。</p><p>$q[i][j]$：数字$i$在前$j$位出现过多少次。</p><p>预处理前缀和：<code>10^5*100=10^7​</code>。</p><p>预处理前缀和，可以将判断<code>num[i]</code>中某个数是否出现过的时间复杂度优化为$O(1)$，对每次询问判断差值最大值只需要扫一次$1-100$，共<code>2*10^4*100=2*10^6</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// q[i][j]:</span></span><br><span class="line">    <span class="keyword">int</span> q[<span class="number">102</span>][<span class="number">100002</span>];</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">minDifference</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 &lt;= nums[i] &lt;= 100</span></span><br><span class="line">        <span class="comment">// 暴力：对每次询问 2*1e4： 哈希表扫一次区间1e5，找max1e2，时间复杂度O(2*1e9)</span></span><br><span class="line">        <span class="comment">// 优化：对每次询问 2*1e4：判断1-100每个数是否出现（可以优化到O（100）），找1e2，时间复杂度O(2*1e6)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理0-100每个数是否出现过</span></span><br><span class="line">        <span class="comment">// 对数组中的每个数x，nums[i]==x置为1，nums[i]!=x置为0；</span></span><br><span class="line">        <span class="comment">// 预处理用前缀和O(1e5*1e2)=O(1e7)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tnt=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]==i) tnt=<span class="number">1</span>;</span><br><span class="line">                q[i][j+<span class="number">1</span>]=q[i][j]+tnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以不用vector来存，然后再遍历求Min</span></span><br><span class="line">        <span class="comment">// 不需要额外开空间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;queries.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> last=<span class="number">-1</span>; <span class="comment">// 上一个出现过的数</span></span><br><span class="line">            <span class="keyword">int</span> Min=<span class="number">101</span>;</span><br><span class="line">            <span class="keyword">int</span> l=queries[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> r=queries[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">100</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(q[j][r+<span class="number">1</span>]-q[j][l]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 更新Min</span></span><br><span class="line">                    <span class="keyword">if</span>(last!=<span class="number">-1</span>)&#123;</span><br><span class="line">                        Min=<span class="built_in">min</span>(Min,j-last);</span><br><span class="line">                    &#125;</span><br><span class="line">                    last=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Min==<span class="number">101</span>) Min=<span class="number">-1</span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(Min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;第246场周赛 D&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-absolute-difference-queries/&quot;&gt;https://leetcode-cn.com/problems/minimum-absolute-difference-queries/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="周赛" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="哈希表" scheme="https://benyang0506.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="前缀和" scheme="https://benyang0506.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>统计子岛屿</title>
    <link href="https://benyang0506.github.io/2021/06/23/%E7%BB%9F%E8%AE%A1%E5%AD%90%E5%B2%9B%E5%B1%BF/"/>
    <id>https://benyang0506.github.io/2021/06/23/%E7%BB%9F%E8%AE%A1%E5%AD%90%E5%B2%9B%E5%B1%BF/</id>
    <published>2021-06-23T05:39:29.000Z</published>
    <updated>2021-06-23T05:59:25.201Z</updated>
    
    <content type="html"><![CDATA[<p>第246场周赛 C</p><p>传送门：<a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给你两个 <code>m x n</code> 的二进制矩阵 <code>grid1</code> 和 <code>grid2</code> ，它们只包含 <code>0</code> （表示水域）和 <code>1</code> （表示陆地）。一个 <strong>岛屿</strong> 是由 <strong>四个方向</strong> （水平或者竖直）上相邻的 <code>1</code> 组成的区域。任何矩阵以外的区域都视为水域。</p><p>如果 <code>grid2</code> 的一个岛屿，被 <code>grid1</code> 的一个岛屿 <strong>完全</strong> 包含，也就是说 <code>grid2</code> 中该岛屿的每一个格子都被 <code>grid1</code> 中同一个岛屿完全包含，那么我们称 <code>grid2</code> 中的这个岛屿为 <strong>子岛屿</strong> 。</p><p>请你返回 <code>grid2</code> 中 <strong>子岛屿</strong> 的 <strong>数目</strong> 。</p><p><strong>示例 1</strong></p><p><img src="/2021/06/23/%E7%BB%9F%E8%AE%A1%E5%AD%90%E5%B2%9B%E5%B1%BF/Snipaste_2021-06-23_13-50-41.png" alt></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]</span><br><span class="line">输出：3</span><br><span class="line">解释：如上图所示，左边为 grid1 ，右边为 grid2 。</span><br><span class="line">grid2 中标红的 1 区域是子岛屿，总共有 3 个子岛屿。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><p><img src="/2021/06/23/%E7%BB%9F%E8%AE%A1%E5%AD%90%E5%B2%9B%E5%B1%BF/Snipaste_2021-06-23_13-51-35.png" alt></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]</span><br><span class="line">输出：2 </span><br><span class="line">解释：如上图所示，左边为 grid1 ，右边为 grid2 。</span><br><span class="line">grid2 中标红的 1 区域是子岛屿，总共有 2 个子岛屿。</span><br></pre></td></tr></table></figure><h5 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m == grid1.length == grid2.length</span><br><span class="line">n == grid1[i].length == grid2[i].length</span><br><span class="line">1 &lt;= m, n &lt;= 500</span><br><span class="line">grid1[i][j] 和 grid2[i][j] 都要么是 0 要么是 1 。</span><br></pre></td></tr></table></figure><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>对grid2中的某一个连通块，如果其中的每一个位置在grid1中都为1，那么ans++；（满足此性质的连通块在grid1中也一定是联通的。）</p><p>$FloodFill$搭配$bfs$和$dfs$应该都可以，用$dfs$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// bool vis[501][501]; 不需要vis，可以直接使用g2来判断vis，走过的话将g2[i][j]=0;</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; g1,g2;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 访问到某一个点</span></span><br><span class="line">        <span class="comment">// g2标记访问过</span></span><br><span class="line">        g2[x][y]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 判断g1中是否为1</span></span><br><span class="line">        <span class="keyword">if</span>(!g1[x][y]) flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;   </span><br><span class="line">            x=x+dx[i];</span><br><span class="line">            y=y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;row&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;col&amp;&amp;g2[x][y])&#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">dfs</span>(x,y))</span><br><span class="line">                    flag=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x=x-dx[i];</span><br><span class="line">            y=y-dy[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubIslands</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid1, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 思路：对grid2中的某一个连通块，如果其中的每一个位置在grid1中都为1，那么ans++；（满足此性质的连通块在grid1中也一定是联通的。</span></span><br><span class="line">        g1=grid1;</span><br><span class="line">        g2=grid2;</span><br><span class="line">        col=g2[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        row=g2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(g2[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">dfs</span>(i,j))&#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;第246场周赛 C&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/&quot;&gt;https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="周赛" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="dfs" scheme="https://benyang0506.github.io/tags/dfs/"/>
    
    <category term="FloodFill" scheme="https://benyang0506.github.io/tags/FloodFill/"/>
    
  </entry>
  
  <entry>
    <title>二进制中1的个数</title>
    <link href="https://benyang0506.github.io/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>https://benyang0506.github.io/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</id>
    <published>2021-06-23T02:12:28.000Z</published>
    <updated>2021-06-23T02:20:27.778Z</updated>
    
    <content type="html"><![CDATA[<p>6.23 每日一题</p><p>传送门：<a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p><p><strong>示例 1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#x27;1&#x27;。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：00000000000000000000000010000000</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#x27;1&#x27;。</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#x27;1&#x27;。</span><br></pre></td></tr></table></figure><h5 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入必须是长度为 32 的 二进制串 。</span><br></pre></td></tr></table></figure><h4 id="移位-判断"><a href="#移位-判断" class="headerlink" title="移位+判断"></a>移位+判断</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=n&amp;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(x) cnt++;</span><br><span class="line">            n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(k)$，$k$为$n$的位数，为32.</p><h4 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h4><p><code>x&amp;(x-1)</code></p><p>把最低位的1变为0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// lowbit2:把最低位的1变为0</span></span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">lowbit2</span><span class="params">(<span class="keyword">uint32_t</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x&amp;(x<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            n=<span class="built_in">lowbit2</span>(n);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(lgn)$。</p><p><code>x&amp;-x</code></p><p>返回x的最后一位1（从低往高数）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// lowbit:返回x的最后一位1（从低往高数）</span></span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">lowbit2</span><span class="params">(<span class="keyword">uint32_t</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            n-=<span class="built_in">lowbit2</span>(n);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(lgn)$。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;6.23 每日一题&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/&quot;&gt;https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="每日一题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="位运算" scheme="https://benyang0506.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>字符串的排列</title>
    <link href="https://benyang0506.github.io/2021/06/22/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <id>https://benyang0506.github.io/2021/06/22/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</id>
    <published>2021-06-22T09:29:50.000Z</published>
    <updated>2021-06-23T02:11:54.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><p>6.22 每日一题</p><p>传送门：<a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p> <strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure><h5 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= s 的长度 &lt;= 8</span><br></pre></td></tr></table></figure><h4 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h4><p>先求出所有排列结果，然后用$set$去重。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">9</span>];</span><br><span class="line">    map&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>&gt; vis;</span><br><span class="line">    set&lt;string&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k,string s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            string t=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                t=t+s[d[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">insert</span>(t);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">                vis[i]=<span class="literal">true</span>;</span><br><span class="line">                d[k]=i;</span><br><span class="line">                <span class="built_in">dfs</span>(k+<span class="number">1</span>,s);</span><br><span class="line">                vis[i]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">permutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,s);</span><br><span class="line">        vector&lt;string&gt; per;</span><br><span class="line">        per.<span class="built_in">assign</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> per;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(2^8*s)$</p><p>运行时间534ms。</p><h4 id="dfs-1"><a href="#dfs-1" class="headerlink" title="dfs"></a>dfs</h4><p>先求出所有排列结果，然后用$vector$排序再去重。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">9</span>];</span><br><span class="line">    map&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>&gt; vis;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k,string s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            string t=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                t=t+s[d[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(t);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">                vis[i]=<span class="literal">true</span>;</span><br><span class="line">                d[k]=i;</span><br><span class="line">                <span class="built_in">dfs</span>(k+<span class="number">1</span>,s);</span><br><span class="line">                vis[i]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">permutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,s);</span><br><span class="line">        <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line">        ans.<span class="built_in">erase</span>(<span class="built_in">unique</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>()),ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行时间424ms。</p><h4 id="dfs-剪枝"><a href="#dfs-剪枝" class="headerlink" title="dfs+剪枝"></a>dfs+剪枝</h4><p>在$dfs$的时候对重复的排列进行剪枝。</p><p>具体做法：先对$s$进行排序，使得相同元素相邻，然后在$dfs$的过程中，对$s[i]==s[i-1],vis[i-1]==true)$剪枝，因为相同元素$dfs$出来的结果一定相同，后面条件避免在一次排列中相同字符只能用一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">9</span>];</span><br><span class="line">    map&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>&gt; vis;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k,string s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            string t=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                t=t+s[d[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(t);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">// 剪枝，有重复元素跳过</span></span><br><span class="line">            <span class="comment">// 后面条件避免在一次排列中相同字符只能用一次</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;s[i]==s[i<span class="number">-1</span>]&amp;&amp;vis[i<span class="number">-1</span>]==<span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">                vis[i]=<span class="literal">true</span>;</span><br><span class="line">                d[k]=i;</span><br><span class="line">                <span class="built_in">dfs</span>(k+<span class="number">1</span>,s);</span><br><span class="line">                vis[i]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">permutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,s);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行时间116ms。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;p&gt;6.22 每日一题&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/&quot;&gt;https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="每日一题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="dfs" scheme="https://benyang0506.github.io/tags/dfs/"/>
    
  </entry>
  
  <entry>
    <title>二进制手表</title>
    <link href="https://benyang0506.github.io/2021/06/21/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%89%8B%E8%A1%A8/"/>
    <id>https://benyang0506.github.io/2021/06/21/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%89%8B%E8%A1%A8/</id>
    <published>2021-06-21T14:59:48.000Z</published>
    <updated>2021-06-21T15:10:27.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><p>6.21 每日一题</p><p>传送门：<a href="https://leetcode-cn.com/problems/binary-watch/">https://leetcode-cn.com/problems/binary-watch/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>二进制手表顶部有 4 个 LED 代表 <strong>小时（0-11）</strong>，底部的 6 个 LED 代表 <strong>分钟（0-59）</strong>。每个 LED 代表一个 0 或 1，最低位在右侧。</p><ul><li>例如，下面的二进制手表读取 <code>&quot;3:25&quot;</code> 。</li></ul><p><img src="/2021/06/21/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%89%8B%E8%A1%A8/binary_clock_samui_moon.jpg" alt></p><p>给你一个整数 <code>turnedOn</code> ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 <strong>按任意顺序</strong> 返回答案。</p><p>小时不会以零开头：</p><ul><li>例如，<code>&quot;01:00&quot;</code> 是无效的时间，正确的写法应该是 <code>&quot;1:00&quot;</code> 。</li></ul><p>分钟必须由两位数组成，可能会以零开头：</p><ul><li>例如，<code>&quot;10:2&quot;</code> 是无效的时间，正确的写法应该是 <code>&quot;10:02&quot;</code> 。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：turnedOn = 1</span><br><span class="line">输出：[&quot;0:01&quot;,&quot;0:02&quot;,&quot;0:04&quot;,&quot;0:08&quot;,&quot;0:16&quot;,&quot;0:32&quot;,&quot;1:00&quot;,&quot;2:00&quot;,&quot;4:00&quot;,&quot;8:00&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：turnedOn = 9</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h5 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= turnedOn &lt;= 10</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="方法一：dfs"><a href="#方法一：dfs" class="headerlink" title="方法一：dfs"></a>方法一：dfs</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// dfs</span></span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">11</span>];</span><br><span class="line">    map&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>&gt; vis;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; hm=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>&#125;;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> turnedOn)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==turnedOn)&#123;</span><br><span class="line">            <span class="keyword">int</span> h=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> m=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;turnedOn;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(d[i]&lt;<span class="number">4</span>)&#123;</span><br><span class="line">                    h=h+hm[d[i]];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    m=m+hm[d[i]];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(h&gt;<span class="number">11</span>||m&gt;<span class="number">59</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            string s=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            s+=<span class="built_in">to_string</span>(h);</span><br><span class="line">            s+=<span class="string">&quot;:&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(m&lt;<span class="number">10</span>)&#123;</span><br><span class="line">                s+=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s+=<span class="built_in">to_string</span>(m);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">                vis[i]=<span class="literal">true</span>;</span><br><span class="line">                d[k]=i;</span><br><span class="line">                <span class="built_in">dfs</span>(k+<span class="number">1</span>,turnedOn);</span><br><span class="line">                vis[i]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">readBinaryWatch</span><span class="params">(<span class="keyword">int</span> turnedOn)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,turnedOn);</span><br><span class="line">        <span class="comment">// 去重</span></span><br><span class="line">        <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line">        ans.<span class="built_in">erase</span>(<span class="built_in">unique</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>()),ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="方法二：枚举-二进制判断"><a href="#方法二：枚举-二进制判断" class="headerlink" title="方法二：枚举+二进制判断"></a>方法二：枚举+二进制判断</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculateBin</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">readBinaryWatch</span><span class="params">(<span class="keyword">int</span> turnedOn)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 枚举所有时分，然后计算时分中二进制下一的个数，排除不符合条件的结果</span></span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> sumOfBin;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">11</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">59</span>;j++)&#123;</span><br><span class="line">                sumOfBin=<span class="number">0</span>;</span><br><span class="line">                sumOfBin=sumOfBin+<span class="built_in">calculateBin</span>(i)+<span class="built_in">calculateBin</span>(j);</span><br><span class="line">                <span class="keyword">if</span>(sumOfBin==turnedOn)&#123;</span><br><span class="line">                    string s=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                    s+=<span class="built_in">to_string</span>(i);</span><br><span class="line">                    s+=<span class="string">&quot;:&quot;</span>;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">to_string</span>(j).<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">                        s+=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    s+=<span class="built_in">to_string</span>(j);</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;p&gt;6.21 每日一题&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/binary-watch/&quot;&gt;https://leetcode-cn.com/problems/binary-watch/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="每日一题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="dfs" scheme="https://benyang0506.github.io/tags/dfs/"/>
    
  </entry>
  
  <entry>
    <title>串联字符串的最大长度</title>
    <link href="https://benyang0506.github.io/2021/06/21/%E4%B8%B2%E8%81%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6/"/>
    <id>https://benyang0506.github.io/2021/06/21/%E4%B8%B2%E8%81%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6/</id>
    <published>2021-06-21T14:37:31.000Z</published>
    <updated>2021-06-21T14:51:10.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><p>6.19 每日一题</p><p>传送门：<a href="https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/">https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给定一个字符串数组 <code>arr</code>，字符串 <code>s</code> 是将 <code>arr</code> 某一子序列字符串连接所得的字符串，如果 <code>s</code> 中的每一个字符都只出现过一次，那么它就是一个可行解。</p><p>请返回所有可行解 <code>s</code> 中最长长度。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;]</span><br><span class="line">输出：4</span><br><span class="line">解释：所有可能的串联组合是 &quot;&quot;,&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;,&quot;uniq&quot; 和 &quot;ique&quot;，最大长度为 4。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [&quot;cha&quot;,&quot;r&quot;,&quot;act&quot;,&quot;ers&quot;]</span><br><span class="line">输出：6</span><br><span class="line">解释：可能的解答有 &quot;chaers&quot; 和 &quot;acters&quot;。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [&quot;abcdefghijklmnopqrstuvwxyz&quot;]</span><br><span class="line">输出：26</span><br></pre></td></tr></table></figure><h5 id="数据范围："><a href="#数据范围：" class="headerlink" title="数据范围："></a>数据范围：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= arr.length &lt;= 16</span><br><span class="line">1 &lt;= arr[i].length &lt;= 26</span><br><span class="line">arr[i] 中只含有小写英文字母</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>arr.length &lt;= 16，可以dfs。</p><p>最近能dfs就dfs，多练习下，之前总是因为写的太丑TLE。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">int</span> Max=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//考虑到第k个字符串；当前连接得的字符串的长度；字符串数组arr</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> len,vector&lt;string&gt;&amp; arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==arr.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 一个string如果自己有重复元素，直接跳过</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr[k].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            mp2[arr[k][i]]++;</span><br><span class="line">            <span class="keyword">if</span>(mp2[arr[k][i]]&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">                flag=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存在一个字符，之前已经出现过，当前字符串就不能选</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr[k].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[arr[k][i]]!=<span class="number">0</span>)&#123;</span><br><span class="line">                flag=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可选</span></span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr[k].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                mp[arr[k][i]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            len+=arr[k].<span class="built_in">size</span>();</span><br><span class="line">            Max=<span class="built_in">max</span>(Max,len);</span><br><span class="line">            <span class="built_in">dfs</span>(k+<span class="number">1</span>,len,arr);</span><br><span class="line">            <span class="comment">// 选</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr[k].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                mp[arr[k][i]]--;</span><br><span class="line">            &#125;</span><br><span class="line">            len-=arr[k].<span class="built_in">size</span>();</span><br><span class="line">            <span class="built_in">dfs</span>(k+<span class="number">1</span>,len,arr);</span><br><span class="line">            <span class="comment">// 不选（先还原状态）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(k+<span class="number">1</span>,len,arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxLength</span><span class="params">(vector&lt;string&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dfs可以写</span></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,arr);</span><br><span class="line">        <span class="keyword">return</span> Max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>明天填坑剪枝优化。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;p&gt;6.19 每日一题&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/&quot;&gt;https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="每日一题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="dfs" scheme="https://benyang0506.github.io/tags/dfs/"/>
    
  </entry>
  
  <entry>
    <title>石子游戏</title>
    <link href="https://benyang0506.github.io/2021/06/16/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/"/>
    <id>https://benyang0506.github.io/2021/06/16/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/</id>
    <published>2021-06-16T09:24:09.000Z</published>
    <updated>2021-06-17T05:18:05.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><p>6.16 每日一题</p><p>传送门：<a href="https://leetcode-cn.com/problems/stone-game/">https://leetcode-cn.com/problems/stone-game/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>亚历克斯和李用几堆石子在做游戏。偶数堆石子<strong>排成一行</strong>，每堆都有正整数颗石子 <code>piles[i]</code> 。</p><p>游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。</p><p>亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。</p><p>假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 <code>true</code> ，当李赢得比赛时返回 <code>false</code> 。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例：</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：[5,3,4,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。</span><br><span class="line">假设他取了前 5 颗，这一行就变成了 [3,4,5] 。</span><br><span class="line">如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。</span><br><span class="line">如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。</span><br><span class="line">这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。</span><br></pre></td></tr></table></figure><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 &lt;= piles.length &lt;= 500</span><br><span class="line">piles.length 是偶数。</span><br><span class="line">1 &lt;= piles[i] &lt;= 500</span><br><span class="line">sum(piles) 是奇数。</span><br></pre></td></tr></table></figure><h4 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h4><p>如果数据范围小一点，可以$dfs$。</p><h4 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h4><p>因为$piles.length$是偶数，所以可以把$piles$分为奇数项和偶数项，所以在每一个回合，先手玩家可以限制后手玩家只能取（奇数项/偶数项）。</p><p>因此只需要提前比较奇数项和与偶数项和的大小，先手玩家选择较大的就好，从而先手必胜。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">stoneGame</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h4><p>每次拿石头均从最左侧或最右侧拿，所以保证剩下的石子堆是连续的，可以划分为更小的子问题。</p><p>$f[i][j]$：区间$[i,j]$的石子赢取的最大差值。</p><h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><p>$i&gt;j$时没有意义，初始化为0；</p><p>$i=j$时，$f[i][j]=piles[i]$，取第$i$堆石子可以拿到最大差值；</p><h6 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h6><p>$f[i][j]=max(piles[i]-f[i+1,j],piles[j]-f[i,j-1])$；</p><p>因为每个人每次都要做最优决策，而状态转移$f[i][j]$的状态又是由相邻的状态转移来的，相邻的状态是对手的最优决策，所以计算时做<strong>减法</strong>。</p><h5 id="区间dp写法"><a href="#区间dp写法" class="headerlink" title="区间dp写法"></a>区间dp写法</h5><p>1、先枚举长度，再枚举左端点（右端点由左端点和长度计算得来）。</p><p>2、先枚举左端点，再枚举右端点（注意枚举顺序，保证状态更新时用到的状态在之前已经计算过/保证结果在最后推出）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// f[i][j]：区间[i,j]堆石子，玩家可以得到的最大差值</span></span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">501</span>][<span class="number">501</span>];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">stoneGame</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;piles.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                f[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;piles.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            f[i][i]=piles[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 区间dp，先枚举len，再枚举左端点。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=piles.<span class="built_in">size</span>();len++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l+len<span class="number">-1</span>&lt;piles.<span class="built_in">size</span>();l++)&#123;</span><br><span class="line">                <span class="keyword">int</span> r=l+len<span class="number">-1</span>;</span><br><span class="line">                f[l][r]=<span class="built_in">max</span>(piles[l]-f[l+<span class="number">1</span>][r],piles[r]-f[l][r<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f[<span class="number">0</span>][piles.<span class="built_in">size</span>()<span class="number">-1</span>]&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">501</span>][<span class="number">501</span>];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">stoneGame</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 区间dp初始化</span></span><br><span class="line">        <span class="comment">// 没有意义的状态i&gt;j</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;piles.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                f[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i=j </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;piles.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;piles.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j)&#123;</span><br><span class="line">                    f[i][j]=piles[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 状态转移，注意枚举顺序</span></span><br><span class="line">        <span class="comment">// 枚举方法：先枚举左端点，再枚举右端点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=piles.<span class="built_in">size</span>()<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;piles.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                f[i][j]=<span class="built_in">max</span>(piles[i]-f[i+<span class="number">1</span>][j],piles[j]-f[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>][piles.<span class="built_in">size</span>()]&gt;=<span class="number">0</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h4><p>因为每个状态只和左边和下边的状态有关，可以将动态规划的空间优化为一维$f[501]$。</p><p><img src="/2021/06/16/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/Snipaste_2021-06-17_13-13-51.png" alt></p><p>原转移：</p><p><code>f[i][j]=max(piles[i]-f[i+1][j],piles[j]-f[i][j-1]);</code></p><p>压缩后转移：</p><p><code>f[j]=max(piles[i]-f[j],piles[j]-f[j-1]);</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">501</span>];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">stoneGame</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;piles.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            f[i]=piles[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 状态转移，注意枚举顺序</span></span><br><span class="line">        <span class="comment">// 枚举方法：先枚举左端点，再枚举右端点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=piles.<span class="built_in">size</span>()<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;piles.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                f[j]=<span class="built_in">max</span>(piles[i]-f[j],piles[j]-f[j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[piles.<span class="built_in">size</span>()]&gt;=<span class="number">0</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;p&gt;6.16 每日一题&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/stone-game/&quot;&gt;https://leetcode-cn.com/problems/stone-game/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="每日一题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="dp" scheme="https://benyang0506.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>数位成本和为目标值的最大数字</title>
    <link href="https://benyang0506.github.io/2021/06/15/%E6%95%B0%E4%BD%8D%E6%88%90%E6%9C%AC%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97/"/>
    <id>https://benyang0506.github.io/2021/06/15/%E6%95%B0%E4%BD%8D%E6%88%90%E6%9C%AC%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97/</id>
    <published>2021-06-15T07:54:06.000Z</published>
    <updated>2021-06-15T08:36:28.506Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><p>6.12 每日一题</p><p>传送门：<a href="https://leetcode-cn.com/problems/form-largest-integer-with-digits-that-add-up-to-target/">https://leetcode-cn.com/problems/form-largest-integer-with-digits-that-add-up-to-target/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给你一个整数数组 <code>cost</code> 和一个整数 <code>target</code> 。请你返回满足如下规则可以得到的 <strong>最大</strong> 整数：</p><ul><li>给当前结果添加一个数位（<code>i + 1</code>）的成本为 <code>cost[i]</code> （<code>cost</code> 数组下标从 0 开始）。</li><li>总成本必须恰好等于 <code>target</code> 。</li><li>添加的数位中没有数字 0 。</li></ul><p>由于答案可能会很大，请你以字符串形式返回。</p><p>如果按照上述要求无法得到任何整数，请你返回 “0” 。</p><h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a><strong>示例 1：</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [4,3,2,5,6,7,2,5,5], target = 9</span><br><span class="line">输出：&quot;7772&quot;</span><br><span class="line">解释：添加数位 &#x27;7&#x27; 的成本为 2 ，添加数位 &#x27;2&#x27; 的成本为 3 。所以 &quot;7772&quot; 的代价为 2*3+ 3*1 = 9 。 &quot;977&quot; 也是满足要求的数字，但 &quot;7772&quot; 是较大的数字。</span><br><span class="line"> 数字     成本</span><br><span class="line">  1  -&gt;   4</span><br><span class="line">  2  -&gt;   3</span><br><span class="line">  3  -&gt;   2</span><br><span class="line">  4  -&gt;   5</span><br><span class="line">  5  -&gt;   6</span><br><span class="line">  6  -&gt;   7</span><br><span class="line">  7  -&gt;   2</span><br><span class="line">  8  -&gt;   5</span><br><span class="line">  9  -&gt;   5</span><br></pre></td></tr></table></figure><h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a><strong>示例 2：</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [7,6,5,5,5,6,8,7,8], target = 12</span><br><span class="line">输出：&quot;85&quot;</span><br><span class="line">解释：添加数位 &#x27;8&#x27; 的成本是 7 ，添加数位 &#x27;5&#x27; 的成本是 5 。&quot;85&quot; 的成本为 7 + 5 = 12 。</span><br></pre></td></tr></table></figure><h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a><strong>示例 3：</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [2,4,6,2,4,6,4,4,4], target = 5</span><br><span class="line">输出：&quot;0&quot;</span><br><span class="line">解释：总成本是 target 的条件下，无法生成任何整数。</span><br></pre></td></tr></table></figure><h4 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a><strong>示例 4：</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [6,10,15,40,40,40,40,40,40], target = 47</span><br><span class="line">输出：&quot;32211&quot;</span><br></pre></td></tr></table></figure><h4 id="数据范围："><a href="#数据范围：" class="headerlink" title="数据范围："></a>数据范围：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cost.length == 9</span><br><span class="line">1 &lt;= cost[i] &lt;= 5000</span><br><span class="line">1 &lt;= target &lt;= 5000</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>要求输出最大的整数：首先根据长度比较，长度较长的数较大；其次数字长度相同，从高位到地位依次比较。</p><h5 id="dp-贪心输出方案"><a href="#dp-贪心输出方案" class="headerlink" title="dp+贪心输出方案"></a>dp+贪心输出方案</h5><p>$f[i][j]$：从前$i$个数中选，每个数可以取无数次，代价（类比完全背包中的体积）为$j$的取法中，取得的物品数（数字位数）最多是多少。</p><p>输出方案时按从$9-1$的次序输出，参考完全背包中输出方案的写法。</p><p><a href="https://zhuanlan.zhihu.com/p/139368825">https://zhuanlan.zhihu.com/p/139368825</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">10</span>][<span class="number">5001</span>];</span><br><span class="line">    <span class="function">string <span class="title">largestNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; cost, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将cost看成体积，体积恰好为target的情况下取得的物品数最多是多少。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=target;j++)&#123;</span><br><span class="line">                f[i][j]=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=target;j++)&#123;</span><br><span class="line">                f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=cost[i<span class="number">-1</span>])&#123;</span><br><span class="line">                    f[i][j]=<span class="built_in">max</span>(f[i][j],f[i][j-cost[i<span class="number">-1</span>]]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// f[9][target]:总成本为target，最多取多少个数。</span></span><br><span class="line">        <span class="keyword">if</span>(f[<span class="number">9</span>][target]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string ans=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> t=target;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">9</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(t&gt;=cost[i<span class="number">-1</span>]&amp;&amp;f[i][t]==f[i][t-cost[i<span class="number">-1</span>]]+<span class="number">1</span>)&#123;</span><br><span class="line">                ans+=<span class="string">&#x27;0&#x27;</span>+i;</span><br><span class="line">                t-=cost[i<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="优化空间"><a href="#优化空间" class="headerlink" title="优化空间"></a>优化空间</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">5001</span>];</span><br><span class="line">    <span class="function">string <span class="title">largestNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; cost, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将cost看成体积，体积恰好为target的情况下取得的物品数最多是多少。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=target;j++)&#123;</span><br><span class="line">             f[j]=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=cost[i<span class="number">-1</span>];j&lt;=target;j++)&#123;</span><br><span class="line">                f[j]=<span class="built_in">max</span>(f[j],f[j-cost[i<span class="number">-1</span>]]+<span class="number">1</span>);</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f[target]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string ans=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> t=target;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">9</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(t&gt;=cost[i<span class="number">-1</span>]&amp;&amp;f[t]==f[t-cost[i<span class="number">-1</span>]]+<span class="number">1</span>)&#123;</span><br><span class="line">                ans+=<span class="string">&#x27;0&#x27;</span>+i;</span><br><span class="line">                t-=cost[i<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(9*target)$，空间复杂度$O(target)$。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;p&gt;6.12 每日一题&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/form-largest-integer-with-digits-that-add-up-to-target/&quot;&gt;https://leetcode-cn.com/problems/form-largest-integer-with-digits-that-add-up-to-target/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="每日一题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="dp" scheme="https://benyang0506.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>完全平方数</title>
    <link href="https://benyang0506.github.io/2021/06/15/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"/>
    <id>https://benyang0506.github.io/2021/06/15/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</id>
    <published>2021-06-15T05:55:52.000Z</published>
    <updated>2021-06-15T08:12:08.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><p>6.11 每日一题</p><p>传送门：<a href="https://leetcode-cn.com/problems/perfect-squares/">https://leetcode-cn.com/problems/perfect-squares/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给定正整数 <em>n</em>，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 <em>n</em>。你需要让组成和的完全平方数的个数最少。</p><p>给你一个整数 <code>n</code> ，返回和为 <code>n</code> 的完全平方数的 <strong>最少数量</strong> 。</p><p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：3 </span><br><span class="line">解释：12 = 4 + 4 + 4</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 13</span><br><span class="line">输出：2</span><br><span class="line">解释：13 = 4 + 9</span><br></pre></td></tr></table></figure><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= n &lt;= 1e4</span><br></pre></td></tr></table></figure><h4 id="lc题解"><a href="#lc题解" class="headerlink" title="lc题解"></a>lc题解</h4><p>$f[i]$表示至少需要多少个完全平方数来组成$i$，假设$j$是组成$i$的其中一个完全平方数，则$f[i]=f[i-j^2]+1$，形成递推关系，每次只需要从完全平方数中找$f[i-j^2]$较小的即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// f[i]：和为i的完全平方数的最少数量</span></span><br><span class="line">        <span class="comment">// f[i]=f[i-j^2]+1; //j为其中一个组成i的完全平方数</span></span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">10001</span>];</span><br><span class="line">        f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            f[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">sqrt</span>(i);j++)&#123;</span><br><span class="line">                f[i]=<span class="built_in">min</span>(f[i],f[i-j*j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>将题意转化为：用给定数组中的数来组成$n$，每个数可以取无数次，求最少需要多少个数。</p><p>裸的完全背包，需要注意的是求$min$而不是$max$，用给定的完全平方数恰好组成$n$，而不是不超过$n$，（$n$就相当于完全背包中的体积）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// f[i][j]：只考虑前i个数，恰好组成j，取得最少的数量</span></span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">101</span>][<span class="number">10001</span>]; </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                f[i][j]=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//和为n，用给定数组中的数来凑，每个数可以取无数次（完全背包），求取得最少数量。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="comment">// for(int k=0;k*i*i&lt;=j;k++)&#123;</span></span><br><span class="line">                <span class="comment">//     f[i][j]=min(f[i][j],f[i-1][j-k*i*i]+k);</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=i*i)&#123;</span><br><span class="line">                    f[i][j]=<span class="built_in">min</span>(f[i][j],f[i][j-i*i]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[(<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n)][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>优化空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// f[i][j]：只考虑前i个数，恰好组成j，取得最少的数量</span></span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">10001</span>]; </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            f[i]=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//和为n，用给定数组中的数来凑，每个数可以取无数次（完全背包），求取得最少数量。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i*i;j&lt;=n;j++)&#123;</span><br><span class="line">                 f[j]=<span class="built_in">min</span>(f[j],f[j-i*i]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n*sqrt(n))$，空间复杂度$O(n)$。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;p&gt;6.11 每日一题&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/perfect-squares/&quot;&gt;https://leetcode-cn.com/problems/perfect-squares/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="每日一题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="dp" scheme="https://benyang0506.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>零钱兑换II</title>
    <link href="https://benyang0506.github.io/2021/06/11/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II/"/>
    <id>https://benyang0506.github.io/2021/06/11/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II/</id>
    <published>2021-06-11T07:55:41.000Z</published>
    <updated>2021-06-11T08:39:12.992Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><p>6.10 每日一题</p><p>传送门：<a href="https://leetcode-cn.com/problems/coin-change-2/">https://leetcode-cn.com/problems/coin-change-2/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p><p>假设每一种面额的硬币有无限个。 </p><p>题目数据保证结果符合 32 位带符号整数。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：amount = <span class="number">5</span>, coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：有四种方式可以凑成总金额：</span><br><span class="line"><span class="number">5</span>=<span class="number">5</span></span><br><span class="line"><span class="number">5</span>=<span class="number">2</span>+<span class="number">2</span>+<span class="number">1</span></span><br><span class="line"><span class="number">5</span>=<span class="number">2</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span></span><br><span class="line"><span class="number">5</span>=<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：amount = <span class="number">3</span>, coins = [<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：只用面额 <span class="number">2</span> 的硬币不能凑成总金额 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：amount = <span class="number">10</span>, coins = [<span class="number">10</span>] </span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= coins.length &lt;= 300</span><br><span class="line">1 &lt;= coins[i] &lt;= 5000</span><br><span class="line">coins 中的所有值互不相同</span><br><span class="line">0 &lt;= amount &lt;= 5000</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">501</span>][<span class="number">5001</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, vector&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp[i][j]:只用前i种硬币，恰好能组成j的方法种数</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=coins.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=amount;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k*coins[i<span class="number">-1</span>]&lt;=j;k++)&#123;</span><br><span class="line">                    dp[i][j]+=dp[i<span class="number">-1</span>][j-k*coins[i<span class="number">-1</span>]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[coins.<span class="built_in">size</span>()][amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度<code>O(n*amount*amount)</code>，空间复杂度​<code>O(n*amount)​</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">501</span>][<span class="number">5001</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, vector&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp[i][j]:只用前i种硬币，恰好能组成j的方法种数</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=coins.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=amount;j++)&#123;</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=coins[i<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j]+=dp[i][j-coins[i<span class="number">-1</span>]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[coins.<span class="built_in">size</span>()][amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度<code>O(n*amount)​</code>，空间复杂度​<code>O(n*amount)​</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int dp[5001];</span><br><span class="line">    int change(int amount, vector&lt;int&gt;&amp; coins) &#123;</span><br><span class="line">        // dp[i][j]:只用前i种硬币，恰好能组成j的方法种数</span><br><span class="line">        dp[0]=1;</span><br><span class="line">        for(int i=1;i&lt;=coins.size();i++)&#123;</span><br><span class="line">            for(int j=coins[i-1];j&lt;=amount;j++)&#123;</span><br><span class="line">                dp[j]=dp[j]+dp[j-coins[i-1]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度<code>O(n*amount)​</code>，空间复杂度​<code>O(amount)​</code>。</p><p>优化类似完全背包模型。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;p&gt;6.10 每日一题&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/coin-change-2/&quot;&gt;https://leetcode-cn.com/problems/coin-change-2/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="每日一题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="dp" scheme="https://benyang0506.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>盈利计划</title>
    <link href="https://benyang0506.github.io/2021/06/11/%E7%9B%88%E5%88%A9%E8%AE%A1%E5%88%92/"/>
    <id>https://benyang0506.github.io/2021/06/11/%E7%9B%88%E5%88%A9%E8%AE%A1%E5%88%92/</id>
    <published>2021-06-11T07:13:11.000Z</published>
    <updated>2021-06-11T07:52:02.610Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><p>6.9 每日一题</p><p>传送门：<a href="https://leetcode-cn.com/problems/profitable-schemes/">https://leetcode-cn.com/problems/profitable-schemes/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>集团里有 <code>n</code> 名员工，他们可以完成各种各样的工作创造利润。</p><p>第 <code>i</code> 种工作会产生 <code>profit[i]</code> 的利润，它要求 <code>group[i]</code> 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。</p><p>工作的任何至少产生 <code>minProfit</code> 利润的子集称为 <strong>盈利计划</strong> 。并且工作的成员总数最多为 <code>n</code> 。</p><p>有多少种计划可以选择？因为答案很大，所以 <strong>返回结果模</strong> <code>10^9 + 7</code> <strong>的值</strong>。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5, minProfit = 3, group = [2,2], profit = [2,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：至少产生 3 的利润，该集团可以完成工作 0 和工作 1 ，或仅完成工作 1 。</span><br><span class="line">总的来说，有两种计划。</span><br><span class="line"></span><br><span class="line">输入：n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8]</span><br><span class="line">输出：7</span><br><span class="line">解释：至少产生 5 的利润，只要完成其中一种工作就行，所以该集团可以完成任何工作。</span><br><span class="line">有 7 种可能的计划：(0)，(1)，(2)，(0,1)，(0,2)，(1,2)，以及 (0,1,2) 。</span><br></pre></td></tr></table></figure><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= n &lt;= 100</span><br><span class="line">0 &lt;= minProfit &lt;= 100</span><br><span class="line">1 &lt;= group.length &lt;= 100</span><br><span class="line">1 &lt;= group[i] &lt;= 100</span><br><span class="line">profit.length == group.length</span><br><span class="line">0 &lt;= profit[i] &lt;= 100</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>三维$dp$，考虑为什么用三维，首先考虑前$i$个员工，成员数限制（类似背包问题的体积），利润（类似背包问题价值），属性是方法种数，很自然就会想到三维。</p><p><code>f[i][j][k]: 考虑前i种工作，代价恰好为j，获得至少利润k的方法种数。</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">profitableSchemes</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> minProfit, vector&lt;<span class="keyword">int</span>&gt;&amp; group, vector&lt;<span class="keyword">int</span>&gt;&amp; profit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;profit.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            sum+=profit[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="comment">// 需要考虑三维dp</span></span><br><span class="line">        <span class="comment">// f[i][j][k]: 考虑前i种工作，代价恰好为j，获得至少利润k的方法种数。</span></span><br><span class="line">        <span class="comment">// 时间复杂度：100*100*100=1e6</span></span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">101</span>][<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=group.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=minProfit;k++)&#123;</span><br><span class="line">                    f[i][j][k]=f[i<span class="number">-1</span>][j][k];</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=group[i<span class="number">-1</span>])&#123;</span><br><span class="line">                        f[i][j][k]=(f[i][j][k]+f[i<span class="number">-1</span>][j-group[i<span class="number">-1</span>]][<span class="built_in">max</span>(<span class="number">0</span>,k-profit[i<span class="number">-1</span>])])%mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            count=(count+f[group.<span class="built_in">size</span>()][i][minProfit])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>f[i][j][k]=(f[i][j][k]+f[i-1][j-group[i-1]][max(0,k-profit[i-1])])%mod;</code>当中<code>max(0,k-profit[i-1])</code>其实相当于</p><p><code>if((k-profit[i-1])&gt;=0)</code>，<code>f[i][j][k]=(f[i][j][k]+f[i-1][j-group[i-1]][k-profit[i-1]])%mod;</code></p><p><code>else</code>，<code>f[i][j][k]=(f[i][j][k]+f[i-1][j-group[i-1]][0])%mod;</code></p><p>另一种写法：</p><p><code>f[i][j][k]: 考虑前i种工作，代价至多为j，获得至少利润k的方法种数。</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">profitableSchemes</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> minProfit, vector&lt;<span class="keyword">int</span>&gt;&amp; group, vector&lt;<span class="keyword">int</span>&gt;&amp; profit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;profit.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            sum+=profit[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="comment">// 需要考虑三维dp</span></span><br><span class="line">        <span class="comment">// f[i][j][k]: 考虑前i种工作，代价至多为j，获得至少利润k的方法种数。</span></span><br><span class="line">        <span class="comment">// 时间复杂度：100*100*100=1e6</span></span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">101</span>][<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line">        <span class="comment">// f[0][0][0]=1;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=group.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                f[i][j][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=group.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=minProfit;k++)&#123;</span><br><span class="line">                    f[i][j][k]=f[i<span class="number">-1</span>][j][k];</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=group[i<span class="number">-1</span>])&#123;</span><br><span class="line">                        f[i][j][k]=(f[i][j][k]+f[i<span class="number">-1</span>][j-group[i<span class="number">-1</span>]][<span class="built_in">max</span>(<span class="number">0</span>,k-profit[i<span class="number">-1</span>])])%mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[group.<span class="built_in">size</span>()][n][minProfit]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>$dp$数组要根据具体意义来初始化。</p><p>还可以优化到二维，类似01背包。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;p&gt;6.9 每日一题&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/profitable-schemes/&quot;&gt;https://leetcode-cn.com/problems/profitable-schemes/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="每日一题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="dp" scheme="https://benyang0506.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>最后一块石头的重量II</title>
    <link href="https://benyang0506.github.io/2021/06/11/%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII/"/>
    <id>https://benyang0506.github.io/2021/06/11/%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII/</id>
    <published>2021-06-11T05:25:36.000Z</published>
    <updated>2021-06-11T07:10:39.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><p>6.8 每日一题</p><p>传送门：<a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">https://leetcode-cn.com/problems/last-stone-weight-ii/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p><p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p><ul><li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li><li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li></ul><p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code>。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [2,7,4,1,8,1]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，</span><br><span class="line">组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，</span><br><span class="line">组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，</span><br><span class="line">组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [31,26,33,21,40]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= stones.length &lt;= 30</span><br><span class="line">1 &lt;= stones[i] &lt;= 100</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思考对于粉碎的两个石头，粉碎后的石头重量为$stones[i]-stones[j]$，用这个石头与$stones[k]$来粉碎，假设$stones[k]&gt;(stones[i]-stones[j])$，粉碎后的结果为$stones[k]-stones[i]+stones[j]$。</p><p>粉碎的本质就是给$stones$数组中每个数前面加<code>+</code> 和<code>-</code>。</p><h6 id="题意转化为给-stones-数组中每个数前面加-和-，使得最后结果的绝对值最小。"><a href="#题意转化为给-stones-数组中每个数前面加-和-，使得最后结果的绝对值最小。" class="headerlink" title="题意转化为给$stones$数组中每个数前面加+ 和-，使得最后结果的绝对值最小。"></a>题意转化为给$stones$数组中每个数前面加<code>+</code> 和<code>-</code>，使得最后结果的绝对值最小。</h6><p>记$stones$数组的和为$sum$，前面加<code>-</code>的数字的和为$neg$，$ans=sum-2*neg$，要使$ans$绝对值小，即$neg$取小于等于$sum/2$的最大的值。</p><h6 id="题意转化为从-stones-数组中找若干个数，使得若干个数的和（代价，类似01背包中的体积）在满足不超过-sum-2-的条件下最大。"><a href="#题意转化为从-stones-数组中找若干个数，使得若干个数的和（代价，类似01背包中的体积）在满足不超过-sum-2-的条件下最大。" class="headerlink" title="题意转化为从$stones$数组中找若干个数，使得若干个数的和（代价，类似01背包中的体积）在满足不超过$sum/2$的条件下最大。"></a>题意转化为从$stones$数组中找若干个数，使得若干个数的和（代价，类似01背包中的体积）在满足不超过$sum/2$的条件下最大。</h6><p>到这就是裸的01背包。</p><p>有几种dp的写法：</p><h5 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h5><p>状态表示：</p><p><code>dp[i][j]</code></p><p>集合：从前$i$个数中取，代价（和）不超过$j$的取法。</p><p>属性：和的最大值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">30001</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;stones.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            sum+=stones[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=sum/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=stones.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=ans;j&gt;=stones[i<span class="number">-1</span>];j--)&#123;</span><br><span class="line">                    dp[j]=<span class="built_in">max</span>(dp[j],dp[j-stones[i<span class="number">-1</span>]]+stones[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum<span class="number">-2</span>*dp[ans];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h5><p>状态表示：</p><p><code>dp[i][j]</code></p><p>集合：从前$i$个数中取，得到总和为$j$的取法。</p><p>属性：数量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;stones.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            sum+=stones[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=sum/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">// f[i][j]:从前i个石头选，得到总和为j的方法的种数。</span></span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">31</span>][<span class="number">1501</span>];</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=stones.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=ans;j++)&#123;</span><br><span class="line">                f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=stones[i<span class="number">-1</span>])&#123;</span><br><span class="line">                    f[i][j]=f[i][j]+f[i<span class="number">-1</span>][j-stones[i<span class="number">-1</span>]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> neg=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=ans;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(f[stones.<span class="built_in">size</span>()][i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                neg=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum<span class="number">-2</span>*neg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h5><p>状态表示：</p><p><code>dp[i][j]</code></p><p>集合：从前$i$个数中取，得到总和为$j$的取法。</p><p>属性：0或1代表是否能够有这种取法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">30001</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;stones.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            sum+=stones[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">int</span> tmp=sum/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//f[i][j]表示是否可以用前i个数组成j，只有0，1两种情况</span></span><br><span class="line">        <span class="comment">//优化为一维</span></span><br><span class="line">        <span class="comment">// int f[30001];</span></span><br><span class="line">        f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=stones.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=tmp;j&gt;=stones[i<span class="number">-1</span>];j--)&#123;</span><br><span class="line">                    f[j]=<span class="built_in">max</span>(f[j],f[j-stones[i<span class="number">-1</span>]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=tmp;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(f[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span> sum<span class="number">-2</span>*i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;p&gt;6.8 每日一题&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/last-stone-weight-ii/&quot;&gt;https://leetcode-cn.com/problems/last-stone-weight-ii/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="每日一题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="dp" scheme="https://benyang0506.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>目标和</title>
    <link href="https://benyang0506.github.io/2021/06/11/%E7%9B%AE%E6%A0%87%E5%92%8C/"/>
    <id>https://benyang0506.github.io/2021/06/11/%E7%9B%AE%E6%A0%87%E5%92%8C/</id>
    <published>2021-06-11T02:42:43.000Z</published>
    <updated>2021-06-15T06:02:27.918Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><p>6.7 每日一题</p><p>传送门：<a href="https://leetcode-cn.com/problems/target-sum/">https://leetcode-cn.com/problems/target-sum/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>向数组中的每个整数前添加 <code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p><ul><li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>&#39;+&#39;</code> ，在 <code>1</code> 之前添加 <code>&#39;-&#39;</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li></ul><p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1,1,1], target = 3</span><br><span class="line">输出：5</span><br><span class="line">解释：一共有 5 种方法让最终目标和为 3 。</span><br><span class="line">-1 + 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 - 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 - 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 - 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 + 1 - 1 = 3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1], target = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h5 id="数据范围："><a href="#数据范围：" class="headerlink" title="数据范围："></a>数据范围：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums.length &lt;= 20</span><br><span class="line">0 &lt;= nums[i] &lt;= 1000</span><br><span class="line">0 &lt;= sum(nums[i]) &lt;= 1000</span><br><span class="line">-1000 &lt;= target &lt;= 1000</span><br></pre></td></tr></table></figure><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k, vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">2</span>]=&#123;<span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(k==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">            sum=sum+nums[k]*a[i];</span><br><span class="line">            <span class="built_in">dfs</span>(k+<span class="number">1</span>, nums, target, sum);</span><br><span class="line">            sum=sum-nums[k]*a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, nums, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(2^n)$，每次在倒数几个测试点TLE，应该是<code>sum=sum+nums[k]*a[i]</code>这被卡常了?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// int a[2]=&#123;-1, 1&#125;;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k, vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(k+<span class="number">1</span>, nums, target, sum-nums[k]);</span><br><span class="line">        <span class="built_in">dfs</span>(k+<span class="number">1</span>, nums, target, sum+nums[k]);</span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;2;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     sum=sum+nums[k]*a[i];</span></span><br><span class="line">        <span class="comment">//     dfs(k+1, nums, target, sum);</span></span><br><span class="line">        <span class="comment">//     sum=sum-nums[k]*a[i];</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, nums, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(2^n)$</p><p>空间复杂度$O(n)$</p><h3 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h3><h5 id="将题目转化为-dp-题"><a href="#将题目转化为-dp-题" class="headerlink" title="将题目转化为$dp$题"></a>将题目转化为$dp$题</h5><p>记$nums$数组总和为$sum$，每给一个$nums[k]$前加<code>&#39;-&#39;</code>，表达式的值$ans=sum-2<em>nums[k]$，假设所有加<code>&#39;-&#39;</code>的数字的和为$neg$，$ans=sum-2</em>neg$，$ans==target$时满足条件。</p><p>反过来，从$nums$中找若干个数，和为$(sum-target)/2$，使其前面加<code>&#39;-&#39;</code>，即可满足条件。</p><p>$(sum-target)mod2!=0$时，不符合条件。</p><p>$(sum-target)&lt;0$时，由于<code>0 &lt;= nums[i]</code>，从中找不到若干个数，使其和为$(sum-target)/2$，不符合条件。</p><h5 id="现在的问题变为，从-nums-中取若干数，使其和为-sum-target-2-，求方法数。"><a href="#现在的问题变为，从-nums-中取若干数，使其和为-sum-target-2-，求方法数。" class="headerlink" title="现在的问题变为，从$nums$中取若干数，使其和为$(sum-target)/2$，求方法数。"></a>现在的问题变为，从$nums$中取若干数，使其和为$(sum-target)/2$，求方法数。</h5><h6 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h6><p><code>dp[i][j]</code></p><p>集合：从前$i$个数中选，和为$j$的选法。</p><p>属性：选法总数。</p><h6 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h6><p>第$i$个数选不了，即<code>nums[i]&gt;j</code>，<code>dp[i][j]=dp[i-1][j]</code>；</p><p>第$i$个数可以选，即<code>nums[i]&lt;=j</code> ，<code>dp[i][j]=dp[i-1][j]+dp[i-1][j-nums[i]]</code></p><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=sum-target; <span class="comment">//必为偶数，否则配不出来。</span></span><br><span class="line">        <span class="keyword">if</span>(ans%<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//负数也凑不出来，因为num[i]都是非负数</span></span><br><span class="line">        <span class="keyword">if</span>(ans&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ans/=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">21</span>][<span class="number">2001</span>];</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=ans;j++)&#123;</span><br><span class="line">                f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(nums[i<span class="number">-1</span>]&lt;=j)&#123;</span><br><span class="line">                    f[i][j]+=f[i<span class="number">-1</span>][j-nums[i<span class="number">-1</span>]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[nums.<span class="built_in">size</span>()][ans];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n*ans)$</p><p>空间复杂度：$O(n*ans)$</p><p>空间复杂度还可以优化到$O(ans)$。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;p&gt;6.7 每日一题&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/target-sum/&quot;&gt;https://leetcode-cn.com/problems/target-sum/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="每日一题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="dp" scheme="https://benyang0506.github.io/tags/dp/"/>
    
    <category term="dfs" scheme="https://benyang0506.github.io/tags/dfs/"/>
    
  </entry>
  
  <entry>
    <title>一和零</title>
    <link href="https://benyang0506.github.io/2021/06/10/%E4%B8%80%E5%92%8C%E9%9B%B6/"/>
    <id>https://benyang0506.github.io/2021/06/10/%E4%B8%80%E5%92%8C%E9%9B%B6/</id>
    <published>2021-06-10T15:03:09.000Z</published>
    <updated>2021-06-11T02:59:31.329Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><p>6.6 每日一题</p><p>传送门：<a href="https://leetcode-cn.com/problems/ones-and-zeroes/">https://leetcode-cn.com/problems/ones-and-zeroes/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code> 。</p><p>请你找出并返回 <code>strs</code> 的最大子集的大小，该子集中 <strong>最多</strong> 有 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 。</p><p>如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合 <code>x</code> 是集合 <code>y</code> 的 <strong>子集</strong> 。</p><p><img src="/2021/06/10/%E4%B8%80%E5%92%8C%E9%9B%B6/Snipaste_2021-06-10_23-08-56.png" alt></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>和01背包类似，每个字符串的0和1的数量为代价，要求选尽可能多的字符串。</p><h6 id="预处理："><a href="#预处理：" class="headerlink" title="预处理："></a>预处理：</h6><p>先用两个$vector$记录每个字符串中0和1的数量。</p><h6 id="状态表示："><a href="#状态表示：" class="headerlink" title="状态表示："></a>状态表示：</h6><p><code>f[i][j][k]</code></p><p>集合：从前$i$个物品中选，0的数量不超过$j$，1的数量不超过$k$的选法。</p><p>属性：选的字符串个数的最大值。</p><h6 id="状态转移："><a href="#状态转移：" class="headerlink" title="状态转移："></a>状态转移：</h6><p>如果第$i$个字符串不可选，即<code>zero[i]&gt;j||one[i]&gt;k​</code>，转移方程​<code>f[i][j][k]=f[i-1][j][k]​</code>；</p><p>如果第$i$个字符串可选，即<code>j&gt;=zero[i-1]&amp;&amp;k&gt;=one[i-1]</code>，可以分为两种情况，选和不选。</p><p>不选：<code>f[i][j][k]=f[i-1][j][k]</code></p><p>选：<code>f[i][j][k]=f[i-1][j-zero[i]][k-one[i]]+1</code></p><p>取二者中的较大值。</p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">601</span>][<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 预处理每个01字符串中0和1的数量</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; zero;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; one;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strs.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> z_sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> o_sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;strs[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(strs[i][j]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                    z_sum++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    o_sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            zero.<span class="built_in">push_back</span>(z_sum);</span><br><span class="line">            one.<span class="built_in">push_back</span>(o_sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// f[i][j][k]:只考虑前i个01字符串、0的个数不超过j、1的个数不超过k的最大子集的大小。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=strs.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=n;k++)&#123;</span><br><span class="line">                    f[i][j][k]=f[i<span class="number">-1</span>][j][k];</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=zero[i<span class="number">-1</span>]&amp;&amp;k&gt;=one[i<span class="number">-1</span>])&#123;</span><br><span class="line">                        f[i][j][k]=<span class="built_in">max</span>(f[i][j][k], f[i<span class="number">-1</span>][j-zero[i<span class="number">-1</span>]][k-one[i<span class="number">-1</span>]]+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;k&lt;&lt;&quot; :&quot;&lt;&lt;f[i][j][k]&lt;&lt;&quot;    &quot;;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[strs.<span class="built_in">size</span>()][m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>$l$为$strs.size()$，时间复杂度$O(l<em>m</em>n)$，空间复杂度$O(l<em>m</em>n$)，</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p><code>f[i][j][k]</code>只和<code>f[i-1][j][k]</code>的状态有关，可以将$i$压缩。</p><p>每个字符串只有选和不选两种情况，类似01背包，压缩后倒序遍历，保证<code>f[i][j][k]</code>由<code>f[i-1][j][k]</code>推得而不是由<code>f[i][j][k]</code>推得。</p><h3 id="程序-1"><a href="#程序-1" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 预处理每个01字符串中0和1的数量</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; zero;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; one;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strs.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> z_sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> o_sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;strs[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(strs[i][j]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                    z_sum++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    o_sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            zero.<span class="built_in">push_back</span>(z_sum);</span><br><span class="line">            one.<span class="built_in">push_back</span>(o_sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=strs.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=zero[i<span class="number">-1</span>];j--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=n;k&gt;=one[i<span class="number">-1</span>];k--)&#123;</span><br><span class="line">                    f[j][k]=<span class="built_in">max</span>(f[j][k], f[j-zero[i<span class="number">-1</span>]][k-one[i<span class="number">-1</span>]]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;p&gt;6.6 每日一题&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/ones-and-zeroes/&quot;&gt;https://leetcode-cn.com/problems/ones-and-zeroes/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="每日一题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="dp" scheme="https://benyang0506.github.io/tags/dp/"/>
    
  </entry>
  
</feed>
