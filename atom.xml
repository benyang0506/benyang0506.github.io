<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阿犇</title>
  
  <subtitle>记录生活中的点点滴滴</subtitle>
  <link href="https://benyang0506.github.io/atom.xml" rel="self"/>
  
  <link href="https://benyang0506.github.io/"/>
  <updated>2021-11-16T10:36:46.330Z</updated>
  <id>https://benyang0506.github.io/</id>
  
  <author>
    <name>杨犇</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>完美矩形（扫描线）</title>
    <link href="https://benyang0506.github.io/2021/11/16/%E5%AE%8C%E7%BE%8E%E7%9F%A9%E5%BD%A2%EF%BC%88%E6%89%AB%E6%8F%8F%E7%BA%BF%EF%BC%89/"/>
    <id>https://benyang0506.github.io/2021/11/16/%E5%AE%8C%E7%BE%8E%E7%9F%A9%E5%BD%A2%EF%BC%88%E6%89%AB%E6%8F%8F%E7%BA%BF%EF%BC%89/</id>
    <published>2021-11-16T10:05:38.000Z</published>
    <updated>2021-11-16T10:36:46.330Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="11-16-每日一题-完美矩形"><a href="#11-16-每日一题-完美矩形" class="headerlink" title="11.16 每日一题 完美矩形"></a>11.16 每日一题 完美矩形</h5><p>传送门：<a href="https://leetcode-cn.com/problems/perfect-rectangle/">https://leetcode-cn.com/problems/perfect-rectangle/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给你一个数组 <code>rectangles</code> ，其中 <code>rectangles[i] = [xi, yi, ai, bi]</code> 表示一个坐标轴平行的矩形。这个矩形的左下顶点是 <code>(xi, yi)</code> ，右上顶点是 <code>(ai, bi)</code> 。</p><p>如果所有矩形一起精确覆盖了某个矩形区域，则返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="/2021/11/16/%E5%AE%8C%E7%BE%8E%E7%9F%A9%E5%BD%A2%EF%BC%88%E6%89%AB%E6%8F%8F%E7%BA%BF%EF%BC%89/1.png" alt></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]</span><br><span class="line">输出：true</span><br><span class="line">解释：5 个矩形一起可以精确地覆盖一个矩形区域。 </span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/2021/11/16/%E5%AE%8C%E7%BE%8E%E7%9F%A9%E5%BD%A2%EF%BC%88%E6%89%AB%E6%8F%8F%E7%BA%BF%EF%BC%89/2.png" alt></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]</span><br><span class="line">输出：false</span><br><span class="line">解释：两个矩形之间有间隔，无法覆盖成一个矩形。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="/2021/11/16/%E5%AE%8C%E7%BE%8E%E7%9F%A9%E5%BD%A2%EF%BC%88%E6%89%AB%E6%8F%8F%E7%BA%BF%EF%BC%89/3.png" alt></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[3,2,4,4]]</span><br><span class="line">输出：false</span><br><span class="line">解释：图形顶端留有空缺，无法覆盖成一个矩形。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><p><img src="/2021/11/16/%E5%AE%8C%E7%BE%8E%E7%9F%A9%E5%BD%A2%EF%BC%88%E6%89%AB%E6%8F%8F%E7%BA%BF%EF%BC%89/4.png" alt></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]</span><br><span class="line">输出：false</span><br><span class="line">解释：因为中间有相交区域，虽然形成了矩形，但不是精确覆盖。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= rectangles.length &lt;= 2 * 1e4</span><br><span class="line">rectangles[i].length == 4</span><br><span class="line">-1e5 &lt;= xi, yi, ai, bi &lt;= 1e5</span><br></pre></td></tr></table></figure><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>观察样例找规律可知，完美矩形的充要条件为：拼接后得到的矩形面积等于所有矩形面积之和，图形中的顶点出现次数为2或4（大矩形的四个顶点为1除外）。</p><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt;, <span class="keyword">int</span>&gt; times; </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRectangleCover</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; rectangles)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 面积是否相等；所有顶点出现两次或四次</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum_area=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> minX=<span class="number">0x3f3f3f3f</span>,minY=<span class="number">0x3f3f3f3f</span>,maxX=<span class="number">-0x3f3f3f3f</span>,maxY=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rectangles.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> x1=rectangles[i][<span class="number">0</span>],y1=rectangles[i][<span class="number">1</span>],x2=rectangles[i][<span class="number">2</span>],y2=rectangles[i][<span class="number">3</span>];</span><br><span class="line">            minX=<span class="built_in">min</span>(minX,x1);</span><br><span class="line">            minY=<span class="built_in">min</span>(minY,y1);</span><br><span class="line">            maxX=<span class="built_in">max</span>(maxX,x2);</span><br><span class="line">            maxY=<span class="built_in">max</span>(maxY,y2);</span><br><span class="line">            sum_area+=(x2-x1)*(y2-y1);</span><br><span class="line">            times[&#123;x1,y1&#125;]++;</span><br><span class="line">            times[&#123;x2,y2&#125;]++;</span><br><span class="line">            times[&#123;x1,y2&#125;]++;</span><br><span class="line">            times[&#123;x2,y1&#125;]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum_area!=(maxX-minX)*(maxY-minY))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:times)&#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;i.second&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>((i.first.first==minX&amp;&amp;i.first.second==minY)||(i.first.first==maxX&amp;&amp;i.first.second==maxY)||</span><br><span class="line">            (i.first.first==minX&amp;&amp;i.first.second==maxY)||(i.first.first==maxX&amp;&amp;i.first.second==minY))&#123;</span><br><span class="line">                <span class="keyword">if</span>(i.second!=<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">// cout&lt;&lt;&quot;1&quot;&lt;&lt;endl;</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i.second!=<span class="number">2</span>&amp;&amp;i.second!=<span class="number">4</span>)&#123;</span><br><span class="line">                cout&lt;&lt;i.first.first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i.first.second&lt;&lt;endl;</span><br><span class="line">                cout&lt;&lt;i.second&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法二（扫描线）"><a href="#方法二（扫描线）" class="headerlink" title="方法二（扫描线）"></a>方法二（扫描线）</h3><p>扫描线解法：<br>将每个矩形看成两条竖直方向的直线，以$(x,y1,y2,flag)$的格式存，$flag$区分矩形的左边还是右边；<br>每一条非边缘的竖线，左右两边一定成对存在；<br>每一条边缘的竖线，左或右只出现一次；</p><p>其中，对非边缘的竖线，可以由无缝拼接而成的竖线成对存在（ps，成对存在的线段在$y$方向上可以不相邻，因此对同一个$x$，可能需要存多个线段，然后一一匹配）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 扫描线解法</span></span><br><span class="line">    <span class="comment">// 将每个矩形看成两条竖直方向的直线，以(x,y1,y2,flag)的格式存，flag区分矩形的左边还是右边</span></span><br><span class="line">    <span class="comment">// 每一条非边缘的竖线，左右两边成对存在</span></span><br><span class="line">    <span class="comment">// 每一条边缘的竖线，左或右只出现一次</span></span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; vt;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRectangleCover</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; rectangles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=rectangles.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            vt.<span class="built_in">push_back</span>(&#123;rectangles[i][<span class="number">0</span>],rectangles[i][<span class="number">1</span>],rectangles[i][<span class="number">3</span>],<span class="number">0</span>&#125;);</span><br><span class="line">            vt.<span class="built_in">push_back</span>(&#123;rectangles[i][<span class="number">2</span>],rectangles[i][<span class="number">1</span>],rectangles[i][<span class="number">3</span>],<span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(vt.<span class="built_in">begin</span>(),vt.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每个矩形存两条边</span></span><br><span class="line">        <span class="keyword">int</span> m=vt.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;m;)&#123;</span><br><span class="line">            <span class="keyword">int</span> r=l;</span><br><span class="line">            <span class="keyword">while</span>(r&lt;m&amp;&amp;vt[r][<span class="number">0</span>]==vt[l][<span class="number">0</span>])&#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 区间[l,r)</span></span><br><span class="line">            <span class="comment">// 只存ymin和ymax是错误的，对同一个x，y方向可能被分成多段，所以要将每一段都存下来。</span></span><br><span class="line">            vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; left;</span><br><span class="line">            vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; right;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;r;i++)&#123;</span><br><span class="line">                <span class="comment">// 左边</span></span><br><span class="line">                <span class="keyword">if</span>(vt[i][<span class="number">3</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">                    vector&lt;<span class="keyword">int</span>&gt; cur=&#123;vt[i][<span class="number">1</span>],vt[i][<span class="number">2</span>]&#125;;</span><br><span class="line">                    <span class="keyword">if</span>(left.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                        left.<span class="built_in">push_back</span>(cur);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(left[left.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>]&gt;cur[<span class="number">0</span>])&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(left[left.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>]==cur[<span class="number">0</span>])&#123;</span><br><span class="line">                            left[left.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>]=cur[<span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            left.<span class="built_in">push_back</span>(cur);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(vt[i][<span class="number">3</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">// 右边</span></span><br><span class="line">                    vector&lt;<span class="keyword">int</span>&gt; cur=&#123;vt[i][<span class="number">1</span>],vt[i][<span class="number">2</span>]&#125;;</span><br><span class="line">                    <span class="keyword">if</span>(right.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                        right.<span class="built_in">push_back</span>(cur);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(right[right.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>]&gt;cur[<span class="number">0</span>])&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(right[right.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>]==cur[<span class="number">0</span>])&#123;</span><br><span class="line">                            right[right.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>]=cur[<span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            right.<span class="built_in">push_back</span>(cur);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 非边缘</span></span><br><span class="line">            <span class="keyword">if</span>(l&gt;<span class="number">0</span>&amp;&amp;r&lt;m)&#123;</span><br><span class="line">                <span class="comment">// cout&lt;&lt;&quot;1&quot;&lt;&lt;endl;</span></span><br><span class="line">                <span class="keyword">if</span>(left.<span class="built_in">size</span>()!=right.<span class="built_in">size</span>())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;left.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(left[j][<span class="number">0</span>]!=right[j][<span class="number">0</span>]||left[j][<span class="number">1</span>]!=right[j][<span class="number">1</span>])&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(left.<span class="built_in">size</span>()==<span class="number">0</span>&amp;&amp;right.<span class="built_in">size</span>()==<span class="number">1</span>||left.<span class="built_in">size</span>()==<span class="number">1</span>||right.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l=r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;11-16-每日一题-完美矩形&quot;&gt;&lt;a href=&quot;#11-16-每日一题-完美矩形&quot; class=&quot;headerlink&quot; title=&quot;11.16 每日一题 完美矩形&quot;&gt;&lt;/a&gt;11.16 每日一题 完美矩形&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/perfect-rectangle/&quot;&gt;https://leetcode-cn.com/problems/perfect-rectangle/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="每日一题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="扫描线" scheme="https://benyang0506.github.io/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>第262场双周赛D</title>
    <link href="https://benyang0506.github.io/2021/11/02/%E7%AC%AC262%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9BD/"/>
    <id>https://benyang0506.github.io/2021/11/02/%E7%AC%AC262%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9BD/</id>
    <published>2021-11-02T13:02:26.000Z</published>
    <updated>2021-11-02T13:52:50.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="将数组分成两个数组并最小化数组和的差"><a href="#将数组分成两个数组并最小化数组和的差" class="headerlink" title="将数组分成两个数组并最小化数组和的差"></a>将数组分成两个数组并最小化数组和的差</h5><p>传送门：<a href="https://leetcode-cn.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/">https://leetcode-cn.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给你一个长度为 <code>2 * n</code> 的整数数组。你需要将 <code>nums</code> 分成 <strong>两个</strong> 长度为 <code>n</code> 的数组，分别求出两个数组的和，并 <strong>最小化</strong> 两个数组和之 <strong>差的绝对值</strong> 。<code>nums</code> 中每个元素都需要放入两个数组之一。</p><p>请你返回 <strong>最小</strong> 的数组和之差。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,9,7,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：最优分组方案是分成 [3,9] 和 [7,3] 。</span><br><span class="line">数组和之差的绝对值为 abs((3 + 9) - (7 + 3)) = 2 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-36,36]</span><br><span class="line">输出：72</span><br><span class="line">解释：最优分组方案是分成 [-36] 和 [36] 。</span><br><span class="line">数组和之差的绝对值为 abs((-36) - (36)) = 72 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,-1,0,4,-2,-9]</span><br><span class="line">输出：0</span><br><span class="line">解释：最优分组方案是分成 [2,4,-9] 和 [-1,0,-2] 。</span><br><span class="line">数组和之差的绝对值为 abs((2 + 4 + -9) - (-1 + 0 + -2)) = 0 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= n &lt;= 15</span><br><span class="line">nums.length == 2 * n</span><br><span class="line">-10^7 &lt;= nums[i] &lt;= 10^7</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>最接近目标值的子序列和问题，与</p><p><a href="https://www.aben.fun/2021/11/02/%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/#more">https://www.aben.fun/2021/11/02/%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/#more</a></p><p>非常类似。</p><p>搜索所有子集的时间复杂度较大的时候，可以考虑把原始集合划分成两个相等长度的集合，分别求子集。</p><p>这里把原数组划分成$sum1、sum2$两个长度为$n$的集合，分别求出其中所有子集的和（位运算），按组成子集的的元素个数分组。</p><p>然后开始合并两个子集，由于固定合并之后的长度为$n$，所以需要遍历$sum1$中组成元素个数从$0-n$的子集（对应$sum2$中为($n-i$)），可以用双指针或者二分求出于$sum/2$的最小差值。</p><p>将所有的元素*2是为了避免$sum/2$不是整数。</p><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><h5 id="折半搜索-状态压缩-双指针"><a href="#折半搜索-状态压缩-双指针" class="headerlink" title="折半搜索+状态压缩+双指针"></a>折半搜索+状态压缩+双指针</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; sum1,vector&lt;<span class="keyword">int</span>&gt;&amp; sum2,<span class="keyword">int</span> halfsum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Min=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=sum2.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;sum1.<span class="built_in">size</span>()&amp;&amp;j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            Min=<span class="built_in">min</span>(Min,<span class="built_in">abs</span>(sum1[i]+sum2[j]-halfsum));</span><br><span class="line">            <span class="keyword">if</span>(sum1[i]+sum2[j]&gt;=halfsum)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumDifference</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保证sum/2为整数</span></span><br><span class="line">        <span class="keyword">int</span> halfsum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            halfsum+=nums[i];</span><br><span class="line">            nums[i]*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>()/<span class="number">2</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">sum1</span>(n+<span class="number">1</span>);</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">sum2</span>(n+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    k++;</span><br><span class="line">                    s+=nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sum1[k].<span class="built_in">push_back</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    k++;</span><br><span class="line">                    s+=nums[n+j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sum2[k].<span class="built_in">push_back</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 问题变成了从16组两个元素个数不超过C(7,15)的列表中找出和最接近原来总和一半的方案，取得的两组的元素和为n</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; sum:sum1)&#123;</span><br><span class="line">            <span class="built_in">sort</span>(sum.<span class="built_in">begin</span>(),sum.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; sum:sum2)&#123;</span><br><span class="line">            <span class="built_in">sort</span>(sum.<span class="built_in">begin</span>(),sum.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> Min=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            Min=<span class="built_in">min</span>(Min,<span class="built_in">getMin</span>(sum1[i],sum2[n-i],halfsum));</span><br><span class="line">            <span class="keyword">if</span>(Min==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="折半搜索-状态压缩-二分"><a href="#折半搜索-状态压缩-二分" class="headerlink" title="折半搜索+状态压缩+二分"></a>折半搜索+状态压缩+二分</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumDifference</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保证sum/2为整数</span></span><br><span class="line">        <span class="keyword">int</span> halfsum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            halfsum+=nums[i];</span><br><span class="line">            nums[i]*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>()/<span class="number">2</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">sum1</span>(n+<span class="number">1</span>);</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">sum2</span>(n+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    k++;</span><br><span class="line">                    s+=nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sum1[k].<span class="built_in">push_back</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    k++;</span><br><span class="line">                    s+=nums[n+j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sum2[k].<span class="built_in">push_back</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> Min=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="comment">// 问题变成了从16组两个元素个数不超过C(7,15)的列表中找出和最接近原来总和一半的方案，取得的两组的元素和为n</span></span><br><span class="line">        <span class="comment">// 二分</span></span><br><span class="line">        <span class="comment">// 对sum2进行排序，对sum1中的每个i中的值，二分sum2中的n-i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; sum:sum2)&#123;</span><br><span class="line">            <span class="built_in">sort</span>(sum.<span class="built_in">begin</span>(),sum.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sum1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> x=sum1[i];</span><br><span class="line">            <span class="keyword">auto</span> y=sum2[n-i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> num:x)&#123;</span><br><span class="line">                <span class="keyword">int</span> l=<span class="number">0</span>,r=y.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(num+y[mid]-halfsum&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                        r=mid;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        l=mid+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Min=<span class="built_in">min</span>(Min,<span class="built_in">abs</span>(num+y[l]-halfsum));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;将数组分成两个数组并最小化数组和的差&quot;&gt;&lt;a href=&quot;#将数组分成两个数组并最小化数组和的差&quot; class=&quot;headerlink&quot; title=&quot;将数组分成两个数组并最小化数组和的差&quot;&gt;&lt;/a&gt;将数组分成两个数组并最小化数组和的差&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/&quot;&gt;https://leetcode-cn.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="周赛" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="双指针" scheme="https://benyang0506.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="二分" scheme="https://benyang0506.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
    <category term="状态压缩" scheme="https://benyang0506.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="折半搜索" scheme="https://benyang0506.github.io/tags/%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>最接近目标值的子序列和</title>
    <link href="https://benyang0506.github.io/2021/11/02/%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/"/>
    <id>https://benyang0506.github.io/2021/11/02/%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/</id>
    <published>2021-11-02T01:36:13.000Z</published>
    <updated>2021-11-02T13:49:09.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="最接近目标值的子序列和"><a href="#最接近目标值的子序列和" class="headerlink" title="最接近目标值的子序列和"></a>最接近目标值的子序列和</h5><p>传送门：<a href="https://leetcode-cn.com/problems/closest-subsequence-sum/">https://leetcode-cn.com/problems/closest-subsequence-sum/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给你一个整数数组 <code>nums</code> 和一个目标值 <code>goal</code> 。</p><p>你需要从 <code>nums</code> 中选出一个子序列，使子序列元素总和最接近 <code>goal</code> 。也就是说，如果子序列元素和为 <code>sum</code> ，你需要 <strong>最小化绝对差</strong> <code>abs(sum - goal)</code> 。</p><p>返回 <code>abs(sum - goal)</code> 可能的 <strong>最小值</strong> 。</p><p>注意，数组的子序列是通过移除原始数组中的某些元素（可能全部或无）而形成的数组。</p><p> <strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,-7,3,5], goal = 6</span><br><span class="line">输出：0</span><br><span class="line">解释：选择整个数组作为选出的子序列，元素和为 6 。</span><br><span class="line">子序列和与目标值相等，所以绝对差为 0 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [7,-9,15,-2], goal = -5</span><br><span class="line">输出：1</span><br><span class="line">解释：选出子序列 [7,-9,-2] ，元素和为 -4 。</span><br><span class="line">绝对差为 abs(-4 - (-5)) = abs(1) = 1 ，是可能的最小值。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3], goal = -7</span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums.length &lt;= 40</span><br><span class="line">-10^7 &lt;= nums[i] &lt;= 10^7</span><br><span class="line">-10^9 &lt;= goal &lt;= 10^9</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>枚举子集的基础题目：<a href="https://leetcode-cn.com/problems/subsets/">https://leetcode-cn.com/problems/subsets/</a></p><p>两种求所有子集的方法：</p><ul><li>$dfs$</li><li>位运算</li></ul><p>枚举所有子集的时间复杂度为$2^n$，$n=40$，加上每次需要求和运算，时间复杂度太高。</p><p>一个技巧：将$n=40$的数组拆成两部分，每部分元素个数为20，枚举每一部分所有子集的时间复杂度为$2^{20}\approx10^6$，接着枚举每一部分所有子集的和，记为$sum1$，$sum2$，时间复杂度$O((n/2)*2^{n/2})$，大概在$10^7$左右。</p><p>原数组的子序列和，必然为下列三者之一：</p><ul><li><p>$sum1$中某个元素</p></li><li><p>$sum2$中某个元素</p></li><li>$sum1$中某个元素与$sum2$中某个元素之和</li></ul><p>前两种情况直接遍历就可以得到，第三种情况为给定两个有序数组，分别从两个数组中各取出一个数字，使他们的和最接近$goal$，相关题目：<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/。">https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/。</a></p><p>考虑双指针，将$i$指向$sum1$中第一个元素，将$j$指向$sum2$中最后一个元素，每次计算$sum1[i]$与$sum2[j]$的和$s$。</p><p>如果$s&lt;goal$，则对于当前的$i$，剩余所有的$j$都不用考虑了（和只可能更小），于是将$i$右移一个位置；</p><p>如果$s&gt;=goal$，则对于当前的$j$，剩余所有的$i$都不需要考虑了（和只可能更大），于是将$j$左移一个位置。</p><p>这部分排序时间复杂度为$O(2^{n/2}log{2^{n/2}})$，大概在$10^7$左右，双指针时间复杂度$O(2^{n/2})$。</p><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; sum1;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; sum2;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minAbsDifference</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> goal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 位运算求subset</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;(n/<span class="number">2</span>));i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n/<span class="number">2</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    sum+=nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sum1.<span class="built_in">push_back</span>(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;(n-n/<span class="number">2</span>));i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(n-n/<span class="number">2</span>);j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    sum+=nums[n/<span class="number">2</span>+j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sum2.<span class="built_in">push_back</span>(sum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(sum1.<span class="built_in">begin</span>(),sum1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(sum2.<span class="built_in">begin</span>(),sum2.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> Min=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sum1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(sum1[i]-goal)&lt;Min)&#123;</span><br><span class="line">                Min=<span class="built_in">abs</span>(sum1[i]-goal);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sum2.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(sum2[i]-goal)&lt;Min)&#123;</span><br><span class="line">                Min=<span class="built_in">abs</span>(sum2[i]-goal);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从sum1中挑选一个数，从sum2中挑选一个数，使二者之和与goal的差最小</span></span><br><span class="line">        <span class="comment">// 双指针做法</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=sum2.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;sum1.<span class="built_in">size</span>()&amp;&amp;j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            Min=<span class="built_in">min</span>(Min,<span class="built_in">abs</span>(sum1[i]+sum2[j]-goal));</span><br><span class="line">            <span class="keyword">if</span>(sum1[i]+sum2[j]&lt;=goal)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;最接近目标值的子序列和&quot;&gt;&lt;a href=&quot;#最接近目标值的子序列和&quot; class=&quot;headerlink&quot; title=&quot;最接近目标值的子序列和&quot;&gt;&lt;/a&gt;最接近目标值的子序列和&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/closest-subsequence-sum/&quot;&gt;https://leetcode-cn.com/problems/closest-subsequence-sum/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    
    <category term="双指针" scheme="https://benyang0506.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="状态压缩" scheme="https://benyang0506.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="折半搜索" scheme="https://benyang0506.github.io/tags/%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Attention Is All You Need</title>
    <link href="https://benyang0506.github.io/2021/11/01/Attention-Is-All-You-Need/"/>
    <id>https://benyang0506.github.io/2021/11/01/Attention-Is-All-You-Need/</id>
    <published>2021-11-01T11:39:27.000Z</published>
    <updated>2021-11-01T13:43:37.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Attention-Is-All-You-Need"><a href="#Attention-Is-All-You-Need" class="headerlink" title="Attention Is All You Need"></a>Attention Is All You Need</h2><p>原文链接：<a href="https://arxiv.org/abs/1706.03762">https://arxiv.org/abs/1706.03762</a><br>中英文对应（来自一译）：<a href="https://www.yiyibooks.cn/yiyibooks/Attention_Is_All_You_Need/index.html">https://www.yiyibooks.cn/yiyibooks/Attention_Is_All_You_Need/index.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Attention-Is-All-You-Need&quot;&gt;&lt;a href=&quot;#Attention-Is-All-You-Need&quot; class=&quot;headerlink&quot; title=&quot;Attention Is All You Need&quot;&gt;&lt;/a&gt;Attention I</summary>
      
    
    
    
    <category term="nlp" scheme="https://benyang0506.github.io/categories/nlp/"/>
    
    
    <category term="transformer" scheme="https://benyang0506.github.io/tags/transformer/"/>
    
  </entry>
  
  <entry>
    <title>八股搭建神经网络</title>
    <link href="https://benyang0506.github.io/2021/10/28/%E5%85%AB%E8%82%A1%E6%90%AD%E5%BB%BA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>https://benyang0506.github.io/2021/10/28/%E5%85%AB%E8%82%A1%E6%90%AD%E5%BB%BA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</id>
    <published>2021-10-28T11:10:32.000Z</published>
    <updated>2021-10-28T11:18:58.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用八股搭建神经网络"><a href="#使用八股搭建神经网络" class="headerlink" title="使用八股搭建神经网络"></a>使用八股搭建神经网络</h2><p>用Tensorflow API: tf. keras</p><h4 id="六步法搭建神经网络"><a href="#六步法搭建神经网络" class="headerlink" title="六步法搭建神经网络"></a>六步法搭建神经网络</h4><p>第一步：import相关模块，如import tensorflow as tf。</p><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><p>第二步：指定输入网络的训练集和测试集，如指定训练集的输入x_train和标签y_train，测试集的输<br>入x_test和标签y_test。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mnist = tf.keras.datasets.mnist</span><br><span class="line">(x_train,y_train),(x_test,y_test)=mnist.load_data()</span><br><span class="line">x_train,x_test=x_train/<span class="number">255.0</span>,x_test/<span class="number">255.0</span></span><br></pre></td></tr></table></figure><p>第三步：逐层搭建网络结构，model = tf.keras.models.Sequential()。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">model=tf.keras.models.Sequential([</span><br><span class="line">    tf.keras.layers.Flatten(),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">128</span>,activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">10</span>,activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>第四步：在model.compile()中配置训练方法，选择训练时使用的优化器、损失函数和最终评价指标。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">             loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=<span class="literal">False</span>),</span><br><span class="line">             metrics=[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>])</span><br></pre></td></tr></table></figure><h4 id="断点续训，读取模型"><a href="#断点续训，读取模型" class="headerlink" title="断点续训，读取模型"></a>断点续训，读取模型</h4><p>定义存放模型的路径和文件名，命名为ckpt文件</p><p>生成ckpt文件时会同步生成index索引表，所以判断索引表是否存在，来判断是否存在模型参数</p><p>如有索引表，则直接读取ckpt文件中的模型参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">checkpoint_save_path=<span class="string">&quot;./checkpoint/mnist.ckpt&quot;</span></span><br><span class="line"><span class="keyword">if</span> os.path.exists(checkpoint_save_path+<span class="string">&#x27;.index&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--------------load the model---------------&#x27;</span>)</span><br><span class="line">    model.load_weights(checkpoint_save_path)</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>--------------load the model---------------</code></pre><h4 id="保存模型"><a href="#保存模型" class="headerlink" title="保存模型"></a>保存模型</h4><p>第五步：在model.fit()中执行训练过程，告知训练集和测试集的输入值和标签、每个batch的大小（batchsize）和数据集的迭代次数（epoch）。</p><p>第六步：使用model.summary()打印网络结构，统计参数数目。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cp_callback = tf.keras.callbacks.ModelCheckpoint(filepath=checkpoint_save_path,</span><br><span class="line">                                                save_weights_only=<span class="literal">True</span>,</span><br><span class="line">                                                save_best_only=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">history = model.fit(x_train,y_train,batch_size=<span class="number">32</span>,epochs=<span class="number">5</span>,validation_data=(x_test,y_test),validation_freq=<span class="number">1</span>,callbacks=[cp_callback])</span><br><span class="line">model.summary()</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>Epoch 1/51875/1875 [==============================] - 2s 886us/step - loss: 0.0118 - sparse_categorical_accuracy: 0.9962 - val_loss: 0.0801 - val_sparse_categorical_accuracy: 0.9797Epoch 2/51875/1875 [==============================] - 1s 667us/step - loss: 0.0101 - sparse_categorical_accuracy: 0.9967 - val_loss: 0.0899 - val_sparse_categorical_accuracy: 0.9798Epoch 3/51875/1875 [==============================] - 1s 695us/step - loss: 0.0086 - sparse_categorical_accuracy: 0.9974 - val_loss: 0.0879 - val_sparse_categorical_accuracy: 0.9807Epoch 4/51875/1875 [==============================] - 1s 694us/step - loss: 0.0095 - sparse_categorical_accuracy: 0.9970 - val_loss: 0.0979 - val_sparse_categorical_accuracy: 0.9782Epoch 5/51875/1875 [==============================] - 1s 687us/step - loss: 0.0060 - sparse_categorical_accuracy: 0.9981 - val_loss: 0.0997 - val_sparse_categorical_accuracy: 0.9800Model: &quot;sequential&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================flatten (Flatten)            (None, 784)               0         _________________________________________________________________dense (Dense)                (None, 128)               100480    _________________________________________________________________dense_1 (Dense)              (None, 10)                1290      =================================================================Total params: 101,770Trainable params: 101,770Non-trainable params: 0_________________________________________________________________</code></pre><h4 id="设置输出格式"><a href="#设置输出格式" class="headerlink" title="设置输出格式"></a>设置输出格式</h4><p>np.set printoptions(threshold=超过多少省略显示)</p><p>np.set_printoptions(threshold=np.inf) # np. inf表示无限大</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.set_printoptions(threshold=np.inf)</span></span><br><span class="line">np.set_printoptions(threshold=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(model.trainable_variables)</span><br></pre></td></tr></table></figure><pre><code>[&lt;tf.Variable &#39;dense/kernel:0&#39; shape=(784, 128) dtype=float32, numpy=array([[-0.05238347, -0.06266207, -0.07440181, ...,  0.0417512 ,        -0.05344176,  0.02906115],       [-0.00369083,  0.01099763, -0.00766775, ...,  0.07014749,        -0.03556629,  0.01387362],       [-0.07415341, -0.01817401,  0.00419831, ...,  0.06153186,        -0.01100198,  0.0544705 ],       ...,       [ 0.06579664, -0.06812809, -0.05979012, ..., -0.0540199 ,         0.04981285,  0.066493  ],       [-0.0601579 ,  0.06772352, -0.0692725 , ..., -0.04544504,        -0.08102902,  0.02741539],       [-0.044352  , -0.07048865,  0.00934549, ...,  0.032233  ,        -0.00784087,  0.05623148]], dtype=float32)&gt;, &lt;tf.Variable &#39;dense/bias:0&#39; shape=(128,) dtype=float32, numpy=array([-0.14855091, -0.07285158, -0.09825671, ...,  0.07643671,       -0.1354494 ,  0.08794942], dtype=float32)&gt;, &lt;tf.Variable &#39;dense_1/kernel:0&#39; shape=(128, 10) dtype=float32, numpy=array([[ 2.43996501e-01, -2.15584278e-01,  2.29047656e-01, ...,        -6.07578419e-02,  9.98528376e-02,  1.91292807e-01],       [ 2.44029671e-01,  4.49361429e-02, -9.02478278e-01, ...,        -9.88776796e-03,  4.69152890e-02,  1.93796545e-01],       [-1.17883611e+00,  3.15114379e-01,  3.47505659e-01, ...,         3.69858891e-01,  3.26448739e-01, -8.94050360e-01],       ...,       [-5.94317436e-01, -2.05278710e-01, -7.61512935e-01, ...,         3.76689643e-01,  1.37598768e-01,  1.51904374e-01],       [-2.08765984e-01,  1.04028150e-01,  1.08290091e-01, ...,        -6.63495797e-04,  1.37945980e-01,  1.77999035e-01],       [ 4.85304482e-02, -2.46528938e-01, -5.67862451e-01, ...,        -4.70214367e-01, -3.69332522e-01,  1.24029376e-01]], dtype=float32)&gt;, &lt;tf.Variable &#39;dense_1/bias:0&#39; shape=(10,) dtype=float32, numpy=array([-0.1546798 , -0.22612654, -0.10529487, -0.1593509 ,  0.18012638,        0.10057895, -0.01941594, -0.1304893 ,  0.35250106,  0.02564381],      dtype=float32)&gt;]</code></pre><h4 id="参数保存"><a href="#参数保存" class="headerlink" title="参数保存"></a>参数保存</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file=<span class="built_in">open</span>(<span class="string">&#x27;./weights.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> model.trainable_variables:</span><br><span class="line">    file.write(<span class="built_in">str</span>(v.name)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    file.write(<span class="built_in">str</span>(v.shape)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    file.write(<span class="built_in">str</span>(v.numpy())+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><h4 id="显示训练集和验证集的acc和loss曲线"><a href="#显示训练集和验证集的acc和loss曲线" class="headerlink" title="显示训练集和验证集的acc和loss曲线"></a>显示训练集和验证集的acc和loss曲线</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">acc=history.history[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>]</span><br><span class="line">val_acc=history.history[<span class="string">&#x27;val_sparse_categorical_accuracy&#x27;</span>]</span><br><span class="line">loss=history.history[<span class="string">&#x27;loss&#x27;</span>]</span><br><span class="line">val_loss=history.history[<span class="string">&#x27;val_loss&#x27;</span>]</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">plt.plot(acc,label=<span class="string">&#x27;Training Accuracy&#x27;</span>)</span><br><span class="line">plt.plot(val_acc,label=<span class="string">&#x27;Validation Accuracy&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Training and Validation Accuracy&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">plt.plot(loss,label=<span class="string">&#x27;Training loss&#x27;</span>)</span><br><span class="line">plt.plot(val_loss,label=<span class="string">&#x27;Validation Loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and Validation Loss&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2021/10/28/%E5%85%AB%E8%82%A1%E6%90%AD%E5%BB%BA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/output_21_0.png" style="zoom:90%;"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;使用八股搭建神经网络&quot;&gt;&lt;a href=&quot;#使用八股搭建神经网络&quot; class=&quot;headerlink&quot; title=&quot;使用八股搭建神经网络&quot;&gt;&lt;/a&gt;使用八股搭建神经网络&lt;/h2&gt;&lt;p&gt;用Tensorflow API: tf. keras&lt;/p&gt;
&lt;h4 id=&quot;六步法搭建神经网络&quot;&gt;&lt;a href=&quot;#六步法搭建神经网络&quot; class=&quot;headerlink&quot; title=&quot;六步法搭建神经网络&quot;&gt;&lt;/a&gt;六步法搭建神经网络&lt;/h4&gt;&lt;p&gt;第一步：import相关模块，如import tensorflow as tf。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习/深度学习基础" scheme="https://benyang0506.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="tensorflow" scheme="https://benyang0506.github.io/tags/tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>第63场双周赛D</title>
    <link href="https://benyang0506.github.io/2021/10/28/%E7%AC%AC63%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9BD/"/>
    <id>https://benyang0506.github.io/2021/10/28/%E7%AC%AC63%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9BD/</id>
    <published>2021-10-28T10:47:40.000Z</published>
    <updated>2021-10-28T10:56:15.040Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="两个有序数组的第K小乘积"><a href="#两个有序数组的第K小乘积" class="headerlink" title="两个有序数组的第K小乘积"></a>两个有序数组的第K小乘积</h5><p>传送门：<a href="https://leetcode-cn.com/problems/kth-smallest-product-of-two-sorted-arrays/">https://leetcode-cn.com/problems/kth-smallest-product-of-two-sorted-arrays/</a></p><span id="more"></span><p>给你两个 <strong>从小到大排好序</strong> 且下标从 <strong>0</strong> 开始的整数数组 <code>nums1</code> 和 <code>nums2</code> 以及一个整数 <code>k</code> ，请你返回第 <code>k</code> （从 <strong>1</strong> 开始编号）小的 <code>nums1[i] * nums2[j]</code> 的乘积，其中 <code>0 &lt;= i &lt; nums1.length</code> 且 <code>0 &lt;= j &lt; nums2.length</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [2,5], nums2 = [3,4], k = 2</span><br><span class="line">输出：8</span><br><span class="line">解释：第 2 小的乘积计算如下：</span><br><span class="line">- nums1[0] * nums2[0] = 2 * 3 = 6</span><br><span class="line">- nums1[0] * nums2[1] = 2 * 4 = 8</span><br><span class="line">第 2 小的乘积为 8 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [-4,-2,0,3], nums2 = [2,4], k = 6</span><br><span class="line">输出：0</span><br><span class="line">解释：第 6 小的乘积计算如下：</span><br><span class="line">- nums1[0] * nums2[1] = (-4) * 4 = -16</span><br><span class="line">- nums1[0] * nums2[0] = (-4) * 2 = -8</span><br><span class="line">- nums1[1] * nums2[1] = (-2) * 4 = -8</span><br><span class="line">- nums1[1] * nums2[0] = (-2) * 2 = -4</span><br><span class="line">- nums1[2] * nums2[0] = 0 * 2 = 0</span><br><span class="line">- nums1[2] * nums2[1] = 0 * 4 = 0</span><br><span class="line">第 6 小的乘积为 0 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [-2,-1,0,1,2], nums2 = [-3,-1,2,4,5], k = 3</span><br><span class="line">输出：-6</span><br><span class="line">解释：第 3 小的乘积计算如下：</span><br><span class="line">- nums1[0] * nums2[4] = (-2) * 5 = -10</span><br><span class="line">- nums1[0] * nums2[3] = (-2) * 4 = -8</span><br><span class="line">- nums1[4] * nums2[0] = 2 * (-3) = -6</span><br><span class="line">第 3 小的乘积为 -6 。</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h5 id="二分-二分"><a href="#二分-二分" class="headerlink" title="二分+二分"></a>二分+二分</h5><p>假设$f(x)$为满足$nums1[i]$与$nums2[j] $的乘积小于等于$x$的组数，显然函数随$x$递增，可以二分。</p><p>计算满足$nums1[i]$与$nums2[j] $的乘积小于等于$x$的组数时，枚举$nums1$中的数$u$，每次固定$u$，二分$nums2$，寻找$nums2$中有多少个数满足$u*nums2[j]&lt;=x$。</p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; B;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">check</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> u:A)&#123;</span><br><span class="line">            <span class="keyword">if</span>(u&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 为什么不是break？考虑B[0]为负数的情况，A[0]*B[0]最大，所以要继续朝A[0]后面搜索</span></span><br><span class="line">                <span class="keyword">if</span>(u*B[<span class="number">0</span>]&gt;x) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 固定A，二分最大的乘积&lt;=x的B的索引</span></span><br><span class="line">                <span class="keyword">int</span> l=<span class="number">0</span>,r=B.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                    <span class="keyword">int</span> mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(u*B[mid]&lt;=x)&#123;</span><br><span class="line">                        l=mid;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        r=mid<span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt+=l+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(u&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 先取乘积最小的组合</span></span><br><span class="line">                <span class="keyword">if</span>(u*B[B.<span class="built_in">size</span>()<span class="number">-1</span>]&gt;x) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> l=<span class="number">0</span>,r=B.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(u*B[mid]&lt;=x)&#123;</span><br><span class="line">                        r=mid;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        l=mid+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt+=B.<span class="built_in">size</span>()-l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(u==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(x&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    cnt+=B.<span class="built_in">size</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">kthSmallestProduct</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">long</span> <span class="keyword">long</span> k)</span> </span>&#123;</span><br><span class="line">        A=nums1;</span><br><span class="line">        B=nums2;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> l=<span class="number">-1e10</span><span class="number">-10</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> r=<span class="number">1e10</span>+<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 二分乘积&lt;=x的组数</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid)&gt;=k)&#123;</span><br><span class="line">                r=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;两个有序数组的第K小乘积&quot;&gt;&lt;a href=&quot;#两个有序数组的第K小乘积&quot; class=&quot;headerlink&quot; title=&quot;两个有序数组的第K小乘积&quot;&gt;&lt;/a&gt;两个有序数组的第K小乘积&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/kth-smallest-product-of-two-sorted-arrays/&quot;&gt;https://leetcode-cn.com/problems/kth-smallest-product-of-two-sorted-arrays/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="周赛" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="二分" scheme="https://benyang0506.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>删除无效的括号</title>
    <link href="https://benyang0506.github.io/2021/10/27/%E5%88%A0%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>https://benyang0506.github.io/2021/10/27/%E5%88%A0%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</id>
    <published>2021-10-27T02:19:28.000Z</published>
    <updated>2021-10-28T10:58:12.678Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="10-27-每日一题"><a href="#10-27-每日一题" class="headerlink" title="10.27 每日一题"></a>10.27 每日一题</h5><p>传送门：<a href="https://leetcode-cn.com/problems/remove-invalid-parentheses/">https://leetcode-cn.com/problems/remove-invalid-parentheses/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给你一个由若干括号和字母组成的字符串 <code>s</code> ，删除最小数量的无效括号，使得输入的字符串有效。</p><p>返回所有可能的结果。答案可以按 <strong>任意顺序</strong> 返回。</p><p> <strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()())()&quot;</span><br><span class="line">输出：[&quot;(())()&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;(a)())()&quot;</span><br><span class="line">输出：[&quot;(a())()&quot;,&quot;(a)()()&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;)(&quot;</span><br><span class="line">输出：[&quot;&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 25</code></li><li><code>s</code> 由小写英文字母以及括号 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 组成</li><li><code>s</code> 中至多含 <code>20</code> 个括号</li></ul><h3 id="方法一：dfs-剪枝"><a href="#方法一：dfs-剪枝" class="headerlink" title="方法一：dfs+剪枝"></a>方法一：dfs+剪枝</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h5 id="我们发现，删除的无效括号的最小数量是可以提前求出来的。"><a href="#我们发现，删除的无效括号的最小数量是可以提前求出来的。" class="headerlink" title="我们发现，删除的无效括号的最小数量是可以提前求出来的。"></a>我们发现，删除的无效括号的最小数量是可以提前求出来的。</h5><p>可以用一个计数器$lnum$来模拟栈，往栈中不断地添加左括号；</p><p>之后出现的右括号都可以去栈中匹配左括号，最后栈中剩下的即为要删去的左括号，数量等于$lnum$。</p><p>右括号出现时，栈中没有左括号用来匹配，则右括号需要删去，计数器$rnum$++，记录需要删去的右括号数量。</p><h5 id="dfs-搜索"><a href="#dfs-搜索" class="headerlink" title="$dfs$搜索"></a>$dfs$搜索</h5><p>$dfs$所有删去$lnum$个左括号、$rnum$个右括号的序列，并判断是否有效。</p><h5 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h5><p>记录当前序列中的左括号数目$lc$与右括号数目$rc$，如果右括号数目$rc&gt;lc$，则这个序列一定为无效序列，停止搜索。</p><h5 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h5><p>按照上述算法搜索出的结果中可能含有重复序列，比如当前遇到的字符串为” (((())”，去掉前四个左括号中的任意一个，生成的字符串是一样的，均为 “(())”。</p><ul><li><p>在最后的结果中去重，可以使用哈希表/$set$/$sort+unique$。</p></li><li><p>在搜索过程中，遇到相邻元素相同的情况时，只需要搜索一次就好。（剪枝）</p></li></ul><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(st.<span class="built_in">top</span>()!=<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        st.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(string s,<span class="keyword">int</span> lremove,<span class="keyword">int</span> rremove,<span class="keyword">int</span> start,<span class="keyword">int</span> lc,<span class="keyword">int</span> rc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lremove==<span class="number">0</span>&amp;&amp;rremove==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isValid</span>(s))&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=start &amp;&amp; s[i]==s[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>) lc++;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>) rc++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 去掉一个左括号</span></span><br><span class="line">            <span class="keyword">if</span>(lremove&gt;<span class="number">0</span>&amp;&amp;s[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">dfs</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>,i)+s.<span class="built_in">substr</span>(i+<span class="number">1</span>),lremove<span class="number">-1</span>,rremove,i,lc,rc);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//去掉一个右括号</span></span><br><span class="line">            <span class="keyword">if</span>(rremove&gt;<span class="number">0</span>&amp;&amp;s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">dfs</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>,i)+s.<span class="built_in">substr</span>(i+<span class="number">1</span>),lremove,rremove<span class="number">-1</span>,i,lc,rc);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                lc++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                rc++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rc&gt;lc)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">removeInvalidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先计算需要删除的左括号数量、右括号数量</span></span><br><span class="line">        <span class="keyword">int</span> lnum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rnum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                lnum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(lnum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    lnum--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    rnum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dfs</span>(s,lnum,rnum,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// sort(ans.begin(),ans.end());</span></span><br><span class="line">        <span class="comment">// ans.erase(unique(ans.begin(),ans.end()),ans.end());</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n*2^n)$，$n$为字符串的长度，长度为$n$的字符串最多有$2^n$个子串，需要对每个子串进行一次合法性判断。</p><h3 id="方法二：bfs"><a href="#方法二：bfs" class="headerlink" title="方法二：bfs"></a>方法二：bfs</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>注意到题目说的是删去最少的括号，我们可以每次删去一个括号，就所有删去一个括号的操作作为$bfs$的一层，判断这一层有没有符合条件的序列；如果没有就继续删一个括号，转向下一层，以此类推，一旦在某一层找到答案便停止搜索。</p><p>我们做$bfs$，上一层$level$和下一层$level$之间的关系为：把所有上一层$level$中的每个元素都拿出来，列举出在删除一个括号后的所有可能的情况。(不管删除以后是否合法），添加到下一个$level$中的元素。</p><p>例如：$current level$是 <code>[&quot;(()&quot;, &quot;())&quot;]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 那么下一层level中的元素应该是:</span><br><span class="line"></span><br><span class="line">    1. 对 &quot;(()&quot; 删除一个括号的所有可能为： (), (), ((</span><br><span class="line">    2. 对 &quot;())&quot; 删除一个括号的所有可能为： (), )), ()</span><br></pre></td></tr></table></figure><p>注意到有重复的序列，可以使用$unordered_set$代替$queue$，以达到去重的目的。</p><h4 id="程序-1"><a href="#程序-1" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isvalid</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                ans--;</span><br><span class="line">                <span class="keyword">if</span>(ans&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bfs</span></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">removeInvalidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// unordered_set模拟队列</span></span><br><span class="line">        <span class="comment">// 每一层删去一些字符后会有重复元素，可以在进队前去重</span></span><br><span class="line">        unordered_set&lt;string&gt; q;</span><br><span class="line">        <span class="comment">// 存答案</span></span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        q.<span class="built_in">insert</span>(s);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">// 遍历这一层中的所有序列，如果有符合条件的，加入ans中，并且终止向下一层搜索。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> ss:q)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">isvalid</span>(ss))&#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(ss);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ans.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 继续搜索下一层</span></span><br><span class="line">            unordered_set&lt;string&gt; curq;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> ss:q)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ss.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;ss[i]==ss[i<span class="number">-1</span>])&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(ss[i]==<span class="string">&#x27;(&#x27;</span>||ss[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                        curq.<span class="built_in">insert</span>(ss.<span class="built_in">substr</span>(<span class="number">0</span>,i)+ss.<span class="built_in">substr</span>(i+<span class="number">1</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            q=curq;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n*2^n)$，$n$为字符串的长度，长度为$n$的字符串最多有$2^n$个子串，需要对每个子串进行一次合法性判断。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;10-27-每日一题&quot;&gt;&lt;a href=&quot;#10-27-每日一题&quot; class=&quot;headerlink&quot; title=&quot;10.27 每日一题&quot;&gt;&lt;/a&gt;10.27 每日一题&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/remove-invalid-parentheses/&quot;&gt;https://leetcode-cn.com/problems/remove-invalid-parentheses/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="每日一题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="dfs" scheme="https://benyang0506.github.io/tags/dfs/"/>
    
    <category term="bfs" scheme="https://benyang0506.github.io/tags/bfs/"/>
    
  </entry>
  
  <entry>
    <title>Jupyter notebook 快捷键</title>
    <link href="https://benyang0506.github.io/2021/10/26/Jupyter-notebook%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://benyang0506.github.io/2021/10/26/Jupyter-notebook%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2021-10-26T11:52:57.000Z</published>
    <updated>2021-10-26T12:05:26.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Jupyter-notebook-快捷键"><a href="#Jupyter-notebook-快捷键" class="headerlink" title="Jupyter notebook 快捷键"></a>Jupyter notebook 快捷键</h2><h5 id="Jupyter-Notebook-有两种键盘输入模式。"><a href="#Jupyter-Notebook-有两种键盘输入模式。" class="headerlink" title="Jupyter Notebook 有两种键盘输入模式。"></a>Jupyter Notebook 有两种键盘输入模式。</h5><p>编辑模式，允许你往单元中键入代码或文本；这时的单元框线是绿色的。</p><span id="more"></span><p>命令模式，键盘输入运行程序命令；这时的单元框线是灰色的。</p><h3 id="命令模式-按键-Esc-开启"><a href="#命令模式-按键-Esc-开启" class="headerlink" title="命令模式 (按键 Esc 开启)"></a>命令模式 (按键 Esc 开启)</h3><ul><li>Enter : 转入编辑模式</li><li>Shift-Enter : 运行本单元，选中下个单元</li><li>Ctrl-Enter : 运行本单元</li><li>Alt-Enter : 运行本单元，在其下插入新单元</li><li>Y : 单元转入代码状态</li><li>M :单元转入markdown状态</li><li>R : 单元转入raw状态</li><li>1 : 设定 1 级标题</li><li>2 : 设定 2 级标题</li><li>3 : 设定 3 级标题</li><li>4 : 设定 4 级标题</li><li>5 : 设定 5 级标题</li><li>6 : 设定 6 级标题</li><li>Up : 选中上方单元</li><li>K : 选中上方单元</li><li>Down : 选中下方单元</li><li>J : 选中下方单元</li><li>Shift-K : 扩大选中上方单元</li><li>Shift-J : 扩大选中下方单元</li><li>A : 在上方插入新单元</li><li>B : 在下方插入新单元</li><li>X : 剪切选中的单元</li><li>C : 复制选中的单元</li><li>Shift-V : 粘贴到上方单元</li><li>V : 粘贴到下方单元</li><li>Z : 恢复删除的最后一个单元</li><li>D,D : 删除选中的单元</li><li>Shift-M : 合并选中的单元</li><li>Ctrl-S : 文件存盘</li><li>S : 文件存盘</li><li>L : 转换行号</li><li>O : 转换输出</li><li>Shift-O : 转换输出滚动</li><li>Esc : 关闭页面</li><li>Q : 关闭页面</li><li>H : 显示快捷键帮助</li><li>I,I : 中断Notebook内核</li><li>0,0 : 重启Notebook内核</li><li>Shift : 忽略</li><li>Shift-Space : 向上滚动</li><li>Space : 向下滚动</li></ul><h3 id="编辑模式-Enter-键启动"><a href="#编辑模式-Enter-键启动" class="headerlink" title="编辑模式 ( Enter 键启动)"></a>编辑模式 ( Enter 键启动)</h3><ul><li>Tab : 代码补全或缩进</li><li>Shift-Tab : 提示</li><li>Ctrl-] : 缩进</li><li>Ctrl-[ : 解除缩进</li><li>Ctrl-A : 全选</li><li>Ctrl-Z : 复原</li><li>Ctrl-Shift-Z : 再做</li><li>Ctrl-Y : 再做</li><li>Ctrl-Home : 跳到单元开头</li><li>Ctrl-Up : 跳到单元开头</li><li>Ctrl-End : 跳到单元末尾</li><li>Ctrl-Down : 跳到单元末尾</li><li>Ctrl-Left : 跳到左边一个字首</li><li>Ctrl-Right : 跳到右边一个字首</li><li>Ctrl-Backspace : 删除前面一个字</li><li>Ctrl-Delete : 删除后面一个字</li><li>Esc : 进入命令模式</li><li>Ctrl-M : 进入命令模式</li><li>Shift-Enter : 运行本单元，选中下一单元</li><li>Ctrl-Enter : 运行本单元</li><li>Alt-Enter : 运行本单元，在下面插入一单元</li><li>Ctrl-Shift– : 分割单元</li><li>Ctrl-Shift-Subtract : 分割单元</li><li>Ctrl-S : 文件存盘</li><li>Shift : 忽略</li><li>Up : 光标上移或转入上一单元</li><li>Down :光标下移或转入下一单元</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Jupyter-notebook-快捷键&quot;&gt;&lt;a href=&quot;#Jupyter-notebook-快捷键&quot; class=&quot;headerlink&quot; title=&quot;Jupyter notebook 快捷键&quot;&gt;&lt;/a&gt;Jupyter notebook 快捷键&lt;/h2&gt;&lt;h5 id=&quot;Jupyter-Notebook-有两种键盘输入模式。&quot;&gt;&lt;a href=&quot;#Jupyter-Notebook-有两种键盘输入模式。&quot; class=&quot;headerlink&quot; title=&quot;Jupyter Notebook 有两种键盘输入模式。&quot;&gt;&lt;/a&gt;Jupyter Notebook 有两种键盘输入模式。&lt;/h5&gt;&lt;p&gt;编辑模式，允许你往单元中键入代码或文本；这时的单元框线是绿色的。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习/深度学习基础" scheme="https://benyang0506.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="jupyter" scheme="https://benyang0506.github.io/tags/jupyter/"/>
    
  </entry>
  
  <entry>
    <title>下一个更大元素I</title>
    <link href="https://benyang0506.github.io/2021/10/26/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I/"/>
    <id>https://benyang0506.github.io/2021/10/26/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I/</id>
    <published>2021-10-26T04:26:31.000Z</published>
    <updated>2021-10-26T04:49:43.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="10-26-下一个更大元素"><a href="#10-26-下一个更大元素" class="headerlink" title="10.26 下一个更大元素"></a>10.26 下一个更大元素</h5><p>传送门：<a href="https://leetcode-cn.com/problems/next-greater-element-i/">https://leetcode-cn.com/problems/next-greater-element-i/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给你两个 <strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，其中<code>nums1</code> 是 <code>nums2</code> 的子集。</p><p>请你找出 <code>nums1</code> 中每个元素在 <code>nums2</code> 中的下一个比其大的值。</p><p><code>nums1</code> 中数字 <code>x</code> 的下一个更大元素是指 <code>x</code> 在 <code>nums2</code> 中对应位置的右边的第一个比 <code>x</code> 大的元素。如果不存在，对应位置输出 <code>-1</code> 。</p><p> <strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [4,1,2], nums2 = [1,3,4,2].</span><br><span class="line">输出: [-1,3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。</span><br><span class="line">    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。</span><br><span class="line">    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [2,4], nums2 = [1,2,3,4].</span><br><span class="line">输出: [3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。</span><br><span class="line">    对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li><li><p><code>0 &lt;= nums1[i], nums2[i] &lt;= 10^4</code></p></li><li><p><code>nums1</code>和<code>nums2</code>中所有整数 <strong>互不相同</strong></p></li><li><code>nums1</code> 中的所有整数同样出现在 <code>nums2</code> 中</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>碰到求下一个更大的元素/上一个更小的元素，用单调栈。</p><p>预处理$nums2$，倒叙遍历$nums2$，用单调栈维护当前位置右边的更大的元素列表，栈内的元素从栈底到栈顶是单调递减的。</p><p>如果存在$i&gt;j$，并且$nums2[i]&lt;nums2[j]$，则$nums2[i]$不会成为答案，要从栈中弹出。</p><p>每个数字的结果用哈希表记录一下。</p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> tt;</span><br><span class="line">    <span class="keyword">int</span> stk[<span class="number">1010</span>];</span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    <span class="comment">// 存每个元素右边第一个比它大的</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 单调栈</span></span><br><span class="line">        <span class="comment">// 如果出现i&gt;j且a[i]&lt;=a[j]，则把i出栈</span></span><br><span class="line">        <span class="comment">// 倒序遍历nums2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums2.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(tt&amp;&amp;nums2[i]&gt;=stk[tt])&#123;</span><br><span class="line">                tt--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tt)&#123;</span><br><span class="line">                mp[nums2[i]]=stk[tt];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                mp[nums2[i]]=<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stk[++tt]=nums2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(nums1.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            ans[i]=mp[nums1[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;10-26-下一个更大元素&quot;&gt;&lt;a href=&quot;#10-26-下一个更大元素&quot; class=&quot;headerlink&quot; title=&quot;10.26 下一个更大元素&quot;&gt;&lt;/a&gt;10.26 下一个更大元素&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/next-greater-element-i/&quot;&gt;https://leetcode-cn.com/problems/next-greater-element-i/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="每日一题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="单调栈" scheme="https://benyang0506.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>单调栈</title>
    <link href="https://benyang0506.github.io/2021/10/26/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <id>https://benyang0506.github.io/2021/10/26/%E5%8D%95%E8%B0%83%E6%A0%88/</id>
    <published>2021-10-26T02:43:10.000Z</published>
    <updated>2021-10-26T03:48:47.104Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="acwing830-单调栈"><a href="#acwing830-单调栈" class="headerlink" title="acwing830 单调栈"></a>acwing830 单调栈</h5><p>传送门：<a href="https://www.acwing.com/problem/content/832/">https://www.acwing.com/problem/content/832/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 N，表示数列长度。</p><p>第二行包含 N 个整数，表示整数数列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含 N 个整数，其中第 i 个数表示第 i 个数的左边第一个比它小的数，如果不存在则输出 −1。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1\leq N\leq10^5 $</p><p>$1\leq数列中元素\leq10^9$</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">3 4 2 7 5</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1 3 -1 2 2</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果$i$在$j$的左边，$a[i]\geq a[j]$，那么$a[i]$永远不会出现在答案中；</p><p>我们维护栈时，保证不包含这样的$a[i]$，最后得到的是一个单调递增的栈。</p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组模拟栈</span></span><br><span class="line"><span class="keyword">int</span> tt;</span><br><span class="line"><span class="keyword">int</span> stk[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">while</span>(tt&amp;&amp;x&lt;=stk[tt]) tt--;</span><br><span class="line">        <span class="keyword">if</span>(tt)&#123;</span><br><span class="line">            cout&lt;&lt;stk[tt]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;-1 &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stk[++tt]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;acwing830-单调栈&quot;&gt;&lt;a href=&quot;#acwing830-单调栈&quot; class=&quot;headerlink&quot; title=&quot;acwing830 单调栈&quot;&gt;&lt;/a&gt;acwing830 单调栈&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://www.acwing.com/problem/content/832/&quot;&gt;https://www.acwing.com/problem/content/832/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="模板题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%A8%A1%E6%9D%BF%E9%A2%98/"/>
    
    
    <category term="单调栈" scheme="https://benyang0506.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>统计最高分的节点数目</title>
    <link href="https://benyang0506.github.io/2021/10/25/%E7%BB%9F%E8%AE%A1%E6%9C%80%E9%AB%98%E5%88%86%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE/"/>
    <id>https://benyang0506.github.io/2021/10/25/%E7%BB%9F%E8%AE%A1%E6%9C%80%E9%AB%98%E5%88%86%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE/</id>
    <published>2021-10-25T08:47:56.000Z</published>
    <updated>2021-10-25T09:03:50.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="第264场周赛C-统计最高分的节点数目"><a href="#第264场周赛C-统计最高分的节点数目" class="headerlink" title="第264场周赛C 统计最高分的节点数目"></a>第264场周赛C 统计最高分的节点数目</h5><p>传送门：<a href="https://leetcode-cn.com/problems/count-nodes-with-the-highest-score/">https://leetcode-cn.com/problems/count-nodes-with-the-highest-score/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给你一棵根节点为 <code>0</code> 的 <strong>二叉树</strong> ，它总共有 <code>n</code> 个节点，节点编号为 <code>0</code> 到 <code>n - 1</code> 。同时给你一个下标从 <strong>0</strong> 开始的整数数组 <code>parents</code> 表示这棵树，其中 <code>parents[i]</code> 是节点 <code>i</code> 的父节点。由于节点 <code>0</code> 是根，所以 <code>parents[0] == -1</code> 。</p><p>一个子树的 <strong>大小</strong> 为这个子树内节点的数目。每个节点都有一个与之关联的 <strong>分数</strong> 。求出某个节点分数的方法是，将这个节点和与它相连的边全部 <strong>删除</strong> ，剩余部分是若干个 <strong>非空</strong> 子树，这个节点的 <strong>分数</strong> 为所有这些子树 <strong>大小的乘积</strong> 。</p><p>请你返回有 <strong>最高得分</strong> 节点的 <strong>数目</strong> 。</p><p><strong>示例 1:</strong></p><p><img src="/2021/10/25/%E7%BB%9F%E8%AE%A1%E6%9C%80%E9%AB%98%E5%88%86%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE/sample1.png" alt></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：parents = [-1,2,0,2,0]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">- 节点 0 的分数为：3 * 1 = 3</span><br><span class="line">- 节点 1 的分数为：4 = 4</span><br><span class="line">- 节点 2 的分数为：1 * 1 * 2 = 2</span><br><span class="line">- 节点 3 的分数为：4 = 4</span><br><span class="line">- 节点 4 的分数为：4 = 4</span><br><span class="line">最高得分为 4 ，有三个节点得分为 4 （分别是节点 1，3 和 4 ）。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/2021/10/25/%E7%BB%9F%E8%AE%A1%E6%9C%80%E9%AB%98%E5%88%86%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE/sample2.png" style="zoom:50%;"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：parents = [-1,2,0]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">- 节点 0 的分数为：2 = 2</span><br><span class="line">- 节点 1 的分数为：2 = 2</span><br><span class="line">- 节点 2 的分数为：1 * 1 = 1</span><br><span class="line">最高分数为 2 ，有两个节点分数为 2 （分别为节点 0 和 1 ）。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == parents.length</code></li><li><p><code>2 &lt;= n &lt;= 1e5</code></p></li><li><p><code>parents[0] == -1</code></p></li><li>对于 <code>i != 0</code> ，有 <code>0 &lt;= parents[i] &lt;= n - 1</code></li><li><code>parents</code> 表示一棵二叉树。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对二叉树来说，删去某个点，最多形成三个连通分量，即左子树，右子树，以及剩下的部分。</p><p>可以先$dfs$一次，预处理出二叉树中以每个结点为根的子树的结点数量。</p><p>然后根据拆分后的情况求得分（是否存在左右子树，是否存在双亲结点/是否为$0$号结点）。</p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// n: 节点总数</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">// 最高得分的结点数</span></span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> childnums[<span class="number">100010</span>];</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; child;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件，叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(child[k].<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            childnums[k]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> childnums[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;child[k].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u=child[k][i];</span><br><span class="line">            childnums[k]+=<span class="built_in">dfs</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">        childnums[k]++;</span><br><span class="line">        <span class="comment">// 加上自己</span></span><br><span class="line">        <span class="keyword">return</span> childnums[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getScore</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> score=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n-childnums[k]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            score=n-childnums[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;child[k].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u=child[k][i];</span><br><span class="line">            score*=childnums[u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countHighestScoreNodes</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; parents)</span> </span>&#123;</span><br><span class="line">        n=parents.<span class="built_in">size</span>();</span><br><span class="line">        child=vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;parents.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            child[parents[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dfs得到以每个节点为根的子树包含的节点数，包含根</span></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;n;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     cout&lt;&lt;childnums[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> tmp=<span class="built_in">getScore</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(tmp&gt;ans)&#123;</span><br><span class="line">                num=<span class="number">1</span>;</span><br><span class="line">                ans=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tmp==ans)&#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;第264场周赛C-统计最高分的节点数目&quot;&gt;&lt;a href=&quot;#第264场周赛C-统计最高分的节点数目&quot; class=&quot;headerlink&quot; title=&quot;第264场周赛C 统计最高分的节点数目&quot;&gt;&lt;/a&gt;第264场周赛C 统计最高分的节点数目&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/count-nodes-with-the-highest-score/&quot;&gt;https://leetcode-cn.com/problems/count-nodes-with-the-highest-score/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="周赛" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="二叉树dfs" scheme="https://benyang0506.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91dfs/"/>
    
  </entry>
  
  <entry>
    <title>并行课程 III</title>
    <link href="https://benyang0506.github.io/2021/10/25/%E5%B9%B6%E8%A1%8C%E8%AF%BE%E7%A8%8B-III/"/>
    <id>https://benyang0506.github.io/2021/10/25/%E5%B9%B6%E8%A1%8C%E8%AF%BE%E7%A8%8B-III/</id>
    <published>2021-10-25T07:33:04.000Z</published>
    <updated>2021-10-25T08:50:32.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="第264场周赛D-并行课程-III"><a href="#第264场周赛D-并行课程-III" class="headerlink" title="第264场周赛D 并行课程 III"></a>第264场周赛D 并行课程 III</h5><p>传送门：<a href="https://leetcode-cn.com/problems/parallel-courses-iii/">https://leetcode-cn.com/problems/parallel-courses-iii/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给你一个整数 <code>n</code> ，表示有 <code>n</code> 节课，课程编号从 <code>1</code> 到 <code>n</code> 。同时给你一个二维整数数组 <code>relations</code> ，其中 <code>relations[j] = [prevCoursej, nextCoursej]</code> ，表示课程 <code>prevCoursej</code> 必须在课程 <code>nextCoursej</code> <strong>之前</strong> 完成（先修课的关系）。同时给你一个下标从 <strong>0</strong> 开始的整数数组 <code>time</code> ，其中 <code>time[i]</code> 表示完成第 <code>(i+1)</code> 门课程需要花费的 <strong>月份</strong> 数。</p><p>请你根据以下规则算出完成所有课程所需要的 <strong>最少</strong> 月份数：</p><ul><li>如果一门课的所有先修课都已经完成，你可以在 <strong>任意</strong> 时间开始这门课程。</li><li>你可以 <strong>同时</strong> 上 <strong>任意门课程</strong> 。</li></ul><p>请你返回完成所有课程所需要的 <strong>最少</strong> 月份数。</p><p><strong>注意：</strong>测试数据保证一定可以完成所有课程（也就是先修课的关系构成一个有向无环图）。</p><p><strong>示例 1:</strong></p><p><img src="/2021/10/25/%E5%B9%B6%E8%A1%8C%E8%AF%BE%E7%A8%8B-III/sample1.png" style="zoom:50%;"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3, relations = [[1,3],[2,3]], time = [3,2,5]</span><br><span class="line">输出：8</span><br><span class="line">解释：上图展示了输入数据所表示的先修关系图，以及完成每门课程需要花费的时间。</span><br><span class="line">你可以在月份 0 同时开始课程 1 和 2 。</span><br><span class="line">课程 1 花费 3 个月，课程 2 花费 2 个月。</span><br><span class="line">所以，最早开始课程 3 的时间是月份 3 ，完成所有课程所需时间为 3 + 5 = 8 个月。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/2021/10/25/%E5%B9%B6%E8%A1%8C%E8%AF%BE%E7%A8%8B-III/sample2.png" style="zoom:50%;"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5, relations = [[1,5],[2,5],[3,5],[3,4],[4,5]], time = [1,2,3,4,5]</span><br><span class="line">输出：12</span><br><span class="line">解释：上图展示了输入数据所表示的先修关系图，以及完成每门课程需要花费的时间。</span><br><span class="line">你可以在月份 0 同时开始课程 1 ，2 和 3 。</span><br><span class="line">在月份 1，2 和 3 分别完成这三门课程。</span><br><span class="line">课程 4 需在课程 3 之后开始，也就是 3 个月后。课程 4 在 3 + 4 = 7 月完成。</span><br><span class="line">课程 5 需在课程 1，2，3 和 4 之后开始，也就是在 max(1,2,3,7) = 7 月开始。</span><br><span class="line">所以完成所有课程所需的最少时间为 7 + 5 = 12 个月。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 5 * 104</code></li><li><p><code>0 &lt;= relations.length &lt;= min(n * (n - 1) / 2, 5 * 104)</code></p></li><li><p><code>relations[j].length == 2</code></p></li><li><p><code>1 &lt;= prevCoursej, nextCoursej &lt;= n</code></p></li><li><p><code>prevCoursej != nextCoursej</code></p></li><li><p>所有的先修课程对 <code>[prevCoursej, nextCoursej]</code> 都是 <strong>互不相同</strong> 的。</p></li><li><p><code>time.length == n</code></p></li><li><p><code>1 &lt;= time[i] &lt;= 104</code></p></li><li><p>先修课程图是一个有向无环图。</p></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>满足拓扑序列的情况下，找出最长的一条路径就是答案。</p><p>可以用数组$f[i]$来记录到达当前节点的最长距离。</p><p>拓扑排序基础题：</p><p><a href="https://www.aben.fun/2021/10/25/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97/">https://www.aben.fun/2021/10/25/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97/</a></p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; e[<span class="number">50010</span>];</span><br><span class="line">    <span class="comment">// 记录当前入度</span></span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">50010</span>];</span><br><span class="line">    <span class="comment">// 记录到达当前节点的最长距离</span></span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">50010</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> n,vector&lt;<span class="keyword">int</span>&gt;&amp; time)</span></span>&#123;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">                f[i]=time[i<span class="number">-1</span>];</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;e[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> v=e[u][i];</span><br><span class="line">                d[v]--;</span><br><span class="line">                <span class="comment">// 每次都需要更新才能找到最长时间（不能等到入度为0才更新）</span></span><br><span class="line">                f[v]=<span class="built_in">max</span>(f[v],f[u]+time[v<span class="number">-1</span>]);</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,f[v]);</span><br><span class="line">                <span class="keyword">if</span>(d[v]==<span class="number">0</span>)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTime</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; relations, vector&lt;<span class="keyword">int</span>&gt;&amp; time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;relations.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u=relations[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> v=relations[i][<span class="number">1</span>];</span><br><span class="line">            e[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">            d[v]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">bfs</span>(n,time);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;第264场周赛D-并行课程-III&quot;&gt;&lt;a href=&quot;#第264场周赛D-并行课程-III&quot; class=&quot;headerlink&quot; title=&quot;第264场周赛D 并行课程 III&quot;&gt;&lt;/a&gt;第264场周赛D 并行课程 III&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/parallel-courses-iii/&quot;&gt;https://leetcode-cn.com/problems/parallel-courses-iii/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="周赛" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="bfs" scheme="https://benyang0506.github.io/tags/bfs/"/>
    
    <category term="拓扑排序" scheme="https://benyang0506.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>有向图的拓扑序列</title>
    <link href="https://benyang0506.github.io/2021/10/25/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97/"/>
    <id>https://benyang0506.github.io/2021/10/25/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97/</id>
    <published>2021-10-25T06:56:21.000Z</published>
    <updated>2021-10-25T07:06:54.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="acwing-848-有向图的拓扑序列"><a href="#acwing-848-有向图的拓扑序列" class="headerlink" title="acwing 848. 有向图的拓扑序列"></a>acwing 848. 有向图的拓扑序列</h5><p>传送门：<a href="https://www.acwing.com/problem/content/850/">https://www.acwing.com/problem/content/850/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给定一个 n 个点 m 条边的有向图，点的编号是 1 到 n，图中可能存在重边和自环。</p><p>请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出 −1。</p><p>若一个由图中所有点构成的序列 A 满足：对于图中的每条边 (x,y)，x在 A 中都出现在 y 之前，则称 A 是该图的一个拓扑序列。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 n 和 m。</p><p>接下来 m 行，每行包含两个整数 x 和 y，表示存在一条从点 x 到点 y 的有向边 (x,y)。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，如果存在拓扑序列，则输出任意一个合法的拓扑序列即可。</p><p>否则输出 −1。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1\leq n,m\leq 10^5$</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>拓扑排序：记录每个节点入度，从入度为0的节点开始$bfs$。</p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; e[N];</span><br><span class="line"><span class="comment">// 记录每个点的入度</span></span><br><span class="line"><span class="keyword">int</span> d[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="comment">// 拓扑排序，从入度为0的点找起</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(d[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">            ans[idx++]=i;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;e[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=e[u][i];</span><br><span class="line">            <span class="comment">// 减去一条入边</span></span><br><span class="line">            d[v]--;</span><br><span class="line">            <span class="keyword">if</span>(d[v]==<span class="number">0</span>)&#123;</span><br><span class="line">                ans[idx++]=v;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(d[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        e[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        d[y]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;-1&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;acwing-848-有向图的拓扑序列&quot;&gt;&lt;a href=&quot;#acwing-848-有向图的拓扑序列&quot; class=&quot;headerlink&quot; title=&quot;acwing 848. 有向图的拓扑序列&quot;&gt;&lt;/a&gt;acwing 848. 有向图的拓扑序列&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://www.acwing.com/problem/content/850/&quot;&gt;https://www.acwing.com/problem/content/850/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="模板题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%A8%A1%E6%9D%BF%E9%A2%98/"/>
    
    
    <category term="bfs" scheme="https://benyang0506.github.io/tags/bfs/"/>
    
    <category term="拓扑排序" scheme="https://benyang0506.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>最长递增路径</title>
    <link href="https://benyang0506.github.io/2021/10/25/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84/"/>
    <id>https://benyang0506.github.io/2021/10/25/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84/</id>
    <published>2021-10-25T05:38:14.000Z</published>
    <updated>2021-10-25T08:51:01.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="剑指-Offer-II-112-最长递增路径"><a href="#剑指-Offer-II-112-最长递增路径" class="headerlink" title="剑指 Offer II 112. 最长递增路径"></a>剑指 Offer II 112. 最长递增路径</h5><p>传送门：<a href="https://leetcode-cn.com/problems/fpTFWP/">https://leetcode-cn.com/problems/fpTFWP/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给定一个 <code>m x n</code> 整数矩阵 <code>matrix</code> ，找出其中 <strong>最长递增路径</strong> 的长度。</p><p>对于每个单元格，你可以往上，下，左，右四个方向移动。 <strong>不能</strong> 在 <strong>对角线</strong> 方向上移动或移动到 <strong>边界外</strong>（即不允许环绕）。</p><p><strong>示例 1：</strong></p><p><img src="/2021/10/25/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84/sample1.png" style="zoom:50%;"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[9,9,4],[6,6,8],[2,1,1]]</span><br><span class="line">输出：4 </span><br><span class="line">解释：最长递增路径为 [1, 2, 6, 9]。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/2021/10/25/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84/sample2.png" style="zoom:50%;"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[3,4,5],[3,2,6],[2,2,1]]</span><br><span class="line">输出：4 </span><br><span class="line">解释：最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>0 &lt;= matrix[i][j] &lt;= 2^31 - 1</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>最朴素的方法为依次$dfs$每个点，找到从每个点开始的最长递增路径的最大值，然后求$max$。</p><p>记忆化$dfs$：由于朴素$dfs$会对同一路径进行大量重复操作，时间复杂度为指数级别。我们可以用$f[i][j]$记录从（i，j）出发可以得到的最长递增路径。下次$dfs$到这个坐标可以直接拿来用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// f[i][j]:从(i,j)出发可以获得的最长递增路径</span></span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记忆化搜索</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[x][y])&#123;</span><br><span class="line">            <span class="keyword">return</span> f[x][y];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最短为1</span></span><br><span class="line">        f[x][y]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> xx=x+dx[i];</span><br><span class="line">            <span class="keyword">int</span> yy=y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(xx&gt;=<span class="number">0</span>&amp;&amp;xx&lt;n&amp;&amp;yy&gt;=<span class="number">0</span>&amp;&amp;yy&lt;m&amp;&amp;matrix[xx][yy]&gt;matrix[x][y])&#123;</span><br><span class="line">                f[x][y]=<span class="built_in">max</span>(f[x][y],<span class="built_in">dfs</span>(matrix,xx,yy)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[x][y];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        n=matrix.<span class="built_in">size</span>();</span><br><span class="line">        m=matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,<span class="built_in">dfs</span>(matrix,i,j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(mn)$，$n$为矩阵的行数，$m$为矩阵的列数。在$dfs$中，时间复杂度为$O(V+E)$，$V$为结点数，$E$为边数$O(V)=O(mn)$，$O(E)\approx O(4mn)$，每个点上下左右四条边。</p><p>空间复杂度：$O(mn)$</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;剑指-Offer-II-112-最长递增路径&quot;&gt;&lt;a href=&quot;#剑指-Offer-II-112-最长递增路径&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer II 112. 最长递增路径&quot;&gt;&lt;/a&gt;剑指 Offer II 112. 最长递增路径&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/fpTFWP/&quot;&gt;https://leetcode-cn.com/problems/fpTFWP/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    
    <category term="记忆化搜索" scheme="https://benyang0506.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>大礼包</title>
    <link href="https://benyang0506.github.io/2021/10/25/%E5%A4%A7%E7%A4%BC%E5%8C%85/"/>
    <id>https://benyang0506.github.io/2021/10/25/%E5%A4%A7%E7%A4%BC%E5%8C%85/</id>
    <published>2021-10-25T04:46:11.000Z</published>
    <updated>2021-10-25T08:51:11.298Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="10-25-每日一题"><a href="#10-25-每日一题" class="headerlink" title="10.25 每日一题"></a>10.25 每日一题</h5><p>传送门：<a href="https://leetcode-cn.com/problems/shopping-offers/">https://leetcode-cn.com/problems/shopping-offers/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>在 LeetCode 商店中， 有 <code>n</code> 件在售的物品。每件物品都有对应的价格。然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。</p><p>给你一个整数数组 <code>price</code> 表示物品价格，其中 <code>price[i]</code> 是第 <code>i</code> 件物品的价格。另有一个整数数组 <code>needs</code> 表示购物清单，其中 <code>needs[i]</code> 是需要购买第 <code>i</code> 件物品的数量。</p><p>还有一个数组 <code>special</code> 表示大礼包，<code>special[i]</code> 的长度为 <code>n + 1</code> ，其中 <code>special[i][j]</code> 表示第 <code>i</code> 个大礼包中内含第 <code>j</code> 件物品的数量，且 <code>special[i][n]</code> （也就是数组中的最后一个整数）为第 <code>i</code> 个大礼包的价格。</p><p>返回 <strong>确切</strong> 满足购物清单所需花费的最低价格，你可以充分利用大礼包的优惠活动。你不能购买超出购物清单指定数量的物品，即使那样会降低整体价格。任意大礼包可无限次购买。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]</span><br><span class="line">输出：14</span><br><span class="line">解释：有 A 和 B 两种物品，价格分别为 ¥2 和 ¥5 。 </span><br><span class="line">大礼包 1 ，你可以以 ¥5 的价格购买 3A 和 0B 。 </span><br><span class="line">大礼包 2 ，你可以以 ¥10 的价格购买 1A 和 2B 。 </span><br><span class="line">需要购买 3 个 A 和 2 个 B ， 所以付 ¥10 购买 1A 和 2B（大礼包 2），以及 ¥4 购买 2A 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]</span><br><span class="line">输出：11</span><br><span class="line">解释：A ，B ，C 的价格分别为 ¥2 ，¥3 ，¥4 。</span><br><span class="line">可以用 ¥4 购买 1A 和 1B ，也可以用 ¥9 购买 2A ，2B 和 1C 。 </span><br><span class="line">需要买 1A ，2B 和 1C ，所以付 ¥4 买 1A 和 1B（大礼包 1），以及 ¥3 购买 1B ， ¥4 购买 1C 。 </span><br><span class="line">不可以购买超出待购清单的物品，尽管购买大礼包 2 更加便宜。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == price.length</code></li><li><code>n == needs.length</code></li><li><code>1 &lt;= n &lt;= 6</code></li><li><code>0 &lt;= price[i] &lt;= 10</code></li><li><code>0 &lt;= needs[i] &lt;= 10</code></li><li><code>1 &lt;= special.length &lt;= 100</code></li><li><code>special[i].length == n + 1</code></li><li><code>0 &lt;= special[i][j] &lt;= 50</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果不考虑大礼包的话需要花费的总价是固定的，所以在考虑大礼包的时候，如果发现选购某个大礼包会使花费的总价减少，就可以更新总价。</p><p>因为没有一种贪心策略，所以只能$dfs$搜索。用$needs$来记录还需要购买的物品集合，$_cache$来记录当前$needs$集合花费的钱的最小值。</p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 记录每一个need的最小价格</span></span><br><span class="line">    map&lt;vector&lt;<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; _cache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shoppingOffers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; special, vector&lt;<span class="keyword">int</span>&gt;&amp; needs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// needs：还需要购买的物品</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(needs,price,special);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; needs,vector&lt;<span class="keyword">int</span>&gt;&amp; price,vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; special)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 子问题计算过，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(_cache[needs])&#123;</span><br><span class="line">            <span class="keyword">return</span> _cache[needs];    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 直接买，不用礼包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;needs.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            ans+=needs[i]*price[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个礼包，依次尝试，看看有没有更便宜的价格</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;special.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; next=needs;</span><br><span class="line">            <span class="keyword">bool</span> valid=<span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 题目要求购买数量为needs，不能超过</span></span><br><span class="line">            <span class="comment">// 检查needs中每一件物品，都不能超过</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> item=<span class="number">0</span>;item&lt;price.<span class="built_in">size</span>();item++)&#123;</span><br><span class="line">                <span class="comment">// 会超过，不符合题意</span></span><br><span class="line">                <span class="keyword">if</span>(special[i][item]&gt;needs[item])&#123;</span><br><span class="line">                    valid=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!valid)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// next记录买过大礼包之后，每件物品还需要多少件</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> item=<span class="number">0</span>;item&lt;price.<span class="built_in">size</span>();item++)&#123;</span><br><span class="line">                next[item]-=special[i][item];</span><br><span class="line">            &#125;</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,<span class="built_in">dfs</span>(next,price,special)+special[i][price.<span class="built_in">size</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">        _cache[needs]=ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(knm^n)$，$k$表示大礼包数量，$n$表示需要多少种物品，$m$表示每种物品的需求量的可能数（0-最大需求量）即最大需求量+1。$needs$最多$m^n$种状态，对每个状态需要遍历所有大礼包，每个大礼包需要遍历所有物品。</p><p>空间复杂度：$O(nm^n)$，$needs$最多$m^n$种状态，每种状态需要存储$n$个物品。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;10-25-每日一题&quot;&gt;&lt;a href=&quot;#10-25-每日一题&quot; class=&quot;headerlink&quot; title=&quot;10.25 每日一题&quot;&gt;&lt;/a&gt;10.25 每日一题&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/shopping-offers/&quot;&gt;https://leetcode-cn.com/problems/shopping-offers/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="每日一题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="记忆化搜索" scheme="https://benyang0506.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>numpy练习</title>
    <link href="https://benyang0506.github.io/2021/10/15/numpy%E7%BB%83%E4%B9%A0/"/>
    <id>https://benyang0506.github.io/2021/10/15/numpy%E7%BB%83%E4%B9%A0/</id>
    <published>2021-10-15T14:38:41.000Z</published>
    <updated>2021-10-25T05:33:45.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="numpy-练习"><a href="#numpy-练习" class="headerlink" title="numpy 练习"></a>numpy 练习</h1><h3 id="numpy-的array操作"><a href="#numpy-的array操作" class="headerlink" title="numpy 的array操作"></a>numpy 的array操作</h3><h4 id="1-导入numpy库"><a href="#1-导入numpy库" class="headerlink" title="1.导入numpy库"></a>1.导入numpy库</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><h4 id="2-建立一个一维数组-a-初始化为-4-5-6-1-输出a-的类型（type）-2-输出a的各维度的大小（shape）-3-输出-a的第一个元素（值为4）"><a href="#2-建立一个一维数组-a-初始化为-4-5-6-1-输出a-的类型（type）-2-输出a的各维度的大小（shape）-3-输出-a的第一个元素（值为4）" class="headerlink" title="2.建立一个一维数组 a 初始化为[4,5,6], (1)输出a 的类型（type）(2)输出a的各维度的大小（shape）(3)输出 a的第一个元素（值为4）"></a>2.建立一个一维数组 a 初始化为[4,5,6], (1)输出a 的类型（type）(2)输出a的各维度的大小（shape）(3)输出 a的第一个元素（值为4）</h4><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=np.array([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><pre><code>&lt;class &#39;numpy.ndarray&#39;&gt;(3,)4</code></pre><h4 id="3-建立一个二维数组-b-初始化为-4-5-6-1-2-3-1-输出各维度的大小（shape）-2-输出-b-0-0-，b-0-1-b-1-1-这三个元素（对应值分别为4-5-2）"><a href="#3-建立一个二维数组-b-初始化为-4-5-6-1-2-3-1-输出各维度的大小（shape）-2-输出-b-0-0-，b-0-1-b-1-1-这三个元素（对应值分别为4-5-2）" class="headerlink" title="3.建立一个二维数组 b,初始化为 [ [4, 5, 6],[1, 2, 3]] (1)输出各维度的大小（shape）(2)输出 b(0,0)，b(0,1),b(1,1) 这三个元素（对应值分别为4,5,2）"></a>3.建立一个二维数组 b,初始化为 [ [4, 5, 6],[1, 2, 3]] (1)输出各维度的大小（shape）(2)输出 b(0,0)，b(0,1),b(1,1) 这三个元素（对应值分别为4,5,2）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b=np.array([[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]])</span><br><span class="line"><span class="built_in">print</span>(b.shape)</span><br><span class="line"><span class="built_in">print</span>(b.shape[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(b.shape[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(b[<span class="number">0</span>,<span class="number">0</span>],b[<span class="number">0</span>,<span class="number">1</span>],b[<span class="number">1</span>,<span class="number">1</span>])</span><br></pre></td></tr></table></figure><pre><code>(2, 3)234 5 2</code></pre><h4 id="4-1-建立一个全0矩阵-a-大小为-3x3-类型为整型（提示-dtype-int）-2-建立一个全1矩阵b-大小为4x5-3-建立一个单位矩阵c-大小为4x4-4-生成一个随机数矩阵d-大小为-3x2"><a href="#4-1-建立一个全0矩阵-a-大小为-3x3-类型为整型（提示-dtype-int）-2-建立一个全1矩阵b-大小为4x5-3-建立一个单位矩阵c-大小为4x4-4-生成一个随机数矩阵d-大小为-3x2" class="headerlink" title="4.  (1)建立一个全0矩阵 a, 大小为 3x3; 类型为整型（提示: dtype = int）(2)建立一个全1矩阵b,大小为4x5;  (3)建立一个单位矩阵c ,大小为4x4; (4)生成一个随机数矩阵d,大小为 3x2."></a>4.  (1)建立一个全0矩阵 a, 大小为 3x3; 类型为整型（提示: dtype = int）(2)建立一个全1矩阵b,大小为4x5;  (3)建立一个单位矩阵c ,大小为4x4; (4)生成一个随机数矩阵d,大小为 3x2.</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=np.zeros((<span class="number">3</span>,<span class="number">3</span>),dtype=<span class="built_in">int</span>)</span><br><span class="line">b=np.ones((<span class="number">4</span>,<span class="number">5</span>))</span><br><span class="line">c=np.eye(<span class="number">4</span>)</span><br><span class="line">d=np.random.randn(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a,b,c,d)</span><br></pre></td></tr></table></figure><pre><code>[[0 0 0] [0 0 0] [0 0 0]] [[1. 1. 1. 1. 1.] [1. 1. 1. 1. 1.] [1. 1. 1. 1. 1.] [1. 1. 1. 1. 1.]] [[1. 0. 0. 0.] [0. 1. 0. 0.] [0. 0. 1. 0.] [0. 0. 0. 1.]] [[ 0.7653732  -0.12668873] [-0.39446617  0.80114903] [-0.9335366  -1.18938761]]</code></pre><h4 id="5-建立一个数组-a-值为-1-2-3-4-5-6-7-8-9-10-11-12-1-打印a-2-输出-下标为-2-3-0-0-这两个数组元素的值"><a href="#5-建立一个数组-a-值为-1-2-3-4-5-6-7-8-9-10-11-12-1-打印a-2-输出-下标为-2-3-0-0-这两个数组元素的值" class="headerlink" title="5. 建立一个数组 a,(值为[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]] ) ,(1)打印a; (2)输出  下标为(2,3),(0,0) 这两个数组元素的值"></a>5. 建立一个数组 a,(值为[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]] ) ,(1)打印a; (2)输出  下标为(2,3),(0,0) 这两个数组元素的值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>,<span class="number">3</span>],a[<span class="number">0</span>,<span class="number">0</span>])</span><br></pre></td></tr></table></figure><pre><code>[[ 1  2  3  4] [ 5  6  7  8] [ 9 10 11 12]]12 1</code></pre><h4 id="6-把上一题的-a数组的-0到1行-2到3列，放到b里面去，（此处不需要从新建立a-直接调用即可）-1-输出b-2-输出b-的（0-0）这个元素的值"><a href="#6-把上一题的-a数组的-0到1行-2到3列，放到b里面去，（此处不需要从新建立a-直接调用即可）-1-输出b-2-输出b-的（0-0）这个元素的值" class="headerlink" title="6.把上一题的 a数组的 0到1行 2到3列，放到b里面去，（此处不需要从新建立a,直接调用即可）(1),输出b;(2) 输出b 的（0,0）这个元素的值"></a>6.把上一题的 a数组的 0到1行 2到3列，放到b里面去，（此处不需要从新建立a,直接调用即可）(1),输出b;(2) 输出b 的（0,0）这个元素的值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b=a[:<span class="number">2</span>,<span class="number">2</span>:<span class="number">4</span>]<span class="comment"># 从起点开始，不包括终点print(b)print(b[0,0])</span></span><br></pre></td></tr></table></figure><pre><code>[[3 4] [7 8]]3</code></pre><h4 id="7-把第5题中数组a的最后两行所有元素放到-c中，（提示：-a-1-2-）-1-输出-c-2-输出-c-中第一行的最后一个元素（提示，使用-1-表示最后一个元素）"><a href="#7-把第5题中数组a的最后两行所有元素放到-c中，（提示：-a-1-2-）-1-输出-c-2-输出-c-中第一行的最后一个元素（提示，使用-1-表示最后一个元素）" class="headerlink" title="7. 把第5题中数组a的最后两行所有元素放到 c中，（提示： a[1:2, :]）(1)输出 c ; (2) 输出 c 中第一行的最后一个元素（提示，使用 -1                 表示最后一个元素）"></a>7. 把第5题中数组a的最后两行所有元素放到 c中，（提示： a[1:2, :]）(1)输出 c ; (2) 输出 c 中第一行的最后一个元素（提示，使用 -1                 表示最后一个元素）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c=a[-<span class="number">2</span>:,:]<span class="built_in">print</span>(c)<span class="built_in">print</span>(c[<span class="number">0</span>,-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><pre><code>[[ 5  6  7  8] [ 9 10 11 12]]8</code></pre><h4 id="8-建立数组a-初始化a为-1-2-3-4-5-6-，输出-（0-0）（1-1）（2-0）这三个元素（提示：-使用-print-a-0-1-2-0-1-0-）"><a href="#8-建立数组a-初始化a为-1-2-3-4-5-6-，输出-（0-0）（1-1）（2-0）这三个元素（提示：-使用-print-a-0-1-2-0-1-0-）" class="headerlink" title="8.建立数组a,初始化a为[[1, 2], [3, 4], [5, 6]]，输出 （0,0）（1,1）（2,0）这三个元素（提示： 使用 print(a[[0, 1, 2], [0, 1, 0]]) ）"></a>8.建立数组a,初始化a为[[1, 2], [3, 4], [5, 6]]，输出 （0,0）（1,1）（2,0）这三个元素（提示： 使用 print(a[[0, 1, 2], [0, 1, 0]]) ）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]])<span class="built_in">print</span>(a)<span class="comment"># print(a[0,0],a[1,1],a[2,0])print(a[[0,1,2],[0,1,0]])</span></span><br></pre></td></tr></table></figure><pre><code>[[1 2] [3 4] [5 6]][1 4 5]</code></pre><h4 id="9-建立矩阵a-初始化为-1-2-3-4-5-6-7-8-9-10-11-12-，输出-0-0-1-2-2-0-3-1-提示使用-b-np-array-0-2-0-1-print-a-np-arange-4-b"><a href="#9-建立矩阵a-初始化为-1-2-3-4-5-6-7-8-9-10-11-12-，输出-0-0-1-2-2-0-3-1-提示使用-b-np-array-0-2-0-1-print-a-np-arange-4-b" class="headerlink" title="9.建立矩阵a ,初始化为[[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]，输出(0,0),(1,2),(2,0),(3,1) (提示使用 b = np.array([0, 2, 0, 1])                     print(a[np.arange(4), b]))"></a>9.建立矩阵a ,初始化为[[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]，输出(0,0),(1,2),(2,0),(3,1) (提示使用 b = np.array([0, 2, 0, 1])                     print(a[np.arange(4), b]))</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])<span class="built_in">print</span>(a)b=np.array([<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>])<span class="built_in">print</span>(a[np.arange(<span class="number">4</span>),b])</span><br></pre></td></tr></table></figure><pre><code>[[ 1  2  3] [ 4  5  6] [ 7  8  9] [10 11 12]][ 1  6  7 11]</code></pre><h4 id="10-对9-中输出的那四个元素，每个都加上10，然后重新输出矩阵a-提示：-a-np-arange-4-b-10-）"><a href="#10-对9-中输出的那四个元素，每个都加上10，然后重新输出矩阵a-提示：-a-np-arange-4-b-10-）" class="headerlink" title="10.对9 中输出的那四个元素，每个都加上10，然后重新输出矩阵a.(提示： a[np.arange(4), b] += 10 ）"></a>10.对9 中输出的那四个元素，每个都加上10，然后重新输出矩阵a.(提示： a[np.arange(4), b] += 10 ）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a)a[np.arange(<span class="number">4</span>),np.array([<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>])]+=10<span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><pre><code>[[ 1  2  3] [ 4  5  6] [ 7  8  9] [10 11 12]][[11  2  3] [ 4  5 16] [17  8  9] [10 21 12]]</code></pre><h3 id="array-的数学运算"><a href="#array-的数学运算" class="headerlink" title="array 的数学运算"></a>array 的数学运算</h3><h4 id="11-执行-x-np-array-1-2-，然后输出-x-的数据类型"><a href="#11-执行-x-np-array-1-2-，然后输出-x-的数据类型" class="headerlink" title="11.  执行 x = np.array([1, 2])，然后输出 x 的数据类型"></a>11.  执行 x = np.array([1, 2])，然后输出 x 的数据类型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=np.array([<span class="number">1</span>,<span class="number">2</span>])<span class="built_in">print</span>(x)<span class="built_in">print</span>(x.dtype)</span><br></pre></td></tr></table></figure><pre><code>[1 2]int32</code></pre><h4 id="12-执行-x-np-array-1-0-2-0-，然后输出-x-的数据类类型"><a href="#12-执行-x-np-array-1-0-2-0-，然后输出-x-的数据类类型" class="headerlink" title="12.执行 x = np.array([1.0, 2.0]) ，然后输出 x 的数据类类型"></a>12.执行 x = np.array([1.0, 2.0]) ，然后输出 x 的数据类类型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=np.array([<span class="number">1.0</span>,<span class="number">2.0</span>])<span class="built_in">print</span>(x.dtype)</span><br></pre></td></tr></table></figure><pre><code>float64</code></pre><h4 id="13-执行-x-np-array-1-2-3-4-dtype-np-float64-，y-np-array-5-6-7-8-dtype-np-float64-，然后输出-x-y-和-np-add-x-y"><a href="#13-执行-x-np-array-1-2-3-4-dtype-np-float64-，y-np-array-5-6-7-8-dtype-np-float64-，然后输出-x-y-和-np-add-x-y" class="headerlink" title="13.执行 x = np.array([[1, 2], [3, 4]], dtype=np.float64) ，y = np.array([[5, 6], [7, 8]], dtype=np.float64)，然后输出 x+y ,和 np.add(x,y)"></a>13.执行 x = np.array([[1, 2], [3, 4]], dtype=np.float64) ，y = np.array([[5, 6], [7, 8]], dtype=np.float64)，然后输出 x+y ,和 np.add(x,y)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]],dtype=np.float64)y=np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]],dtype=np.float64)<span class="built_in">print</span>(x+y)<span class="built_in">print</span>(np.add(x,y))</span><br></pre></td></tr></table></figure><pre><code>[[ 6.  8.] [10. 12.]][[ 6.  8.] [10. 12.]]</code></pre><h4 id="14-利用-13题目中的x-y-输出-x-y-和-np-subtract-x-y"><a href="#14-利用-13题目中的x-y-输出-x-y-和-np-subtract-x-y" class="headerlink" title="14. 利用 13题目中的x,y 输出 x-y 和 np.subtract(x,y)"></a>14. 利用 13题目中的x,y 输出 x-y 和 np.subtract(x,y)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(x-y)<span class="built_in">print</span>(np.subtract(x,y))</span><br></pre></td></tr></table></figure><pre><code>[[-4. -4.] [-4. -4.]][[-4. -4.] [-4. -4.]]</code></pre><h4 id="15-利用13题目中的x，y-输出-x-y-和-np-multiply-x-y-还有-np-dot-x-y-比较差异。然后自己换一个不是方阵的试试。"><a href="#15-利用13题目中的x，y-输出-x-y-和-np-multiply-x-y-还有-np-dot-x-y-比较差异。然后自己换一个不是方阵的试试。" class="headerlink" title="15. 利用13题目中的x，y 输出 x*y ,和 np.multiply(x, y) 还有  np.dot(x,y),比较差异。然后自己换一个不是方阵的试试。"></a>15. 利用13题目中的x，y 输出 x*y ,和 np.multiply(x, y) 还有  np.dot(x,y),比较差异。然后自己换一个不是方阵的试试。</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(x)<span class="built_in">print</span>(y)<span class="built_in">print</span>(x*y) <span class="comment">#对应元素相乘print(np.multiply(x,y)) #对应元素相乘print(np.dot(x,y)) #矩阵乘法</span></span><br></pre></td></tr></table></figure><pre><code>[[1. 2.] [3. 4.]][[5. 6.] [7. 8.]][[ 5. 12.] [21. 32.]][[ 5. 12.] [21. 32.]][[19. 22.] [43. 50.]]</code></pre><h4 id="16-利用13题目中的x-y-输出-x-y-提示-：-使用函数-np-divide"><a href="#16-利用13题目中的x-y-输出-x-y-提示-：-使用函数-np-divide" class="headerlink" title="16. 利用13题目中的x,y,输出 x / y .(提示 ： 使用函数 np.divide())"></a>16. 利用13题目中的x,y,输出 x / y .(提示 ： 使用函数 np.divide())</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(x/y)<span class="built_in">print</span>(np.divide(x,y))</span><br></pre></td></tr></table></figure><pre><code>[[0.2        0.33333333] [0.42857143 0.5       ]][[0.2        0.33333333] [0.42857143 0.5       ]]</code></pre><h4 id="17-利用13题目中的x-输出-x的-开方。-提示：-使用函数-np-sqrt"><a href="#17-利用13题目中的x-输出-x的-开方。-提示：-使用函数-np-sqrt" class="headerlink" title="17. 利用13题目中的x,输出 x的 开方。(提示： 使用函数 np.sqrt() )"></a>17. 利用13题目中的x,输出 x的 开方。(提示： 使用函数 np.sqrt() )</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.sqrt(x))<span class="built_in">print</span>(x**<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><pre><code>[[1.         1.41421356] [1.73205081 2.        ]][[1.         1.41421356] [1.73205081 2.        ]]</code></pre><h4 id="18-利用13题目中的x-y-执行-print-x-dot-y-和-print-np-dot-x-y"><a href="#18-利用13题目中的x-y-执行-print-x-dot-y-和-print-np-dot-x-y" class="headerlink" title="18.利用13题目中的x,y ,执行 print(x.dot(y)) 和 print(np.dot(x,y))"></a>18.利用13题目中的x,y ,执行 print(x.dot(y)) 和 print(np.dot(x,y))</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(x.dot(y))<span class="built_in">print</span>(np.dot(x,y))</span><br></pre></td></tr></table></figure><pre><code>[[19. 22.] [43. 50.]][[19. 22.] [43. 50.]]</code></pre><h5 id="19-利用13题目中的-x-进行求和。提示：输出三种求和-1-print-np-sum-x-2-print-np-sum-x，axis-0-3-print-np-sum-x-axis-1"><a href="#19-利用13题目中的-x-进行求和。提示：输出三种求和-1-print-np-sum-x-2-print-np-sum-x，axis-0-3-print-np-sum-x-axis-1" class="headerlink" title="19.利用13题目中的 x,进行求和。提示：输出三种求和 (1)print(np.sum(x)):   (2)print(np.sum(x，axis =0 ));   (3)print(np.sum(x,axis = 1))"></a>19.利用13题目中的 x,进行求和。提示：输出三种求和 (1)print(np.sum(x)):   (2)print(np.sum(x，axis =0 ));   (3)print(np.sum(x,axis = 1))</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(x)<span class="built_in">print</span>(np.<span class="built_in">sum</span>(x)) <span class="comment"># 所有元素和print(np.sum(x,axis=0))  # 把行压缩掉print(np.sum(x,axis=1))  # 把列压缩掉</span></span><br></pre></td></tr></table></figure><pre><code>[[1. 2.] [3. 4.]]10.0[4. 6.][3. 7.]</code></pre><h4 id="20-利用13题目中的-x-进行求平均数（提示：输出三种平均数-1-print-np-mean-x-2-print-np-mean-x-axis-0-3-print-np-mean-x-axis-1-）"><a href="#20-利用13题目中的-x-进行求平均数（提示：输出三种平均数-1-print-np-mean-x-2-print-np-mean-x-axis-0-3-print-np-mean-x-axis-1-）" class="headerlink" title="20.利用13题目中的 x,进行求平均数（提示：输出三种平均数(1)print(np.mean(x)) (2)print(np.mean(x,axis = 0))(3) print(np.mean(x,axis =1))）"></a>20.利用13题目中的 x,进行求平均数（提示：输出三种平均数(1)print(np.mean(x)) (2)print(np.mean(x,axis = 0))(3) print(np.mean(x,axis =1))）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.mean(x))<span class="built_in">print</span>(np.mean(x,axis=<span class="number">0</span>))<span class="built_in">print</span>(np.mean(x,axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><pre><code>2.5[2. 3.][1.5 3.5]</code></pre><h4 id="21-利用13题目中的x，对x-进行矩阵转置，然后输出转置后的结果，（提示：-x-T-表示对-x-的转置）"><a href="#21-利用13题目中的x，对x-进行矩阵转置，然后输出转置后的结果，（提示：-x-T-表示对-x-的转置）" class="headerlink" title="21.利用13题目中的x，对x 进行矩阵转置，然后输出转置后的结果，（提示： x.T 表示对 x 的转置）"></a>21.利用13题目中的x，对x 进行矩阵转置，然后输出转置后的结果，（提示： x.T 表示对 x 的转置）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(x)<span class="built_in">print</span>(x.T)</span><br></pre></td></tr></table></figure><pre><code>[[1. 2.] [3. 4.]][[1. 3.] [2. 4.]]</code></pre><h4 id="22-利用13题目中的x-求e的指数（提示：-函数-np-exp-）"><a href="#22-利用13题目中的x-求e的指数（提示：-函数-np-exp-）" class="headerlink" title="22.利用13题目中的x,求e的指数（提示： 函数 np.exp()）"></a>22.利用13题目中的x,求e的指数（提示： 函数 np.exp()）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.exp(x))</span><br></pre></td></tr></table></figure><pre><code>[[ 2.71828183  7.3890561 ] [20.08553692 54.59815003]]</code></pre><h4 id="23-利用13题目中的-x-求值最大的下标（提示-1-print-np-argmax-x-2-print-np-argmax-x-axis-0-3-print-np-argmax-x-axis-1"><a href="#23-利用13题目中的-x-求值最大的下标（提示-1-print-np-argmax-x-2-print-np-argmax-x-axis-0-3-print-np-argmax-x-axis-1" class="headerlink" title="23.利用13题目中的 x,求值最大的下标（提示(1)print(np.argmax(x)) ,(2) print(np.argmax(x, axis =0))(3)print(np.argmax(x),axis =1))"></a>23.利用13题目中的 x,求值最大的下标（提示(1)print(np.argmax(x)) ,(2) print(np.argmax(x, axis =0))(3)print(np.argmax(x),axis =1))</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(x)<span class="built_in">print</span>(np.argmax(x)) <span class="comment"># 看成一维之后的最大索引值？print(np.argmax(x,axis=0)) # 每一列的最大索引值print(np.argmax(x,axis=1)) # 每一行的最大索引值</span></span><br></pre></td></tr></table></figure><pre><code>[[1. 2.] [3. 4.]]3[1 1][1 1]</code></pre><h4 id="24-画图，y-x-x-其中-x-np-arange-0-100-0-1-（提示这里用到-matplotlib-pyplot-库）"><a href="#24-画图，y-x-x-其中-x-np-arange-0-100-0-1-（提示这里用到-matplotlib-pyplot-库）" class="headerlink" title="24,画图，y=x*x 其中 x = np.arange(0, 100, 0.1) （提示这里用到  matplotlib.pyplot 库）"></a>24,画图，y=x*x 其中 x = np.arange(0, 100, 0.1) （提示这里用到  matplotlib.pyplot 库）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=np.arange(<span class="number">0</span>,<span class="number">100</span>,<span class="number">0.1</span>)plt.plot(x,x*x)plt.show()</span><br></pre></td></tr></table></figure><p>​    <img src="/2021/10/15/numpy%E7%BB%83%E4%B9%A0/output_51_0.png" alt><br>​    </p><h4 id="25-画图。画正弦函数和余弦函数，-x-np-arange-0-3-np-pi-0-1-提示：这里用到-np-sin-np-cos-函数和-matplotlib-pyplot-库"><a href="#25-画图。画正弦函数和余弦函数，-x-np-arange-0-3-np-pi-0-1-提示：这里用到-np-sin-np-cos-函数和-matplotlib-pyplot-库" class="headerlink" title="25.画图。画正弦函数和余弦函数， x = np.arange(0, 3 * np.pi, 0.1)(提示：这里用到 np.sin() np.cos() 函数和 matplotlib.pyplot 库)"></a>25.画图。画正弦函数和余弦函数， x = np.arange(0, 3 * np.pi, 0.1)(提示：这里用到 np.sin() np.cos() 函数和 matplotlib.pyplot 库)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=np.arange(<span class="number">0</span>,<span class="number">3</span>*np.pi,<span class="number">0.1</span>)plt.plot(x,np.sin(x))plt.plot(x,np.cos(x))plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2021/10/15/numpy%E7%BB%83%E4%B9%A0/output_53_0.png" alt></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;numpy-练习&quot;&gt;&lt;a href=&quot;#numpy-练习&quot; class=&quot;headerlink&quot; title=&quot;numpy 练习&quot;&gt;&lt;/a&gt;numpy 练习&lt;/h1&gt;&lt;h3 id=&quot;numpy-的array操作&quot;&gt;&lt;a href=&quot;#numpy-的array操作&quot; class=&quot;headerlink&quot; title=&quot;numpy 的array操作&quot;&gt;&lt;/a&gt;numpy 的array操作&lt;/h3&gt;&lt;h4 id=&quot;1-导入numpy库&quot;&gt;&lt;a href=&quot;#1-导入numpy库&quot; class=&quot;headerlink&quot; title=&quot;1.导入numpy库&quot;&gt;&lt;/a&gt;1.导入numpy库&lt;/h4&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; plt&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;2-建立一个一维数组-a-初始化为-4-5-6-1-输出a-的类型（type）-2-输出a的各维度的大小（shape）-3-输出-a的第一个元素（值为4）&quot;&gt;&lt;a href=&quot;#2-建立一个一维数组-a-初始化为-4-5-6-1-输出a-的类型（type）-2-输出a的各维度的大小（shape）-3-输出-a的第一个元素（值为4）&quot; class=&quot;headerlink&quot; title=&quot;2.建立一个一维数组 a 初始化为[4,5,6], (1)输出a 的类型（type）(2)输出a的各维度的大小（shape）(3)输出 a的第一个元素（值为4）&quot;&gt;&lt;/a&gt;2.建立一个一维数组 a 初始化为[4,5,6], (1)输出a 的类型（type）(2)输出a的各维度的大小（shape）(3)输出 a的第一个元素（值为4）&lt;/h4&gt;</summary>
    
    
    
    <category term="蒲公英书编程练习" scheme="https://benyang0506.github.io/categories/%E8%92%B2%E5%85%AC%E8%8B%B1%E4%B9%A6%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/"/>
    
    <category term="numpy练习" scheme="https://benyang0506.github.io/categories/%E8%92%B2%E5%85%AC%E8%8B%B1%E4%B9%A6%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/numpy%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="numpy" scheme="https://benyang0506.github.io/tags/numpy/"/>
    
  </entry>
  
  <entry>
    <title>离散化</title>
    <link href="https://benyang0506.github.io/2021/10/14/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    <id>https://benyang0506.github.io/2021/10/14/%E7%A6%BB%E6%95%A3%E5%8C%96/</id>
    <published>2021-10-14T05:41:41.000Z</published>
    <updated>2021-10-14T05:54:57.558Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h5><p>传送门：<a href="https://www.acwing.com/problem/content/804/">https://www.acwing.com/problem/content/804/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>假定有一个无限长的数轴，数轴上每个坐标上的数都是 00。</p><p>现在，我们首先进行 nn 次操作，每次操作将某一位置 xx 上的数加 cc。</p><p>接下来，进行 mm 次询问，每个询问包含两个整数 ll 和 rr，你需要求出在区间 [l,r][l,r] 之间的所有数的和。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 nn 和 mm。</p><p>接下来 nn 行，每行包含两个整数 xx 和 cc。</p><p>再接下来 mm 行，每行包含两个整数 ll 和 rr。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 mm 行，每行输出一个询问中所求的区间内数字和。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$-1e9≤x≤1e9$</p><p>$1≤n,m≤1e5$</p><p>$-1e9≤l≤r≤1e9$</p><p>$−10000≤c≤10000$</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">3 6</span><br><span class="line">7 5</span><br><span class="line">1 3</span><br><span class="line">4 6</span><br><span class="line">7 8</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">0</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>离散化基础模板题</p><p>$x$的范围非常大，数组开不出来，但是实际用到的点不多，可以将这些用到的点映射到较小的数组中（保序），就是离散化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PIR;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有坐标的点的个数，add最大1e5个点，query最多1e5次，每次两个点</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">300000</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有坐标的点的个数</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; alls;</span><br><span class="line"></span><br><span class="line">vector&lt;PIR&gt; query;</span><br><span class="line">vector&lt;PIR&gt; add;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 离散化后的原数组</span></span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="comment">// 离散化后的前缀和数组</span></span><br><span class="line"><span class="keyword">int</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分找映射后的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=alls.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(alls[mid]&gt;=x)&#123;</span><br><span class="line">            r=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使离散化后的原数组从1开始，方便求前缀和</span></span><br><span class="line">    <span class="keyword">return</span> l+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,c;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;c;</span><br><span class="line">        add.<span class="built_in">push_back</span>(&#123;x,c&#125;);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        query.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(l);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//保序离散化+去重</span></span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>());</span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>()),alls.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// add</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;add.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=add[i].first;</span><br><span class="line">        <span class="keyword">int</span> c=add[i].second;</span><br><span class="line">        a[<span class="built_in">find</span>(x)]+=c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 预处理前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=alls.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// query</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;query.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l=query[i].first;</span><br><span class="line">        <span class="keyword">int</span> r=query[i].second;</span><br><span class="line">        cout&lt;&lt;s[<span class="built_in">find</span>(r)]-s[<span class="built_in">find</span>(l)<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;区间和&quot;&gt;&lt;a href=&quot;#区间和&quot; class=&quot;headerlink&quot; title=&quot;区间和&quot;&gt;&lt;/a&gt;区间和&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://www.acwing.com/problem/content/804/&quot;&gt;https://www.acwing.com/problem/content/804/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="模板题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%A8%A1%E6%9D%BF%E9%A2%98/"/>
    
    
    <category term="离散化" scheme="https://benyang0506.github.io/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="https://benyang0506.github.io/2021/10/14/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>https://benyang0506.github.io/2021/10/14/%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2021-10-14T03:47:38.000Z</published>
    <updated>2021-10-14T05:49:34.258Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="连通块中点的数量"><a href="#连通块中点的数量" class="headerlink" title="连通块中点的数量"></a>连通块中点的数量</h5><p>传送门：<a href="https://www.acwing.com/problem/content/839/">https://www.acwing.com/problem/content/839/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给定一个包含 nn 个点（编号为 1∼n1∼n）的无向图，初始时图中没有边。</p><p>现在要进行 mm 个操作，操作共有三种：</p><ol><li><code>C a b</code>，在点 aa 和点 bb 之间连一条边，aa 和 bb 可能相等；</li><li><code>Q1 a b</code>，询问点 aa 和点 bb 是否在同一个连通块中，aa 和 bb 可能相等；</li><li><code>Q2 a</code>，询问点 aa 所在连通块中点的数量；</li></ol><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入整数 nn 和 mm。</p><p>接下来 mm 行，每行包含一个操作指令，指令为 <code>C a b</code>，<code>Q1 a b</code> 或 <code>Q2 a</code> 中的一种。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个询问指令 <code>Q1 a b</code>，如果 aa 和 bb 在同一个连通块中，则输出 <code>Yes</code>，否则输出 <code>No</code>。</p><p>对于每个询问指令 <code>Q2 a</code>，输出一个整数表示点 aa 所在连通块中点的数量</p><p>每个结果占一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1≤n,m≤1e5</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 5</span><br><span class="line">C 1 2</span><br><span class="line">Q1 1 2</span><br><span class="line">Q2 1</span><br><span class="line">C 2 5</span><br><span class="line">Q2 5</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>并查集基础模板题</p><p>$cnt[N]$：记录每个集合中元素个数</p><p>$p[N]$：存当前节点父结点，路径压缩后存根结点</p><p>合并集合时先合并数量，再连边。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p[i]：节点i的根节点</span></span><br><span class="line"><span class="comment">// p[i]=i，i为根节点</span></span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="comment">// 记录每个集合中的元素个数</span></span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找x的根节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果x不是根节点</span></span><br><span class="line">    <span class="keyword">if</span>(x!=p[x]) </span><br><span class="line">        <span class="comment">// 将p[x]设置为根节点</span></span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="comment">// 返回根节点</span></span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">// 每个点都是根节点，各自为一个集合</span></span><br><span class="line">        p[i]=i;</span><br><span class="line">        <span class="comment">// 每个集合一开始只有1个点（自己）</span></span><br><span class="line">        cnt[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">&quot;Q2&quot;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            cout&lt;&lt;cnt[<span class="built_in">find</span>(x)]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">&quot;Q1&quot;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x)==<span class="built_in">find</span>(y))&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// x与y不能再同一个集合</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x)!=<span class="built_in">find</span>(y))&#123;</span><br><span class="line">                <span class="comment">// 先更新cnt</span></span><br><span class="line">                cnt[<span class="built_in">find</span>(y)]+=cnt[<span class="built_in">find</span>(x)];</span><br><span class="line">                <span class="comment">// 将根节点连起来</span></span><br><span class="line">                p[<span class="built_in">find</span>(x)]=<span class="built_in">find</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$find()$时间复杂度可以看成$O(1)$。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;连通块中点的数量&quot;&gt;&lt;a href=&quot;#连通块中点的数量&quot; class=&quot;headerlink&quot; title=&quot;连通块中点的数量&quot;&gt;&lt;/a&gt;连通块中点的数量&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://www.acwing.com/problem/content/839/&quot;&gt;https://www.acwing.com/problem/content/839/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="模板题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%A8%A1%E6%9D%BF%E9%A2%98/"/>
    
    
    <category term="并查集" scheme="https://benyang0506.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>linux基本操作</title>
    <link href="https://benyang0506.github.io/2021/09/29/linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>https://benyang0506.github.io/2021/09/29/linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</id>
    <published>2021-09-29T12:52:11.000Z</published>
    <updated>2021-10-26T11:55:08.047Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux基本操作"><a href="#Linux基本操作" class="headerlink" title="Linux基本操作"></a>Linux基本操作</h2><h5 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h5><p>列出目标目录中所有子目录和文件的信息</p><p>命令语法：ls [选项] [目录或文件名]</p><span id="more"></span><p>命令示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -a</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /etc</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>-a：—all的缩写，显示所有的文件，包括隐藏文件(以.开头的文件)</li><li>-l：列出长数据串，显示出文件的属性与权限等数据信息</li></ul><h5 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h5><p>显示当前工作目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure><h5 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h5><p>切换当前工作目录至目标目录</p><p>命令语法：cd [dirName]</p><p>命令示例：切换至/etc/目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /etc</span><br></pre></td></tr></table></figure><p>参数dirName常用解释：</p><ul><li>绝对路径：从根目录开始,依次将各级子目录的名字组合起来，路径的写法一定是由根目录 / 写起，例如 /usr/local/ ”</li><li>相对路径：相对当前所在路径的位置，路径的写法不是由根目录“ / ”写起，例如“ work/test ”</li><li>. ：”.” 表示目前所在的目录</li><li>.. : “..” 表示目前目录位置的上一层目录</li><li>～：表示当前用户的home目录，也就是刚 login 时所在的目录</li></ul><p>命令示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd sbin/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd .</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br></pre></td></tr></table></figure><h5 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h5><p>拷贝文件或目录</p><p>命令语法：cp [options] source dest</p><p>命令示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r abc cba</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/inittab ./</span><br></pre></td></tr></table></figure><p>常用参数</p><ul><li>-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。</li></ul><h5 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h5><p>创建目录</p><p>命令语法：mkdir [参数][目录名称]</p><p>命令示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir work</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir work/test</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p abc/test</span><br></pre></td></tr></table></figure><ul><li>-p：如果目录路径中的某级目录不存在，则自动创建</li></ul><h5 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h5><p>删除文件或目录</p><p>命令语法：mkdir [参数][目录名称]</p><p>命令示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm inittab</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -r abc</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf cba</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>-r：删除目录用的选项,使用命令rm删除目录时，一定要加-r选项</li><li>-f：表示强制删除</li></ul><p>注意：rm -rf命令非常危险，使用时一定要确保命令正确，路径不要以/开头。</p><p>如果不小心执行了“ rm -rf / ”，后果很严重，哭都来不及了</p><h5 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h5><p>将文件输出到标准输出</p><p>命令语法：cat [选项] [文件]</p><p>命令示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat inittab</span><br></pre></td></tr></table></figure><h5 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h5><p>移动文件或目录</p><p>命令语法：mv [选项] source dest</p><p>命令示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv inittab abc/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv work/ abc/</span><br></pre></td></tr></table></figure><h5 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h5><p>修改文件或目录的权限</p><p>命令语法：chmod [选项] [文件]</p><ul><li>上图中红色圈中的“rwx r-x r-x”，r代表读、w代表写、x代表执行、-代表没有权限。</li><li>第一个root代表该文件的所有者是root用户</li><li>第二个root代表该文件所属群组为root群组</li><li>rwx代表该文件所有者有读写执行权限</li><li>第一个r-x代表所在组的用户对该文件有读和执行的权限，没有写的权限</li><li>第二个r-x代表其他用户对该文件有读和执行的权限，没有写的权限</li></ul><p>解释说明：</p><ul><li>文件或目录权限控制分为读取(r)、写入(w)、执行(x)3种</li><li>具有全部权限的二进制可理解为 “111” 即 十进制的 “7”</li><li>只有读写权限二进制可理解为 “100” 即 十进制的 “4”</li></ul><p>命令示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 abc</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a-x abc</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x abc</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 755 abc</span><br></pre></td></tr></table></figure><p>常用参数解释：</p><ul><li>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是</li><li>+ 表示增加权限、- 表示取消权限</li><li>r 表示可读取，w 表示可写入，x 表示可执行</li><li>-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)</li></ul><h5 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h5><p>打包压缩或解压</p><p>命令语法：tar [选项] [文件…]</p><p>命令示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf abc.tar.gz abc/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf abc.tar.gz</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Linux基本操作&quot;&gt;&lt;a href=&quot;#Linux基本操作&quot; class=&quot;headerlink&quot; title=&quot;Linux基本操作&quot;&gt;&lt;/a&gt;Linux基本操作&lt;/h2&gt;&lt;h5 id=&quot;ls命令&quot;&gt;&lt;a href=&quot;#ls命令&quot; class=&quot;headerlink&quot; title=&quot;ls命令&quot;&gt;&lt;/a&gt;ls命令&lt;/h5&gt;&lt;p&gt;列出目标目录中所有子目录和文件的信息&lt;/p&gt;
&lt;p&gt;命令语法：ls [选项] [目录或文件名]&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://benyang0506.github.io/categories/Linux/"/>
    
    
    <category term="linux" scheme="https://benyang0506.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>寻找重复数</title>
    <link href="https://benyang0506.github.io/2021/09/16/%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/"/>
    <id>https://benyang0506.github.io/2021/09/16/%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/</id>
    <published>2021-09-16T02:00:56.000Z</published>
    <updated>2021-09-16T08:27:56.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><p>传送门：<a href="&lt;https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">&lt;https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a>&gt;</p><p><a href="http://10.129.27.27/contest/9/problem/1002">http://10.129.27.27/contest/9/problem/1002</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p><p>要求算法空间复杂度为 O(1) (不包括输入数组).</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>输入包含两行, 第一行为一个正整数 n, 第二行为 n + 1 个正整数.</p><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>输出为单独一行, 即所有给出的数中重复的数.</p><h5 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 3 4 2 2</span><br></pre></td></tr></table></figure><h5 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h5 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">3 1 3 4 2</span><br></pre></td></tr></table></figure><h5 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="方法一：二分"><a href="#方法一：二分" class="headerlink" title="方法一：二分"></a>方法一：二分</h4><p>我们用$cnt[i]$来记录原数组中小于等于$i$的个数，假设重复的数为$ans$，则<code>1&lt;i&lt;ans</code>时，<code>cnt[i]&lt;=i</code>，<code>ans&lt;=i&lt;=n</code>时，<code>cnt[i]&gt;i</code>；</p><p>已知答案一定在1到$n$之间，二分的思路是每次猜一个数$mid$，然后统计原数组中小于等于$mid$的个数$cnt$，利用上述性质进行二分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 二分</span></span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&lt;=mid)&#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 符合条件</span></span><br><span class="line">            <span class="keyword">if</span>(cnt&gt;mid)&#123;</span><br><span class="line">                r=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(nlgn)$，空间复杂度$O(1)$。</p><h4 id="方法二：位运算"><a href="#方法二：位运算" class="headerlink" title="方法二：位运算"></a>方法二：位运算</h4><p>我们定义数组$v1$，$v1[i]$记录数字1~n的二进制表示中，第$i$位为1的数量；</p><p>接着定义数组$v2$，$v2[i]$记录$nums$数组中所有数的二进制表示中，第$i$位为1的数量。</p><p>因为重复的数会多次出现，所以存在$i$，有$v1[i]&gt;v2[i]$，所有这些$i$的二进制表示组成的和即为重复的数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// 最大位数</span></span><br><span class="line">        <span class="keyword">int</span> bit_Max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(t)&#123;</span><br><span class="line">            t&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            bit_Max++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bit_Max;i++)&#123;</span><br><span class="line">            v1.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">            v2.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bit_Max;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((j&gt;&gt;i)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                    v1[i]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bit_Max;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((nums[j])&gt;&gt;i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                    v2[i]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bit_Max;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v2[i]&gt;v1[i])&#123;</span><br><span class="line">                ans=ans+(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(nlgn)$，空间复杂度$O(1)$。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;p&gt;传送门：&lt;a href=&quot;&amp;lt;https://leetcode-cn.com/problems/intersection-of-two-linked-lists/&quot;&gt;&amp;lt;https://leetcode-cn.com/problems/intersection-of-two-linked-lists/&lt;/a&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://10.129.27.27/contest/9/problem/1002&quot;&gt;http://10.129.27.27/contest/9/problem/1002&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="课堂作业" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E8%AF%BE%E5%A0%82%E4%BD%9C%E4%B8%9A/"/>
    
    
    <category term="双指针" scheme="https://benyang0506.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="位运算" scheme="https://benyang0506.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="二分" scheme="https://benyang0506.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
</feed>
