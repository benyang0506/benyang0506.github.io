<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阿犇</title>
  
  <subtitle>记录生活中的点点滴滴</subtitle>
  <link href="https://benyang0506.github.io/atom.xml" rel="self"/>
  
  <link href="https://benyang0506.github.io/"/>
  <updated>2021-10-27T06:26:38.282Z</updated>
  <id>https://benyang0506.github.io/</id>
  
  <author>
    <name>杨犇</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>删除无效的括号</title>
    <link href="https://benyang0506.github.io/2021/10/27/%E5%88%A0%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>https://benyang0506.github.io/2021/10/27/%E5%88%A0%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</id>
    <published>2021-10-27T02:19:28.000Z</published>
    <updated>2021-10-27T06:26:38.282Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><p>10.27 每日一题</p><p>传送门：<a href="https://leetcode-cn.com/problems/remove-invalid-parentheses/">https://leetcode-cn.com/problems/remove-invalid-parentheses/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给你一个由若干括号和字母组成的字符串 <code>s</code> ，删除最小数量的无效括号，使得输入的字符串有效。</p><p>返回所有可能的结果。答案可以按 <strong>任意顺序</strong> 返回。</p><p> <strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()())()&quot;</span><br><span class="line">输出：[&quot;(())()&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;(a)())()&quot;</span><br><span class="line">输出：[&quot;(a())()&quot;,&quot;(a)()()&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;)(&quot;</span><br><span class="line">输出：[&quot;&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 25</code></li><li><code>s</code> 由小写英文字母以及括号 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 组成</li><li><code>s</code> 中至多含 <code>20</code> 个括号</li></ul><h3 id="方法一：dfs-剪枝"><a href="#方法一：dfs-剪枝" class="headerlink" title="方法一：dfs+剪枝"></a>方法一：dfs+剪枝</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h5 id="我们发现，删除的无效括号的最小数量是可以提前求出来的。"><a href="#我们发现，删除的无效括号的最小数量是可以提前求出来的。" class="headerlink" title="我们发现，删除的无效括号的最小数量是可以提前求出来的。"></a>我们发现，删除的无效括号的最小数量是可以提前求出来的。</h5><p>可以用一个计数器$lnum$来模拟栈，往栈中不断地添加左括号；</p><p>之后出现的右括号都可以去栈中匹配左括号，最后栈中剩下的即为要删去的左括号，数量等于$lnum$。</p><p>右括号出现时，栈中没有左括号用来匹配，则右括号需要删去，计数器$rnum$++，记录需要删去的右括号数量。</p><h5 id="dfs-搜索"><a href="#dfs-搜索" class="headerlink" title="$dfs$搜索"></a>$dfs$搜索</h5><p>$dfs$所有删去$lnum$个左括号、$rnum$个右括号的序列，并判断是否有效。</p><h5 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h5><p>记录当前序列中的左括号数目$lc$与右括号数目$rc$，如果右括号数目$rc&gt;lc$，则这个序列一定为无效序列，停止搜索。</p><h5 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h5><p>按照上述算法搜索出的结果中可能含有重复序列，比如当前遇到的字符串为” (((())”，去掉前四个左括号中的任意一个，生成的字符串是一样的，均为 “(())”。</p><ul><li><p>在最后的结果中去重，可以使用哈希表/$set$/$sort+unique$。</p></li><li><p>在搜索过程中，遇到相邻元素相同的情况时，只需要搜索一次就好。（剪枝）</p></li></ul><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(st.<span class="built_in">top</span>()!=<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        st.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(string s,<span class="keyword">int</span> lremove,<span class="keyword">int</span> rremove,<span class="keyword">int</span> start,<span class="keyword">int</span> lc,<span class="keyword">int</span> rc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lremove==<span class="number">0</span>&amp;&amp;rremove==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isValid</span>(s))&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=start &amp;&amp; s[i]==s[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>) lc++;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>) rc++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 去掉一个左括号</span></span><br><span class="line">            <span class="keyword">if</span>(lremove&gt;<span class="number">0</span>&amp;&amp;s[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">dfs</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>,i)+s.<span class="built_in">substr</span>(i+<span class="number">1</span>),lremove<span class="number">-1</span>,rremove,i,lc,rc);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//去掉一个右括号</span></span><br><span class="line">            <span class="keyword">if</span>(rremove&gt;<span class="number">0</span>&amp;&amp;s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">dfs</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>,i)+s.<span class="built_in">substr</span>(i+<span class="number">1</span>),lremove,rremove<span class="number">-1</span>,i,lc,rc);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                lc++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                rc++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rc&gt;lc)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">removeInvalidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先计算需要删除的左括号数量、右括号数量</span></span><br><span class="line">        <span class="keyword">int</span> lnum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rnum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                lnum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(lnum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    lnum--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    rnum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dfs</span>(s,lnum,rnum,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// sort(ans.begin(),ans.end());</span></span><br><span class="line">        <span class="comment">// ans.erase(unique(ans.begin(),ans.end()),ans.end());</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n*2^n)$，$n$为字符串的长度，长度为$n$的字符串最多有$2^n$个子串，需要对每个子串进行一次合法性判断。</p><h3 id="方法二：bfs"><a href="#方法二：bfs" class="headerlink" title="方法二：bfs"></a>方法二：bfs</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>注意到题目说的是删去最少的括号，我们可以每次删去一个括号，就所有删去一个括号的操作作为$bfs$的一层，判断这一层有没有符合条件的序列；如果没有就继续删一个括号，转向下一层，以此类推，一旦在某一层找到答案便停止搜索。</p><p>我们做$bfs$，上一层$level$和下一层$level$之间的关系为：把所有上一层$level$中的每个元素都拿出来，列举出在删除一个括号后的所有可能的情况。(不管删除以后是否合法），添加到下一个$level$中的元素。</p><p>例如：$current level$是 <code>[&quot;(()&quot;, &quot;())&quot;]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 那么下一层level中的元素应该是:</span><br><span class="line"></span><br><span class="line">    1. 对 &quot;(()&quot; 删除一个括号的所有可能为： (), (), ((</span><br><span class="line">    2. 对 &quot;())&quot; 删除一个括号的所有可能为： (), )), ()</span><br></pre></td></tr></table></figure><p>注意到有重复的序列，可以使用$unordered_set$代替$queue$，以达到去重的目的。</p><h4 id="程序-1"><a href="#程序-1" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isvalid</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                ans--;</span><br><span class="line">                <span class="keyword">if</span>(ans&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bfs</span></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">removeInvalidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// unordered_set模拟队列</span></span><br><span class="line">        <span class="comment">// 每一层删去一些字符后会有重复元素，可以在进队前去重</span></span><br><span class="line">        unordered_set&lt;string&gt; q;</span><br><span class="line">        <span class="comment">// 存答案</span></span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        q.<span class="built_in">insert</span>(s);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">// 遍历这一层中的所有序列，如果有符合条件的，加入ans中，并且终止向下一层搜索。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> ss:q)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">isvalid</span>(ss))&#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(ss);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ans.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 继续搜索下一层</span></span><br><span class="line">            unordered_set&lt;string&gt; curq;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> ss:q)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ss.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;ss[i]==ss[i<span class="number">-1</span>])&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(ss[i]==<span class="string">&#x27;(&#x27;</span>||ss[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                        curq.<span class="built_in">insert</span>(ss.<span class="built_in">substr</span>(<span class="number">0</span>,i)+ss.<span class="built_in">substr</span>(i+<span class="number">1</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            q=curq;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n*2^n)$，$n$为字符串的长度，长度为$n$的字符串最多有$2^n$个子串，需要对每个子串进行一次合法性判断。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;p&gt;10.27 每日一题&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/remove-invalid-parentheses/&quot;&gt;https://leetcode-cn.com/problems/remove-invalid-parentheses/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="每日一题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="dfs" scheme="https://benyang0506.github.io/tags/dfs/"/>
    
    <category term="bfs" scheme="https://benyang0506.github.io/tags/bfs/"/>
    
  </entry>
  
  <entry>
    <title>Jupyter notebook 快捷键</title>
    <link href="https://benyang0506.github.io/2021/10/26/Jupyter-notebook%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://benyang0506.github.io/2021/10/26/Jupyter-notebook%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2021-10-26T11:52:57.000Z</published>
    <updated>2021-10-26T12:05:26.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Jupyter-notebook-快捷键"><a href="#Jupyter-notebook-快捷键" class="headerlink" title="Jupyter notebook 快捷键"></a>Jupyter notebook 快捷键</h2><h5 id="Jupyter-Notebook-有两种键盘输入模式。"><a href="#Jupyter-Notebook-有两种键盘输入模式。" class="headerlink" title="Jupyter Notebook 有两种键盘输入模式。"></a>Jupyter Notebook 有两种键盘输入模式。</h5><p>编辑模式，允许你往单元中键入代码或文本；这时的单元框线是绿色的。</p><span id="more"></span><p>命令模式，键盘输入运行程序命令；这时的单元框线是灰色的。</p><h3 id="命令模式-按键-Esc-开启"><a href="#命令模式-按键-Esc-开启" class="headerlink" title="命令模式 (按键 Esc 开启)"></a>命令模式 (按键 Esc 开启)</h3><ul><li>Enter : 转入编辑模式</li><li>Shift-Enter : 运行本单元，选中下个单元</li><li>Ctrl-Enter : 运行本单元</li><li>Alt-Enter : 运行本单元，在其下插入新单元</li><li>Y : 单元转入代码状态</li><li>M :单元转入markdown状态</li><li>R : 单元转入raw状态</li><li>1 : 设定 1 级标题</li><li>2 : 设定 2 级标题</li><li>3 : 设定 3 级标题</li><li>4 : 设定 4 级标题</li><li>5 : 设定 5 级标题</li><li>6 : 设定 6 级标题</li><li>Up : 选中上方单元</li><li>K : 选中上方单元</li><li>Down : 选中下方单元</li><li>J : 选中下方单元</li><li>Shift-K : 扩大选中上方单元</li><li>Shift-J : 扩大选中下方单元</li><li>A : 在上方插入新单元</li><li>B : 在下方插入新单元</li><li>X : 剪切选中的单元</li><li>C : 复制选中的单元</li><li>Shift-V : 粘贴到上方单元</li><li>V : 粘贴到下方单元</li><li>Z : 恢复删除的最后一个单元</li><li>D,D : 删除选中的单元</li><li>Shift-M : 合并选中的单元</li><li>Ctrl-S : 文件存盘</li><li>S : 文件存盘</li><li>L : 转换行号</li><li>O : 转换输出</li><li>Shift-O : 转换输出滚动</li><li>Esc : 关闭页面</li><li>Q : 关闭页面</li><li>H : 显示快捷键帮助</li><li>I,I : 中断Notebook内核</li><li>0,0 : 重启Notebook内核</li><li>Shift : 忽略</li><li>Shift-Space : 向上滚动</li><li>Space : 向下滚动</li></ul><h3 id="编辑模式-Enter-键启动"><a href="#编辑模式-Enter-键启动" class="headerlink" title="编辑模式 ( Enter 键启动)"></a>编辑模式 ( Enter 键启动)</h3><ul><li>Tab : 代码补全或缩进</li><li>Shift-Tab : 提示</li><li>Ctrl-] : 缩进</li><li>Ctrl-[ : 解除缩进</li><li>Ctrl-A : 全选</li><li>Ctrl-Z : 复原</li><li>Ctrl-Shift-Z : 再做</li><li>Ctrl-Y : 再做</li><li>Ctrl-Home : 跳到单元开头</li><li>Ctrl-Up : 跳到单元开头</li><li>Ctrl-End : 跳到单元末尾</li><li>Ctrl-Down : 跳到单元末尾</li><li>Ctrl-Left : 跳到左边一个字首</li><li>Ctrl-Right : 跳到右边一个字首</li><li>Ctrl-Backspace : 删除前面一个字</li><li>Ctrl-Delete : 删除后面一个字</li><li>Esc : 进入命令模式</li><li>Ctrl-M : 进入命令模式</li><li>Shift-Enter : 运行本单元，选中下一单元</li><li>Ctrl-Enter : 运行本单元</li><li>Alt-Enter : 运行本单元，在下面插入一单元</li><li>Ctrl-Shift– : 分割单元</li><li>Ctrl-Shift-Subtract : 分割单元</li><li>Ctrl-S : 文件存盘</li><li>Shift : 忽略</li><li>Up : 光标上移或转入上一单元</li><li>Down :光标下移或转入下一单元</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Jupyter-notebook-快捷键&quot;&gt;&lt;a href=&quot;#Jupyter-notebook-快捷键&quot; class=&quot;headerlink&quot; title=&quot;Jupyter notebook 快捷键&quot;&gt;&lt;/a&gt;Jupyter notebook 快捷键&lt;/h2&gt;&lt;h5 id=&quot;Jupyter-Notebook-有两种键盘输入模式。&quot;&gt;&lt;a href=&quot;#Jupyter-Notebook-有两种键盘输入模式。&quot; class=&quot;headerlink&quot; title=&quot;Jupyter Notebook 有两种键盘输入模式。&quot;&gt;&lt;/a&gt;Jupyter Notebook 有两种键盘输入模式。&lt;/h5&gt;&lt;p&gt;编辑模式，允许你往单元中键入代码或文本；这时的单元框线是绿色的。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习/深度学习基础" scheme="https://benyang0506.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="jupyter" scheme="https://benyang0506.github.io/tags/jupyter/"/>
    
  </entry>
  
  <entry>
    <title>下一个更大元素I</title>
    <link href="https://benyang0506.github.io/2021/10/26/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I/"/>
    <id>https://benyang0506.github.io/2021/10/26/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I/</id>
    <published>2021-10-26T04:26:31.000Z</published>
    <updated>2021-10-26T04:49:43.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="10-26-下一个更大元素"><a href="#10-26-下一个更大元素" class="headerlink" title="10.26 下一个更大元素"></a>10.26 下一个更大元素</h5><p>传送门：<a href="https://leetcode-cn.com/problems/next-greater-element-i/">https://leetcode-cn.com/problems/next-greater-element-i/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给你两个 <strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，其中<code>nums1</code> 是 <code>nums2</code> 的子集。</p><p>请你找出 <code>nums1</code> 中每个元素在 <code>nums2</code> 中的下一个比其大的值。</p><p><code>nums1</code> 中数字 <code>x</code> 的下一个更大元素是指 <code>x</code> 在 <code>nums2</code> 中对应位置的右边的第一个比 <code>x</code> 大的元素。如果不存在，对应位置输出 <code>-1</code> 。</p><p> <strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [4,1,2], nums2 = [1,3,4,2].</span><br><span class="line">输出: [-1,3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。</span><br><span class="line">    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。</span><br><span class="line">    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [2,4], nums2 = [1,2,3,4].</span><br><span class="line">输出: [3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。</span><br><span class="line">    对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li><li><p><code>0 &lt;= nums1[i], nums2[i] &lt;= 10^4</code></p></li><li><p><code>nums1</code>和<code>nums2</code>中所有整数 <strong>互不相同</strong></p></li><li><code>nums1</code> 中的所有整数同样出现在 <code>nums2</code> 中</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>碰到求下一个更大的元素/上一个更小的元素，用单调栈。</p><p>预处理$nums2$，倒叙遍历$nums2$，用单调栈维护当前位置右边的更大的元素列表，栈内的元素从栈底到栈顶是单调递减的。</p><p>如果存在$i&gt;j$，并且$nums2[i]&lt;nums2[j]$，则$nums2[i]$不会成为答案，要从栈中弹出。</p><p>每个数字的结果用哈希表记录一下。</p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> tt;</span><br><span class="line">    <span class="keyword">int</span> stk[<span class="number">1010</span>];</span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    <span class="comment">// 存每个元素右边第一个比它大的</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 单调栈</span></span><br><span class="line">        <span class="comment">// 如果出现i&gt;j且a[i]&lt;=a[j]，则把i出栈</span></span><br><span class="line">        <span class="comment">// 倒序遍历nums2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums2.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(tt&amp;&amp;nums2[i]&gt;=stk[tt])&#123;</span><br><span class="line">                tt--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tt)&#123;</span><br><span class="line">                mp[nums2[i]]=stk[tt];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                mp[nums2[i]]=<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stk[++tt]=nums2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(nums1.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            ans[i]=mp[nums1[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;10-26-下一个更大元素&quot;&gt;&lt;a href=&quot;#10-26-下一个更大元素&quot; class=&quot;headerlink&quot; title=&quot;10.26 下一个更大元素&quot;&gt;&lt;/a&gt;10.26 下一个更大元素&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/next-greater-element-i/&quot;&gt;https://leetcode-cn.com/problems/next-greater-element-i/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="每日一题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="单调栈" scheme="https://benyang0506.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>单调栈</title>
    <link href="https://benyang0506.github.io/2021/10/26/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <id>https://benyang0506.github.io/2021/10/26/%E5%8D%95%E8%B0%83%E6%A0%88/</id>
    <published>2021-10-26T02:43:10.000Z</published>
    <updated>2021-10-26T03:48:47.104Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="acwing830-单调栈"><a href="#acwing830-单调栈" class="headerlink" title="acwing830 单调栈"></a>acwing830 单调栈</h5><p>传送门：<a href="https://www.acwing.com/problem/content/832/">https://www.acwing.com/problem/content/832/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 N，表示数列长度。</p><p>第二行包含 N 个整数，表示整数数列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含 N 个整数，其中第 i 个数表示第 i 个数的左边第一个比它小的数，如果不存在则输出 −1。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1\leq N\leq10^5 $</p><p>$1\leq数列中元素\leq10^9$</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">3 4 2 7 5</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1 3 -1 2 2</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果$i$在$j$的左边，$a[i]\geq a[j]$，那么$a[i]$永远不会出现在答案中；</p><p>我们维护栈时，保证不包含这样的$a[i]$，最后得到的是一个单调递增的栈。</p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组模拟栈</span></span><br><span class="line"><span class="keyword">int</span> tt;</span><br><span class="line"><span class="keyword">int</span> stk[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">while</span>(tt&amp;&amp;x&lt;=stk[tt]) tt--;</span><br><span class="line">        <span class="keyword">if</span>(tt)&#123;</span><br><span class="line">            cout&lt;&lt;stk[tt]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;-1 &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stk[++tt]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;acwing830-单调栈&quot;&gt;&lt;a href=&quot;#acwing830-单调栈&quot; class=&quot;headerlink&quot; title=&quot;acwing830 单调栈&quot;&gt;&lt;/a&gt;acwing830 单调栈&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://www.acwing.com/problem/content/832/&quot;&gt;https://www.acwing.com/problem/content/832/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="模板题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%A8%A1%E6%9D%BF%E9%A2%98/"/>
    
    
    <category term="单调栈" scheme="https://benyang0506.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>统计最高分的节点数目</title>
    <link href="https://benyang0506.github.io/2021/10/25/%E7%BB%9F%E8%AE%A1%E6%9C%80%E9%AB%98%E5%88%86%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE/"/>
    <id>https://benyang0506.github.io/2021/10/25/%E7%BB%9F%E8%AE%A1%E6%9C%80%E9%AB%98%E5%88%86%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE/</id>
    <published>2021-10-25T08:47:56.000Z</published>
    <updated>2021-10-25T09:03:50.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="第264场周赛C-统计最高分的节点数目"><a href="#第264场周赛C-统计最高分的节点数目" class="headerlink" title="第264场周赛C 统计最高分的节点数目"></a>第264场周赛C 统计最高分的节点数目</h5><p>传送门：<a href="https://leetcode-cn.com/problems/count-nodes-with-the-highest-score/">https://leetcode-cn.com/problems/count-nodes-with-the-highest-score/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给你一棵根节点为 <code>0</code> 的 <strong>二叉树</strong> ，它总共有 <code>n</code> 个节点，节点编号为 <code>0</code> 到 <code>n - 1</code> 。同时给你一个下标从 <strong>0</strong> 开始的整数数组 <code>parents</code> 表示这棵树，其中 <code>parents[i]</code> 是节点 <code>i</code> 的父节点。由于节点 <code>0</code> 是根，所以 <code>parents[0] == -1</code> 。</p><p>一个子树的 <strong>大小</strong> 为这个子树内节点的数目。每个节点都有一个与之关联的 <strong>分数</strong> 。求出某个节点分数的方法是，将这个节点和与它相连的边全部 <strong>删除</strong> ，剩余部分是若干个 <strong>非空</strong> 子树，这个节点的 <strong>分数</strong> 为所有这些子树 <strong>大小的乘积</strong> 。</p><p>请你返回有 <strong>最高得分</strong> 节点的 <strong>数目</strong> 。</p><p><strong>示例 1:</strong></p><p><img src="/2021/10/25/%E7%BB%9F%E8%AE%A1%E6%9C%80%E9%AB%98%E5%88%86%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE/sample1.png" alt></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：parents = [-1,2,0,2,0]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">- 节点 0 的分数为：3 * 1 = 3</span><br><span class="line">- 节点 1 的分数为：4 = 4</span><br><span class="line">- 节点 2 的分数为：1 * 1 * 2 = 2</span><br><span class="line">- 节点 3 的分数为：4 = 4</span><br><span class="line">- 节点 4 的分数为：4 = 4</span><br><span class="line">最高得分为 4 ，有三个节点得分为 4 （分别是节点 1，3 和 4 ）。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/2021/10/25/%E7%BB%9F%E8%AE%A1%E6%9C%80%E9%AB%98%E5%88%86%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE/sample2.png" style="zoom:50%;"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：parents = [-1,2,0]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">- 节点 0 的分数为：2 = 2</span><br><span class="line">- 节点 1 的分数为：2 = 2</span><br><span class="line">- 节点 2 的分数为：1 * 1 = 1</span><br><span class="line">最高分数为 2 ，有两个节点分数为 2 （分别为节点 0 和 1 ）。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == parents.length</code></li><li><p><code>2 &lt;= n &lt;= 1e5</code></p></li><li><p><code>parents[0] == -1</code></p></li><li>对于 <code>i != 0</code> ，有 <code>0 &lt;= parents[i] &lt;= n - 1</code></li><li><code>parents</code> 表示一棵二叉树。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对二叉树来说，删去某个点，最多形成三个连通分量，即左子树，右子树，以及剩下的部分。</p><p>可以先$dfs$一次，预处理出二叉树中以每个结点为根的子树的结点数量。</p><p>然后根据拆分后的情况求得分（是否存在左右子树，是否存在双亲结点/是否为$0$号结点）。</p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// n: 节点总数</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">// 最高得分的结点数</span></span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> childnums[<span class="number">100010</span>];</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; child;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件，叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(child[k].<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            childnums[k]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> childnums[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;child[k].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u=child[k][i];</span><br><span class="line">            childnums[k]+=<span class="built_in">dfs</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">        childnums[k]++;</span><br><span class="line">        <span class="comment">// 加上自己</span></span><br><span class="line">        <span class="keyword">return</span> childnums[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getScore</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> score=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n-childnums[k]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            score=n-childnums[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;child[k].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u=child[k][i];</span><br><span class="line">            score*=childnums[u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countHighestScoreNodes</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; parents)</span> </span>&#123;</span><br><span class="line">        n=parents.<span class="built_in">size</span>();</span><br><span class="line">        child=vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;parents.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            child[parents[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dfs得到以每个节点为根的子树包含的节点数，包含根</span></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;n;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     cout&lt;&lt;childnums[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> tmp=<span class="built_in">getScore</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(tmp&gt;ans)&#123;</span><br><span class="line">                num=<span class="number">1</span>;</span><br><span class="line">                ans=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tmp==ans)&#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;第264场周赛C-统计最高分的节点数目&quot;&gt;&lt;a href=&quot;#第264场周赛C-统计最高分的节点数目&quot; class=&quot;headerlink&quot; title=&quot;第264场周赛C 统计最高分的节点数目&quot;&gt;&lt;/a&gt;第264场周赛C 统计最高分的节点数目&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/count-nodes-with-the-highest-score/&quot;&gt;https://leetcode-cn.com/problems/count-nodes-with-the-highest-score/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="周赛" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="二叉树dfs" scheme="https://benyang0506.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91dfs/"/>
    
  </entry>
  
  <entry>
    <title>并行课程 III</title>
    <link href="https://benyang0506.github.io/2021/10/25/%E5%B9%B6%E8%A1%8C%E8%AF%BE%E7%A8%8B-III/"/>
    <id>https://benyang0506.github.io/2021/10/25/%E5%B9%B6%E8%A1%8C%E8%AF%BE%E7%A8%8B-III/</id>
    <published>2021-10-25T07:33:04.000Z</published>
    <updated>2021-10-25T08:50:32.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="第264场周赛D-并行课程-III"><a href="#第264场周赛D-并行课程-III" class="headerlink" title="第264场周赛D 并行课程 III"></a>第264场周赛D 并行课程 III</h5><p>传送门：<a href="https://leetcode-cn.com/problems/parallel-courses-iii/">https://leetcode-cn.com/problems/parallel-courses-iii/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给你一个整数 <code>n</code> ，表示有 <code>n</code> 节课，课程编号从 <code>1</code> 到 <code>n</code> 。同时给你一个二维整数数组 <code>relations</code> ，其中 <code>relations[j] = [prevCoursej, nextCoursej]</code> ，表示课程 <code>prevCoursej</code> 必须在课程 <code>nextCoursej</code> <strong>之前</strong> 完成（先修课的关系）。同时给你一个下标从 <strong>0</strong> 开始的整数数组 <code>time</code> ，其中 <code>time[i]</code> 表示完成第 <code>(i+1)</code> 门课程需要花费的 <strong>月份</strong> 数。</p><p>请你根据以下规则算出完成所有课程所需要的 <strong>最少</strong> 月份数：</p><ul><li>如果一门课的所有先修课都已经完成，你可以在 <strong>任意</strong> 时间开始这门课程。</li><li>你可以 <strong>同时</strong> 上 <strong>任意门课程</strong> 。</li></ul><p>请你返回完成所有课程所需要的 <strong>最少</strong> 月份数。</p><p><strong>注意：</strong>测试数据保证一定可以完成所有课程（也就是先修课的关系构成一个有向无环图）。</p><p><strong>示例 1:</strong></p><p><img src="/2021/10/25/%E5%B9%B6%E8%A1%8C%E8%AF%BE%E7%A8%8B-III/sample1.png" style="zoom:50%;"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3, relations = [[1,3],[2,3]], time = [3,2,5]</span><br><span class="line">输出：8</span><br><span class="line">解释：上图展示了输入数据所表示的先修关系图，以及完成每门课程需要花费的时间。</span><br><span class="line">你可以在月份 0 同时开始课程 1 和 2 。</span><br><span class="line">课程 1 花费 3 个月，课程 2 花费 2 个月。</span><br><span class="line">所以，最早开始课程 3 的时间是月份 3 ，完成所有课程所需时间为 3 + 5 = 8 个月。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/2021/10/25/%E5%B9%B6%E8%A1%8C%E8%AF%BE%E7%A8%8B-III/sample2.png" style="zoom:50%;"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5, relations = [[1,5],[2,5],[3,5],[3,4],[4,5]], time = [1,2,3,4,5]</span><br><span class="line">输出：12</span><br><span class="line">解释：上图展示了输入数据所表示的先修关系图，以及完成每门课程需要花费的时间。</span><br><span class="line">你可以在月份 0 同时开始课程 1 ，2 和 3 。</span><br><span class="line">在月份 1，2 和 3 分别完成这三门课程。</span><br><span class="line">课程 4 需在课程 3 之后开始，也就是 3 个月后。课程 4 在 3 + 4 = 7 月完成。</span><br><span class="line">课程 5 需在课程 1，2，3 和 4 之后开始，也就是在 max(1,2,3,7) = 7 月开始。</span><br><span class="line">所以完成所有课程所需的最少时间为 7 + 5 = 12 个月。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 5 * 104</code></li><li><p><code>0 &lt;= relations.length &lt;= min(n * (n - 1) / 2, 5 * 104)</code></p></li><li><p><code>relations[j].length == 2</code></p></li><li><p><code>1 &lt;= prevCoursej, nextCoursej &lt;= n</code></p></li><li><p><code>prevCoursej != nextCoursej</code></p></li><li><p>所有的先修课程对 <code>[prevCoursej, nextCoursej]</code> 都是 <strong>互不相同</strong> 的。</p></li><li><p><code>time.length == n</code></p></li><li><p><code>1 &lt;= time[i] &lt;= 104</code></p></li><li><p>先修课程图是一个有向无环图。</p></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>满足拓扑序列的情况下，找出最长的一条路径就是答案。</p><p>可以用数组$f[i]$来记录到达当前节点的最长距离。</p><p>拓扑排序基础题：</p><p><a href="https://www.aben.fun/2021/10/25/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97/">https://www.aben.fun/2021/10/25/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97/</a></p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; e[<span class="number">50010</span>];</span><br><span class="line">    <span class="comment">// 记录当前入度</span></span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">50010</span>];</span><br><span class="line">    <span class="comment">// 记录到达当前节点的最长距离</span></span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">50010</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> n,vector&lt;<span class="keyword">int</span>&gt;&amp; time)</span></span>&#123;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">                f[i]=time[i<span class="number">-1</span>];</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;e[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> v=e[u][i];</span><br><span class="line">                d[v]--;</span><br><span class="line">                <span class="comment">// 每次都需要更新才能找到最长时间（不能等到入度为0才更新）</span></span><br><span class="line">                f[v]=<span class="built_in">max</span>(f[v],f[u]+time[v<span class="number">-1</span>]);</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,f[v]);</span><br><span class="line">                <span class="keyword">if</span>(d[v]==<span class="number">0</span>)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTime</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; relations, vector&lt;<span class="keyword">int</span>&gt;&amp; time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;relations.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u=relations[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> v=relations[i][<span class="number">1</span>];</span><br><span class="line">            e[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">            d[v]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">bfs</span>(n,time);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;第264场周赛D-并行课程-III&quot;&gt;&lt;a href=&quot;#第264场周赛D-并行课程-III&quot; class=&quot;headerlink&quot; title=&quot;第264场周赛D 并行课程 III&quot;&gt;&lt;/a&gt;第264场周赛D 并行课程 III&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/parallel-courses-iii/&quot;&gt;https://leetcode-cn.com/problems/parallel-courses-iii/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="周赛" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="bfs" scheme="https://benyang0506.github.io/tags/bfs/"/>
    
    <category term="拓扑排序" scheme="https://benyang0506.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>有向图的拓扑序列</title>
    <link href="https://benyang0506.github.io/2021/10/25/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97/"/>
    <id>https://benyang0506.github.io/2021/10/25/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97/</id>
    <published>2021-10-25T06:56:21.000Z</published>
    <updated>2021-10-25T07:06:54.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="acwing-848-有向图的拓扑序列"><a href="#acwing-848-有向图的拓扑序列" class="headerlink" title="acwing 848. 有向图的拓扑序列"></a>acwing 848. 有向图的拓扑序列</h5><p>传送门：<a href="https://www.acwing.com/problem/content/850/">https://www.acwing.com/problem/content/850/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给定一个 n 个点 m 条边的有向图，点的编号是 1 到 n，图中可能存在重边和自环。</p><p>请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出 −1。</p><p>若一个由图中所有点构成的序列 A 满足：对于图中的每条边 (x,y)，x在 A 中都出现在 y 之前，则称 A 是该图的一个拓扑序列。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 n 和 m。</p><p>接下来 m 行，每行包含两个整数 x 和 y，表示存在一条从点 x 到点 y 的有向边 (x,y)。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，如果存在拓扑序列，则输出任意一个合法的拓扑序列即可。</p><p>否则输出 −1。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1\leq n,m\leq 10^5$</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>拓扑排序：记录每个节点入度，从入度为0的节点开始$bfs$。</p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; e[N];</span><br><span class="line"><span class="comment">// 记录每个点的入度</span></span><br><span class="line"><span class="keyword">int</span> d[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="comment">// 拓扑排序，从入度为0的点找起</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(d[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">            ans[idx++]=i;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;e[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=e[u][i];</span><br><span class="line">            <span class="comment">// 减去一条入边</span></span><br><span class="line">            d[v]--;</span><br><span class="line">            <span class="keyword">if</span>(d[v]==<span class="number">0</span>)&#123;</span><br><span class="line">                ans[idx++]=v;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(d[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        e[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        d[y]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;-1&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;acwing-848-有向图的拓扑序列&quot;&gt;&lt;a href=&quot;#acwing-848-有向图的拓扑序列&quot; class=&quot;headerlink&quot; title=&quot;acwing 848. 有向图的拓扑序列&quot;&gt;&lt;/a&gt;acwing 848. 有向图的拓扑序列&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://www.acwing.com/problem/content/850/&quot;&gt;https://www.acwing.com/problem/content/850/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="模板题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%A8%A1%E6%9D%BF%E9%A2%98/"/>
    
    
    <category term="bfs" scheme="https://benyang0506.github.io/tags/bfs/"/>
    
    <category term="拓扑排序" scheme="https://benyang0506.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>最长递增路径</title>
    <link href="https://benyang0506.github.io/2021/10/25/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84/"/>
    <id>https://benyang0506.github.io/2021/10/25/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84/</id>
    <published>2021-10-25T05:38:14.000Z</published>
    <updated>2021-10-25T08:51:01.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="剑指-Offer-II-112-最长递增路径"><a href="#剑指-Offer-II-112-最长递增路径" class="headerlink" title="剑指 Offer II 112. 最长递增路径"></a>剑指 Offer II 112. 最长递增路径</h5><p>传送门：<a href="https://leetcode-cn.com/problems/fpTFWP/">https://leetcode-cn.com/problems/fpTFWP/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给定一个 <code>m x n</code> 整数矩阵 <code>matrix</code> ，找出其中 <strong>最长递增路径</strong> 的长度。</p><p>对于每个单元格，你可以往上，下，左，右四个方向移动。 <strong>不能</strong> 在 <strong>对角线</strong> 方向上移动或移动到 <strong>边界外</strong>（即不允许环绕）。</p><p><strong>示例 1：</strong></p><p><img src="/2021/10/25/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84/sample1.png" style="zoom:50%;"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[9,9,4],[6,6,8],[2,1,1]]</span><br><span class="line">输出：4 </span><br><span class="line">解释：最长递增路径为 [1, 2, 6, 9]。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/2021/10/25/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84/sample2.png" style="zoom:50%;"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[3,4,5],[3,2,6],[2,2,1]]</span><br><span class="line">输出：4 </span><br><span class="line">解释：最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>0 &lt;= matrix[i][j] &lt;= 2^31 - 1</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>最朴素的方法为依次$dfs$每个点，找到从每个点开始的最长递增路径的最大值，然后求$max$。</p><p>记忆化$dfs$：由于朴素$dfs$会对同一路径进行大量重复操作，时间复杂度为指数级别。我们可以用$f[i][j]$记录从（i，j）出发可以得到的最长递增路径。下次$dfs$到这个坐标可以直接拿来用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// f[i][j]:从(i,j)出发可以获得的最长递增路径</span></span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记忆化搜索</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[x][y])&#123;</span><br><span class="line">            <span class="keyword">return</span> f[x][y];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最短为1</span></span><br><span class="line">        f[x][y]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> xx=x+dx[i];</span><br><span class="line">            <span class="keyword">int</span> yy=y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(xx&gt;=<span class="number">0</span>&amp;&amp;xx&lt;n&amp;&amp;yy&gt;=<span class="number">0</span>&amp;&amp;yy&lt;m&amp;&amp;matrix[xx][yy]&gt;matrix[x][y])&#123;</span><br><span class="line">                f[x][y]=<span class="built_in">max</span>(f[x][y],<span class="built_in">dfs</span>(matrix,xx,yy)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[x][y];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        n=matrix.<span class="built_in">size</span>();</span><br><span class="line">        m=matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,<span class="built_in">dfs</span>(matrix,i,j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(mn)$，$n$为矩阵的行数，$m$为矩阵的列数。在$dfs$中，时间复杂度为$O(V+E)$，$V$为结点数，$E$为边数$O(V)=O(mn)$，$O(E)\approx O(4mn)$，每个点上下左右四条边。</p><p>空间复杂度：$O(mn)$</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;剑指-Offer-II-112-最长递增路径&quot;&gt;&lt;a href=&quot;#剑指-Offer-II-112-最长递增路径&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer II 112. 最长递增路径&quot;&gt;&lt;/a&gt;剑指 Offer II 112. 最长递增路径&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/fpTFWP/&quot;&gt;https://leetcode-cn.com/problems/fpTFWP/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    
    <category term="记忆化搜索" scheme="https://benyang0506.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>大礼包</title>
    <link href="https://benyang0506.github.io/2021/10/25/%E5%A4%A7%E7%A4%BC%E5%8C%85/"/>
    <id>https://benyang0506.github.io/2021/10/25/%E5%A4%A7%E7%A4%BC%E5%8C%85/</id>
    <published>2021-10-25T04:46:11.000Z</published>
    <updated>2021-10-25T08:51:11.298Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="10-25-每日一题"><a href="#10-25-每日一题" class="headerlink" title="10.25 每日一题"></a>10.25 每日一题</h5><p>传送门：<a href="https://leetcode-cn.com/problems/shopping-offers/">https://leetcode-cn.com/problems/shopping-offers/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>在 LeetCode 商店中， 有 <code>n</code> 件在售的物品。每件物品都有对应的价格。然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。</p><p>给你一个整数数组 <code>price</code> 表示物品价格，其中 <code>price[i]</code> 是第 <code>i</code> 件物品的价格。另有一个整数数组 <code>needs</code> 表示购物清单，其中 <code>needs[i]</code> 是需要购买第 <code>i</code> 件物品的数量。</p><p>还有一个数组 <code>special</code> 表示大礼包，<code>special[i]</code> 的长度为 <code>n + 1</code> ，其中 <code>special[i][j]</code> 表示第 <code>i</code> 个大礼包中内含第 <code>j</code> 件物品的数量，且 <code>special[i][n]</code> （也就是数组中的最后一个整数）为第 <code>i</code> 个大礼包的价格。</p><p>返回 <strong>确切</strong> 满足购物清单所需花费的最低价格，你可以充分利用大礼包的优惠活动。你不能购买超出购物清单指定数量的物品，即使那样会降低整体价格。任意大礼包可无限次购买。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]</span><br><span class="line">输出：14</span><br><span class="line">解释：有 A 和 B 两种物品，价格分别为 ¥2 和 ¥5 。 </span><br><span class="line">大礼包 1 ，你可以以 ¥5 的价格购买 3A 和 0B 。 </span><br><span class="line">大礼包 2 ，你可以以 ¥10 的价格购买 1A 和 2B 。 </span><br><span class="line">需要购买 3 个 A 和 2 个 B ， 所以付 ¥10 购买 1A 和 2B（大礼包 2），以及 ¥4 购买 2A 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]</span><br><span class="line">输出：11</span><br><span class="line">解释：A ，B ，C 的价格分别为 ¥2 ，¥3 ，¥4 。</span><br><span class="line">可以用 ¥4 购买 1A 和 1B ，也可以用 ¥9 购买 2A ，2B 和 1C 。 </span><br><span class="line">需要买 1A ，2B 和 1C ，所以付 ¥4 买 1A 和 1B（大礼包 1），以及 ¥3 购买 1B ， ¥4 购买 1C 。 </span><br><span class="line">不可以购买超出待购清单的物品，尽管购买大礼包 2 更加便宜。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == price.length</code></li><li><code>n == needs.length</code></li><li><code>1 &lt;= n &lt;= 6</code></li><li><code>0 &lt;= price[i] &lt;= 10</code></li><li><code>0 &lt;= needs[i] &lt;= 10</code></li><li><code>1 &lt;= special.length &lt;= 100</code></li><li><code>special[i].length == n + 1</code></li><li><code>0 &lt;= special[i][j] &lt;= 50</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果不考虑大礼包的话需要花费的总价是固定的，所以在考虑大礼包的时候，如果发现选购某个大礼包会使花费的总价减少，就可以更新总价。</p><p>因为没有一种贪心策略，所以只能$dfs$搜索。用$needs$来记录还需要购买的物品集合，$_cache$来记录当前$needs$集合花费的钱的最小值。</p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 记录每一个need的最小价格</span></span><br><span class="line">    map&lt;vector&lt;<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; _cache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shoppingOffers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; special, vector&lt;<span class="keyword">int</span>&gt;&amp; needs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// needs：还需要购买的物品</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(needs,price,special);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; needs,vector&lt;<span class="keyword">int</span>&gt;&amp; price,vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; special)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 子问题计算过，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(_cache[needs])&#123;</span><br><span class="line">            <span class="keyword">return</span> _cache[needs];    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 直接买，不用礼包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;needs.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            ans+=needs[i]*price[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个礼包，依次尝试，看看有没有更便宜的价格</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;special.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; next=needs;</span><br><span class="line">            <span class="keyword">bool</span> valid=<span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 题目要求购买数量为needs，不能超过</span></span><br><span class="line">            <span class="comment">// 检查needs中每一件物品，都不能超过</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> item=<span class="number">0</span>;item&lt;price.<span class="built_in">size</span>();item++)&#123;</span><br><span class="line">                <span class="comment">// 会超过，不符合题意</span></span><br><span class="line">                <span class="keyword">if</span>(special[i][item]&gt;needs[item])&#123;</span><br><span class="line">                    valid=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!valid)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// next记录买过大礼包之后，每件物品还需要多少件</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> item=<span class="number">0</span>;item&lt;price.<span class="built_in">size</span>();item++)&#123;</span><br><span class="line">                next[item]-=special[i][item];</span><br><span class="line">            &#125;</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,<span class="built_in">dfs</span>(next,price,special)+special[i][price.<span class="built_in">size</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">        _cache[needs]=ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(knm^n)$，$k$表示大礼包数量，$n$表示需要多少种物品，$m$表示每种物品的需求量的可能数（0-最大需求量）即最大需求量+1。$needs$最多$m^n$种状态，对每个状态需要遍历所有大礼包，每个大礼包需要遍历所有物品。</p><p>空间复杂度：$O(nm^n)$，$needs$最多$m^n$种状态，每种状态需要存储$n$个物品。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;10-25-每日一题&quot;&gt;&lt;a href=&quot;#10-25-每日一题&quot; class=&quot;headerlink&quot; title=&quot;10.25 每日一题&quot;&gt;&lt;/a&gt;10.25 每日一题&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/shopping-offers/&quot;&gt;https://leetcode-cn.com/problems/shopping-offers/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="每日一题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="记忆化搜索" scheme="https://benyang0506.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>numpy练习</title>
    <link href="https://benyang0506.github.io/2021/10/15/numpy%E7%BB%83%E4%B9%A0/"/>
    <id>https://benyang0506.github.io/2021/10/15/numpy%E7%BB%83%E4%B9%A0/</id>
    <published>2021-10-15T14:38:41.000Z</published>
    <updated>2021-10-25T05:33:45.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="numpy-练习"><a href="#numpy-练习" class="headerlink" title="numpy 练习"></a>numpy 练习</h1><h3 id="numpy-的array操作"><a href="#numpy-的array操作" class="headerlink" title="numpy 的array操作"></a>numpy 的array操作</h3><h4 id="1-导入numpy库"><a href="#1-导入numpy库" class="headerlink" title="1.导入numpy库"></a>1.导入numpy库</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><h4 id="2-建立一个一维数组-a-初始化为-4-5-6-1-输出a-的类型（type）-2-输出a的各维度的大小（shape）-3-输出-a的第一个元素（值为4）"><a href="#2-建立一个一维数组-a-初始化为-4-5-6-1-输出a-的类型（type）-2-输出a的各维度的大小（shape）-3-输出-a的第一个元素（值为4）" class="headerlink" title="2.建立一个一维数组 a 初始化为[4,5,6], (1)输出a 的类型（type）(2)输出a的各维度的大小（shape）(3)输出 a的第一个元素（值为4）"></a>2.建立一个一维数组 a 初始化为[4,5,6], (1)输出a 的类型（type）(2)输出a的各维度的大小（shape）(3)输出 a的第一个元素（值为4）</h4><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=np.array([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><pre><code>&lt;class &#39;numpy.ndarray&#39;&gt;(3,)4</code></pre><h4 id="3-建立一个二维数组-b-初始化为-4-5-6-1-2-3-1-输出各维度的大小（shape）-2-输出-b-0-0-，b-0-1-b-1-1-这三个元素（对应值分别为4-5-2）"><a href="#3-建立一个二维数组-b-初始化为-4-5-6-1-2-3-1-输出各维度的大小（shape）-2-输出-b-0-0-，b-0-1-b-1-1-这三个元素（对应值分别为4-5-2）" class="headerlink" title="3.建立一个二维数组 b,初始化为 [ [4, 5, 6],[1, 2, 3]] (1)输出各维度的大小（shape）(2)输出 b(0,0)，b(0,1),b(1,1) 这三个元素（对应值分别为4,5,2）"></a>3.建立一个二维数组 b,初始化为 [ [4, 5, 6],[1, 2, 3]] (1)输出各维度的大小（shape）(2)输出 b(0,0)，b(0,1),b(1,1) 这三个元素（对应值分别为4,5,2）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b=np.array([[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]])</span><br><span class="line"><span class="built_in">print</span>(b.shape)</span><br><span class="line"><span class="built_in">print</span>(b.shape[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(b.shape[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(b[<span class="number">0</span>,<span class="number">0</span>],b[<span class="number">0</span>,<span class="number">1</span>],b[<span class="number">1</span>,<span class="number">1</span>])</span><br></pre></td></tr></table></figure><pre><code>(2, 3)234 5 2</code></pre><h4 id="4-1-建立一个全0矩阵-a-大小为-3x3-类型为整型（提示-dtype-int）-2-建立一个全1矩阵b-大小为4x5-3-建立一个单位矩阵c-大小为4x4-4-生成一个随机数矩阵d-大小为-3x2"><a href="#4-1-建立一个全0矩阵-a-大小为-3x3-类型为整型（提示-dtype-int）-2-建立一个全1矩阵b-大小为4x5-3-建立一个单位矩阵c-大小为4x4-4-生成一个随机数矩阵d-大小为-3x2" class="headerlink" title="4.  (1)建立一个全0矩阵 a, 大小为 3x3; 类型为整型（提示: dtype = int）(2)建立一个全1矩阵b,大小为4x5;  (3)建立一个单位矩阵c ,大小为4x4; (4)生成一个随机数矩阵d,大小为 3x2."></a>4.  (1)建立一个全0矩阵 a, 大小为 3x3; 类型为整型（提示: dtype = int）(2)建立一个全1矩阵b,大小为4x5;  (3)建立一个单位矩阵c ,大小为4x4; (4)生成一个随机数矩阵d,大小为 3x2.</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=np.zeros((<span class="number">3</span>,<span class="number">3</span>),dtype=<span class="built_in">int</span>)</span><br><span class="line">b=np.ones((<span class="number">4</span>,<span class="number">5</span>))</span><br><span class="line">c=np.eye(<span class="number">4</span>)</span><br><span class="line">d=np.random.randn(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a,b,c,d)</span><br></pre></td></tr></table></figure><pre><code>[[0 0 0] [0 0 0] [0 0 0]] [[1. 1. 1. 1. 1.] [1. 1. 1. 1. 1.] [1. 1. 1. 1. 1.] [1. 1. 1. 1. 1.]] [[1. 0. 0. 0.] [0. 1. 0. 0.] [0. 0. 1. 0.] [0. 0. 0. 1.]] [[ 0.7653732  -0.12668873] [-0.39446617  0.80114903] [-0.9335366  -1.18938761]]</code></pre><h4 id="5-建立一个数组-a-值为-1-2-3-4-5-6-7-8-9-10-11-12-1-打印a-2-输出-下标为-2-3-0-0-这两个数组元素的值"><a href="#5-建立一个数组-a-值为-1-2-3-4-5-6-7-8-9-10-11-12-1-打印a-2-输出-下标为-2-3-0-0-这两个数组元素的值" class="headerlink" title="5. 建立一个数组 a,(值为[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]] ) ,(1)打印a; (2)输出  下标为(2,3),(0,0) 这两个数组元素的值"></a>5. 建立一个数组 a,(值为[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]] ) ,(1)打印a; (2)输出  下标为(2,3),(0,0) 这两个数组元素的值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>,<span class="number">3</span>],a[<span class="number">0</span>,<span class="number">0</span>])</span><br></pre></td></tr></table></figure><pre><code>[[ 1  2  3  4] [ 5  6  7  8] [ 9 10 11 12]]12 1</code></pre><h4 id="6-把上一题的-a数组的-0到1行-2到3列，放到b里面去，（此处不需要从新建立a-直接调用即可）-1-输出b-2-输出b-的（0-0）这个元素的值"><a href="#6-把上一题的-a数组的-0到1行-2到3列，放到b里面去，（此处不需要从新建立a-直接调用即可）-1-输出b-2-输出b-的（0-0）这个元素的值" class="headerlink" title="6.把上一题的 a数组的 0到1行 2到3列，放到b里面去，（此处不需要从新建立a,直接调用即可）(1),输出b;(2) 输出b 的（0,0）这个元素的值"></a>6.把上一题的 a数组的 0到1行 2到3列，放到b里面去，（此处不需要从新建立a,直接调用即可）(1),输出b;(2) 输出b 的（0,0）这个元素的值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b=a[:<span class="number">2</span>,<span class="number">2</span>:<span class="number">4</span>]<span class="comment"># 从起点开始，不包括终点print(b)print(b[0,0])</span></span><br></pre></td></tr></table></figure><pre><code>[[3 4] [7 8]]3</code></pre><h4 id="7-把第5题中数组a的最后两行所有元素放到-c中，（提示：-a-1-2-）-1-输出-c-2-输出-c-中第一行的最后一个元素（提示，使用-1-表示最后一个元素）"><a href="#7-把第5题中数组a的最后两行所有元素放到-c中，（提示：-a-1-2-）-1-输出-c-2-输出-c-中第一行的最后一个元素（提示，使用-1-表示最后一个元素）" class="headerlink" title="7. 把第5题中数组a的最后两行所有元素放到 c中，（提示： a[1:2, :]）(1)输出 c ; (2) 输出 c 中第一行的最后一个元素（提示，使用 -1                 表示最后一个元素）"></a>7. 把第5题中数组a的最后两行所有元素放到 c中，（提示： a[1:2, :]）(1)输出 c ; (2) 输出 c 中第一行的最后一个元素（提示，使用 -1                 表示最后一个元素）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c=a[-<span class="number">2</span>:,:]<span class="built_in">print</span>(c)<span class="built_in">print</span>(c[<span class="number">0</span>,-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><pre><code>[[ 5  6  7  8] [ 9 10 11 12]]8</code></pre><h4 id="8-建立数组a-初始化a为-1-2-3-4-5-6-，输出-（0-0）（1-1）（2-0）这三个元素（提示：-使用-print-a-0-1-2-0-1-0-）"><a href="#8-建立数组a-初始化a为-1-2-3-4-5-6-，输出-（0-0）（1-1）（2-0）这三个元素（提示：-使用-print-a-0-1-2-0-1-0-）" class="headerlink" title="8.建立数组a,初始化a为[[1, 2], [3, 4], [5, 6]]，输出 （0,0）（1,1）（2,0）这三个元素（提示： 使用 print(a[[0, 1, 2], [0, 1, 0]]) ）"></a>8.建立数组a,初始化a为[[1, 2], [3, 4], [5, 6]]，输出 （0,0）（1,1）（2,0）这三个元素（提示： 使用 print(a[[0, 1, 2], [0, 1, 0]]) ）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]])<span class="built_in">print</span>(a)<span class="comment"># print(a[0,0],a[1,1],a[2,0])print(a[[0,1,2],[0,1,0]])</span></span><br></pre></td></tr></table></figure><pre><code>[[1 2] [3 4] [5 6]][1 4 5]</code></pre><h4 id="9-建立矩阵a-初始化为-1-2-3-4-5-6-7-8-9-10-11-12-，输出-0-0-1-2-2-0-3-1-提示使用-b-np-array-0-2-0-1-print-a-np-arange-4-b"><a href="#9-建立矩阵a-初始化为-1-2-3-4-5-6-7-8-9-10-11-12-，输出-0-0-1-2-2-0-3-1-提示使用-b-np-array-0-2-0-1-print-a-np-arange-4-b" class="headerlink" title="9.建立矩阵a ,初始化为[[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]，输出(0,0),(1,2),(2,0),(3,1) (提示使用 b = np.array([0, 2, 0, 1])                     print(a[np.arange(4), b]))"></a>9.建立矩阵a ,初始化为[[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]，输出(0,0),(1,2),(2,0),(3,1) (提示使用 b = np.array([0, 2, 0, 1])                     print(a[np.arange(4), b]))</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])<span class="built_in">print</span>(a)b=np.array([<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>])<span class="built_in">print</span>(a[np.arange(<span class="number">4</span>),b])</span><br></pre></td></tr></table></figure><pre><code>[[ 1  2  3] [ 4  5  6] [ 7  8  9] [10 11 12]][ 1  6  7 11]</code></pre><h4 id="10-对9-中输出的那四个元素，每个都加上10，然后重新输出矩阵a-提示：-a-np-arange-4-b-10-）"><a href="#10-对9-中输出的那四个元素，每个都加上10，然后重新输出矩阵a-提示：-a-np-arange-4-b-10-）" class="headerlink" title="10.对9 中输出的那四个元素，每个都加上10，然后重新输出矩阵a.(提示： a[np.arange(4), b] += 10 ）"></a>10.对9 中输出的那四个元素，每个都加上10，然后重新输出矩阵a.(提示： a[np.arange(4), b] += 10 ）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a)a[np.arange(<span class="number">4</span>),np.array([<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>])]+=10<span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><pre><code>[[ 1  2  3] [ 4  5  6] [ 7  8  9] [10 11 12]][[11  2  3] [ 4  5 16] [17  8  9] [10 21 12]]</code></pre><h3 id="array-的数学运算"><a href="#array-的数学运算" class="headerlink" title="array 的数学运算"></a>array 的数学运算</h3><h4 id="11-执行-x-np-array-1-2-，然后输出-x-的数据类型"><a href="#11-执行-x-np-array-1-2-，然后输出-x-的数据类型" class="headerlink" title="11.  执行 x = np.array([1, 2])，然后输出 x 的数据类型"></a>11.  执行 x = np.array([1, 2])，然后输出 x 的数据类型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=np.array([<span class="number">1</span>,<span class="number">2</span>])<span class="built_in">print</span>(x)<span class="built_in">print</span>(x.dtype)</span><br></pre></td></tr></table></figure><pre><code>[1 2]int32</code></pre><h4 id="12-执行-x-np-array-1-0-2-0-，然后输出-x-的数据类类型"><a href="#12-执行-x-np-array-1-0-2-0-，然后输出-x-的数据类类型" class="headerlink" title="12.执行 x = np.array([1.0, 2.0]) ，然后输出 x 的数据类类型"></a>12.执行 x = np.array([1.0, 2.0]) ，然后输出 x 的数据类类型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=np.array([<span class="number">1.0</span>,<span class="number">2.0</span>])<span class="built_in">print</span>(x.dtype)</span><br></pre></td></tr></table></figure><pre><code>float64</code></pre><h4 id="13-执行-x-np-array-1-2-3-4-dtype-np-float64-，y-np-array-5-6-7-8-dtype-np-float64-，然后输出-x-y-和-np-add-x-y"><a href="#13-执行-x-np-array-1-2-3-4-dtype-np-float64-，y-np-array-5-6-7-8-dtype-np-float64-，然后输出-x-y-和-np-add-x-y" class="headerlink" title="13.执行 x = np.array([[1, 2], [3, 4]], dtype=np.float64) ，y = np.array([[5, 6], [7, 8]], dtype=np.float64)，然后输出 x+y ,和 np.add(x,y)"></a>13.执行 x = np.array([[1, 2], [3, 4]], dtype=np.float64) ，y = np.array([[5, 6], [7, 8]], dtype=np.float64)，然后输出 x+y ,和 np.add(x,y)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]],dtype=np.float64)y=np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]],dtype=np.float64)<span class="built_in">print</span>(x+y)<span class="built_in">print</span>(np.add(x,y))</span><br></pre></td></tr></table></figure><pre><code>[[ 6.  8.] [10. 12.]][[ 6.  8.] [10. 12.]]</code></pre><h4 id="14-利用-13题目中的x-y-输出-x-y-和-np-subtract-x-y"><a href="#14-利用-13题目中的x-y-输出-x-y-和-np-subtract-x-y" class="headerlink" title="14. 利用 13题目中的x,y 输出 x-y 和 np.subtract(x,y)"></a>14. 利用 13题目中的x,y 输出 x-y 和 np.subtract(x,y)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(x-y)<span class="built_in">print</span>(np.subtract(x,y))</span><br></pre></td></tr></table></figure><pre><code>[[-4. -4.] [-4. -4.]][[-4. -4.] [-4. -4.]]</code></pre><h4 id="15-利用13题目中的x，y-输出-x-y-和-np-multiply-x-y-还有-np-dot-x-y-比较差异。然后自己换一个不是方阵的试试。"><a href="#15-利用13题目中的x，y-输出-x-y-和-np-multiply-x-y-还有-np-dot-x-y-比较差异。然后自己换一个不是方阵的试试。" class="headerlink" title="15. 利用13题目中的x，y 输出 x*y ,和 np.multiply(x, y) 还有  np.dot(x,y),比较差异。然后自己换一个不是方阵的试试。"></a>15. 利用13题目中的x，y 输出 x*y ,和 np.multiply(x, y) 还有  np.dot(x,y),比较差异。然后自己换一个不是方阵的试试。</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(x)<span class="built_in">print</span>(y)<span class="built_in">print</span>(x*y) <span class="comment">#对应元素相乘print(np.multiply(x,y)) #对应元素相乘print(np.dot(x,y)) #矩阵乘法</span></span><br></pre></td></tr></table></figure><pre><code>[[1. 2.] [3. 4.]][[5. 6.] [7. 8.]][[ 5. 12.] [21. 32.]][[ 5. 12.] [21. 32.]][[19. 22.] [43. 50.]]</code></pre><h4 id="16-利用13题目中的x-y-输出-x-y-提示-：-使用函数-np-divide"><a href="#16-利用13题目中的x-y-输出-x-y-提示-：-使用函数-np-divide" class="headerlink" title="16. 利用13题目中的x,y,输出 x / y .(提示 ： 使用函数 np.divide())"></a>16. 利用13题目中的x,y,输出 x / y .(提示 ： 使用函数 np.divide())</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(x/y)<span class="built_in">print</span>(np.divide(x,y))</span><br></pre></td></tr></table></figure><pre><code>[[0.2        0.33333333] [0.42857143 0.5       ]][[0.2        0.33333333] [0.42857143 0.5       ]]</code></pre><h4 id="17-利用13题目中的x-输出-x的-开方。-提示：-使用函数-np-sqrt"><a href="#17-利用13题目中的x-输出-x的-开方。-提示：-使用函数-np-sqrt" class="headerlink" title="17. 利用13题目中的x,输出 x的 开方。(提示： 使用函数 np.sqrt() )"></a>17. 利用13题目中的x,输出 x的 开方。(提示： 使用函数 np.sqrt() )</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.sqrt(x))<span class="built_in">print</span>(x**<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><pre><code>[[1.         1.41421356] [1.73205081 2.        ]][[1.         1.41421356] [1.73205081 2.        ]]</code></pre><h4 id="18-利用13题目中的x-y-执行-print-x-dot-y-和-print-np-dot-x-y"><a href="#18-利用13题目中的x-y-执行-print-x-dot-y-和-print-np-dot-x-y" class="headerlink" title="18.利用13题目中的x,y ,执行 print(x.dot(y)) 和 print(np.dot(x,y))"></a>18.利用13题目中的x,y ,执行 print(x.dot(y)) 和 print(np.dot(x,y))</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(x.dot(y))<span class="built_in">print</span>(np.dot(x,y))</span><br></pre></td></tr></table></figure><pre><code>[[19. 22.] [43. 50.]][[19. 22.] [43. 50.]]</code></pre><h5 id="19-利用13题目中的-x-进行求和。提示：输出三种求和-1-print-np-sum-x-2-print-np-sum-x，axis-0-3-print-np-sum-x-axis-1"><a href="#19-利用13题目中的-x-进行求和。提示：输出三种求和-1-print-np-sum-x-2-print-np-sum-x，axis-0-3-print-np-sum-x-axis-1" class="headerlink" title="19.利用13题目中的 x,进行求和。提示：输出三种求和 (1)print(np.sum(x)):   (2)print(np.sum(x，axis =0 ));   (3)print(np.sum(x,axis = 1))"></a>19.利用13题目中的 x,进行求和。提示：输出三种求和 (1)print(np.sum(x)):   (2)print(np.sum(x，axis =0 ));   (3)print(np.sum(x,axis = 1))</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(x)<span class="built_in">print</span>(np.<span class="built_in">sum</span>(x)) <span class="comment"># 所有元素和print(np.sum(x,axis=0))  # 把行压缩掉print(np.sum(x,axis=1))  # 把列压缩掉</span></span><br></pre></td></tr></table></figure><pre><code>[[1. 2.] [3. 4.]]10.0[4. 6.][3. 7.]</code></pre><h4 id="20-利用13题目中的-x-进行求平均数（提示：输出三种平均数-1-print-np-mean-x-2-print-np-mean-x-axis-0-3-print-np-mean-x-axis-1-）"><a href="#20-利用13题目中的-x-进行求平均数（提示：输出三种平均数-1-print-np-mean-x-2-print-np-mean-x-axis-0-3-print-np-mean-x-axis-1-）" class="headerlink" title="20.利用13题目中的 x,进行求平均数（提示：输出三种平均数(1)print(np.mean(x)) (2)print(np.mean(x,axis = 0))(3) print(np.mean(x,axis =1))）"></a>20.利用13题目中的 x,进行求平均数（提示：输出三种平均数(1)print(np.mean(x)) (2)print(np.mean(x,axis = 0))(3) print(np.mean(x,axis =1))）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.mean(x))<span class="built_in">print</span>(np.mean(x,axis=<span class="number">0</span>))<span class="built_in">print</span>(np.mean(x,axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><pre><code>2.5[2. 3.][1.5 3.5]</code></pre><h4 id="21-利用13题目中的x，对x-进行矩阵转置，然后输出转置后的结果，（提示：-x-T-表示对-x-的转置）"><a href="#21-利用13题目中的x，对x-进行矩阵转置，然后输出转置后的结果，（提示：-x-T-表示对-x-的转置）" class="headerlink" title="21.利用13题目中的x，对x 进行矩阵转置，然后输出转置后的结果，（提示： x.T 表示对 x 的转置）"></a>21.利用13题目中的x，对x 进行矩阵转置，然后输出转置后的结果，（提示： x.T 表示对 x 的转置）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(x)<span class="built_in">print</span>(x.T)</span><br></pre></td></tr></table></figure><pre><code>[[1. 2.] [3. 4.]][[1. 3.] [2. 4.]]</code></pre><h4 id="22-利用13题目中的x-求e的指数（提示：-函数-np-exp-）"><a href="#22-利用13题目中的x-求e的指数（提示：-函数-np-exp-）" class="headerlink" title="22.利用13题目中的x,求e的指数（提示： 函数 np.exp()）"></a>22.利用13题目中的x,求e的指数（提示： 函数 np.exp()）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.exp(x))</span><br></pre></td></tr></table></figure><pre><code>[[ 2.71828183  7.3890561 ] [20.08553692 54.59815003]]</code></pre><h4 id="23-利用13题目中的-x-求值最大的下标（提示-1-print-np-argmax-x-2-print-np-argmax-x-axis-0-3-print-np-argmax-x-axis-1"><a href="#23-利用13题目中的-x-求值最大的下标（提示-1-print-np-argmax-x-2-print-np-argmax-x-axis-0-3-print-np-argmax-x-axis-1" class="headerlink" title="23.利用13题目中的 x,求值最大的下标（提示(1)print(np.argmax(x)) ,(2) print(np.argmax(x, axis =0))(3)print(np.argmax(x),axis =1))"></a>23.利用13题目中的 x,求值最大的下标（提示(1)print(np.argmax(x)) ,(2) print(np.argmax(x, axis =0))(3)print(np.argmax(x),axis =1))</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(x)<span class="built_in">print</span>(np.argmax(x)) <span class="comment"># 看成一维之后的最大索引值？print(np.argmax(x,axis=0)) # 每一列的最大索引值print(np.argmax(x,axis=1)) # 每一行的最大索引值</span></span><br></pre></td></tr></table></figure><pre><code>[[1. 2.] [3. 4.]]3[1 1][1 1]</code></pre><h4 id="24-画图，y-x-x-其中-x-np-arange-0-100-0-1-（提示这里用到-matplotlib-pyplot-库）"><a href="#24-画图，y-x-x-其中-x-np-arange-0-100-0-1-（提示这里用到-matplotlib-pyplot-库）" class="headerlink" title="24,画图，y=x*x 其中 x = np.arange(0, 100, 0.1) （提示这里用到  matplotlib.pyplot 库）"></a>24,画图，y=x*x 其中 x = np.arange(0, 100, 0.1) （提示这里用到  matplotlib.pyplot 库）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=np.arange(<span class="number">0</span>,<span class="number">100</span>,<span class="number">0.1</span>)plt.plot(x,x*x)plt.show()</span><br></pre></td></tr></table></figure><p>​    <img src="/2021/10/15/numpy%E7%BB%83%E4%B9%A0/output_51_0.png" alt><br>​    </p><h4 id="25-画图。画正弦函数和余弦函数，-x-np-arange-0-3-np-pi-0-1-提示：这里用到-np-sin-np-cos-函数和-matplotlib-pyplot-库"><a href="#25-画图。画正弦函数和余弦函数，-x-np-arange-0-3-np-pi-0-1-提示：这里用到-np-sin-np-cos-函数和-matplotlib-pyplot-库" class="headerlink" title="25.画图。画正弦函数和余弦函数， x = np.arange(0, 3 * np.pi, 0.1)(提示：这里用到 np.sin() np.cos() 函数和 matplotlib.pyplot 库)"></a>25.画图。画正弦函数和余弦函数， x = np.arange(0, 3 * np.pi, 0.1)(提示：这里用到 np.sin() np.cos() 函数和 matplotlib.pyplot 库)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=np.arange(<span class="number">0</span>,<span class="number">3</span>*np.pi,<span class="number">0.1</span>)plt.plot(x,np.sin(x))plt.plot(x,np.cos(x))plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2021/10/15/numpy%E7%BB%83%E4%B9%A0/output_53_0.png" alt></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;numpy-练习&quot;&gt;&lt;a href=&quot;#numpy-练习&quot; class=&quot;headerlink&quot; title=&quot;numpy 练习&quot;&gt;&lt;/a&gt;numpy 练习&lt;/h1&gt;&lt;h3 id=&quot;numpy-的array操作&quot;&gt;&lt;a href=&quot;#numpy-的array操作&quot; class=&quot;headerlink&quot; title=&quot;numpy 的array操作&quot;&gt;&lt;/a&gt;numpy 的array操作&lt;/h3&gt;&lt;h4 id=&quot;1-导入numpy库&quot;&gt;&lt;a href=&quot;#1-导入numpy库&quot; class=&quot;headerlink&quot; title=&quot;1.导入numpy库&quot;&gt;&lt;/a&gt;1.导入numpy库&lt;/h4&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; plt&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;2-建立一个一维数组-a-初始化为-4-5-6-1-输出a-的类型（type）-2-输出a的各维度的大小（shape）-3-输出-a的第一个元素（值为4）&quot;&gt;&lt;a href=&quot;#2-建立一个一维数组-a-初始化为-4-5-6-1-输出a-的类型（type）-2-输出a的各维度的大小（shape）-3-输出-a的第一个元素（值为4）&quot; class=&quot;headerlink&quot; title=&quot;2.建立一个一维数组 a 初始化为[4,5,6], (1)输出a 的类型（type）(2)输出a的各维度的大小（shape）(3)输出 a的第一个元素（值为4）&quot;&gt;&lt;/a&gt;2.建立一个一维数组 a 初始化为[4,5,6], (1)输出a 的类型（type）(2)输出a的各维度的大小（shape）(3)输出 a的第一个元素（值为4）&lt;/h4&gt;</summary>
    
    
    
    <category term="蒲公英书编程练习" scheme="https://benyang0506.github.io/categories/%E8%92%B2%E5%85%AC%E8%8B%B1%E4%B9%A6%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/"/>
    
    <category term="numpy练习" scheme="https://benyang0506.github.io/categories/%E8%92%B2%E5%85%AC%E8%8B%B1%E4%B9%A6%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/numpy%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="numpy" scheme="https://benyang0506.github.io/tags/numpy/"/>
    
  </entry>
  
  <entry>
    <title>离散化</title>
    <link href="https://benyang0506.github.io/2021/10/14/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    <id>https://benyang0506.github.io/2021/10/14/%E7%A6%BB%E6%95%A3%E5%8C%96/</id>
    <published>2021-10-14T05:41:41.000Z</published>
    <updated>2021-10-14T05:54:57.558Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h5><p>传送门：<a href="https://www.acwing.com/problem/content/804/">https://www.acwing.com/problem/content/804/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>假定有一个无限长的数轴，数轴上每个坐标上的数都是 00。</p><p>现在，我们首先进行 nn 次操作，每次操作将某一位置 xx 上的数加 cc。</p><p>接下来，进行 mm 次询问，每个询问包含两个整数 ll 和 rr，你需要求出在区间 [l,r][l,r] 之间的所有数的和。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 nn 和 mm。</p><p>接下来 nn 行，每行包含两个整数 xx 和 cc。</p><p>再接下来 mm 行，每行包含两个整数 ll 和 rr。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 mm 行，每行输出一个询问中所求的区间内数字和。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$-1e9≤x≤1e9$</p><p>$1≤n,m≤1e5$</p><p>$-1e9≤l≤r≤1e9$</p><p>$−10000≤c≤10000$</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">3 6</span><br><span class="line">7 5</span><br><span class="line">1 3</span><br><span class="line">4 6</span><br><span class="line">7 8</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">0</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>离散化基础模板题</p><p>$x$的范围非常大，数组开不出来，但是实际用到的点不多，可以将这些用到的点映射到较小的数组中（保序），就是离散化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PIR;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有坐标的点的个数，add最大1e5个点，query最多1e5次，每次两个点</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">300000</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有坐标的点的个数</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; alls;</span><br><span class="line"></span><br><span class="line">vector&lt;PIR&gt; query;</span><br><span class="line">vector&lt;PIR&gt; add;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 离散化后的原数组</span></span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="comment">// 离散化后的前缀和数组</span></span><br><span class="line"><span class="keyword">int</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分找映射后的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=alls.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(alls[mid]&gt;=x)&#123;</span><br><span class="line">            r=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使离散化后的原数组从1开始，方便求前缀和</span></span><br><span class="line">    <span class="keyword">return</span> l+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,c;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;c;</span><br><span class="line">        add.<span class="built_in">push_back</span>(&#123;x,c&#125;);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        query.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(l);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//保序离散化+去重</span></span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>());</span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>()),alls.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// add</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;add.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=add[i].first;</span><br><span class="line">        <span class="keyword">int</span> c=add[i].second;</span><br><span class="line">        a[<span class="built_in">find</span>(x)]+=c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 预处理前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=alls.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// query</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;query.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l=query[i].first;</span><br><span class="line">        <span class="keyword">int</span> r=query[i].second;</span><br><span class="line">        cout&lt;&lt;s[<span class="built_in">find</span>(r)]-s[<span class="built_in">find</span>(l)<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;区间和&quot;&gt;&lt;a href=&quot;#区间和&quot; class=&quot;headerlink&quot; title=&quot;区间和&quot;&gt;&lt;/a&gt;区间和&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://www.acwing.com/problem/content/804/&quot;&gt;https://www.acwing.com/problem/content/804/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="模板题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%A8%A1%E6%9D%BF%E9%A2%98/"/>
    
    
    <category term="离散化" scheme="https://benyang0506.github.io/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="https://benyang0506.github.io/2021/10/14/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>https://benyang0506.github.io/2021/10/14/%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2021-10-14T03:47:38.000Z</published>
    <updated>2021-10-14T05:49:34.258Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="连通块中点的数量"><a href="#连通块中点的数量" class="headerlink" title="连通块中点的数量"></a>连通块中点的数量</h5><p>传送门：<a href="https://www.acwing.com/problem/content/839/">https://www.acwing.com/problem/content/839/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给定一个包含 nn 个点（编号为 1∼n1∼n）的无向图，初始时图中没有边。</p><p>现在要进行 mm 个操作，操作共有三种：</p><ol><li><code>C a b</code>，在点 aa 和点 bb 之间连一条边，aa 和 bb 可能相等；</li><li><code>Q1 a b</code>，询问点 aa 和点 bb 是否在同一个连通块中，aa 和 bb 可能相等；</li><li><code>Q2 a</code>，询问点 aa 所在连通块中点的数量；</li></ol><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入整数 nn 和 mm。</p><p>接下来 mm 行，每行包含一个操作指令，指令为 <code>C a b</code>，<code>Q1 a b</code> 或 <code>Q2 a</code> 中的一种。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个询问指令 <code>Q1 a b</code>，如果 aa 和 bb 在同一个连通块中，则输出 <code>Yes</code>，否则输出 <code>No</code>。</p><p>对于每个询问指令 <code>Q2 a</code>，输出一个整数表示点 aa 所在连通块中点的数量</p><p>每个结果占一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1≤n,m≤1e5</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 5</span><br><span class="line">C 1 2</span><br><span class="line">Q1 1 2</span><br><span class="line">Q2 1</span><br><span class="line">C 2 5</span><br><span class="line">Q2 5</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>并查集基础模板题</p><p>$cnt[N]$：记录每个集合中元素个数</p><p>$p[N]$：存当前节点父结点，路径压缩后存根结点</p><p>合并集合时先合并数量，再连边。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p[i]：节点i的根节点</span></span><br><span class="line"><span class="comment">// p[i]=i，i为根节点</span></span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="comment">// 记录每个集合中的元素个数</span></span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找x的根节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果x不是根节点</span></span><br><span class="line">    <span class="keyword">if</span>(x!=p[x]) </span><br><span class="line">        <span class="comment">// 将p[x]设置为根节点</span></span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="comment">// 返回根节点</span></span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">// 每个点都是根节点，各自为一个集合</span></span><br><span class="line">        p[i]=i;</span><br><span class="line">        <span class="comment">// 每个集合一开始只有1个点（自己）</span></span><br><span class="line">        cnt[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">&quot;Q2&quot;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            cout&lt;&lt;cnt[<span class="built_in">find</span>(x)]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">&quot;Q1&quot;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x)==<span class="built_in">find</span>(y))&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// x与y不能再同一个集合</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x)!=<span class="built_in">find</span>(y))&#123;</span><br><span class="line">                <span class="comment">// 先更新cnt</span></span><br><span class="line">                cnt[<span class="built_in">find</span>(y)]+=cnt[<span class="built_in">find</span>(x)];</span><br><span class="line">                <span class="comment">// 将根节点连起来</span></span><br><span class="line">                p[<span class="built_in">find</span>(x)]=<span class="built_in">find</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$find()$时间复杂度可以看成$O(1)$。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;连通块中点的数量&quot;&gt;&lt;a href=&quot;#连通块中点的数量&quot; class=&quot;headerlink&quot; title=&quot;连通块中点的数量&quot;&gt;&lt;/a&gt;连通块中点的数量&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://www.acwing.com/problem/content/839/&quot;&gt;https://www.acwing.com/problem/content/839/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="模板题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%A8%A1%E6%9D%BF%E9%A2%98/"/>
    
    
    <category term="并查集" scheme="https://benyang0506.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>linux基本操作</title>
    <link href="https://benyang0506.github.io/2021/09/29/linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>https://benyang0506.github.io/2021/09/29/linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</id>
    <published>2021-09-29T12:52:11.000Z</published>
    <updated>2021-10-26T11:55:08.047Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux基本操作"><a href="#Linux基本操作" class="headerlink" title="Linux基本操作"></a>Linux基本操作</h2><h5 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h5><p>列出目标目录中所有子目录和文件的信息</p><p>命令语法：ls [选项] [目录或文件名]</p><span id="more"></span><p>命令示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -a</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /etc</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>-a：—all的缩写，显示所有的文件，包括隐藏文件(以.开头的文件)</li><li>-l：列出长数据串，显示出文件的属性与权限等数据信息</li></ul><h5 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h5><p>显示当前工作目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure><h5 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h5><p>切换当前工作目录至目标目录</p><p>命令语法：cd [dirName]</p><p>命令示例：切换至/etc/目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /etc</span><br></pre></td></tr></table></figure><p>参数dirName常用解释：</p><ul><li>绝对路径：从根目录开始,依次将各级子目录的名字组合起来，路径的写法一定是由根目录 / 写起，例如 /usr/local/ ”</li><li>相对路径：相对当前所在路径的位置，路径的写法不是由根目录“ / ”写起，例如“ work/test ”</li><li>. ：”.” 表示目前所在的目录</li><li>.. : “..” 表示目前目录位置的上一层目录</li><li>～：表示当前用户的home目录，也就是刚 login 时所在的目录</li></ul><p>命令示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd sbin/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd .</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br></pre></td></tr></table></figure><h5 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h5><p>拷贝文件或目录</p><p>命令语法：cp [options] source dest</p><p>命令示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r abc cba</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/inittab ./</span><br></pre></td></tr></table></figure><p>常用参数</p><ul><li>-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。</li></ul><h5 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h5><p>创建目录</p><p>命令语法：mkdir [参数][目录名称]</p><p>命令示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir work</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir work/test</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p abc/test</span><br></pre></td></tr></table></figure><ul><li>-p：如果目录路径中的某级目录不存在，则自动创建</li></ul><h5 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h5><p>删除文件或目录</p><p>命令语法：mkdir [参数][目录名称]</p><p>命令示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm inittab</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -r abc</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf cba</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>-r：删除目录用的选项,使用命令rm删除目录时，一定要加-r选项</li><li>-f：表示强制删除</li></ul><p>注意：rm -rf命令非常危险，使用时一定要确保命令正确，路径不要以/开头。</p><p>如果不小心执行了“ rm -rf / ”，后果很严重，哭都来不及了</p><h5 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h5><p>将文件输出到标准输出</p><p>命令语法：cat [选项] [文件]</p><p>命令示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat inittab</span><br></pre></td></tr></table></figure><h5 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h5><p>移动文件或目录</p><p>命令语法：mv [选项] source dest</p><p>命令示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv inittab abc/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv work/ abc/</span><br></pre></td></tr></table></figure><h5 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h5><p>修改文件或目录的权限</p><p>命令语法：chmod [选项] [文件]</p><ul><li>上图中红色圈中的“rwx r-x r-x”，r代表读、w代表写、x代表执行、-代表没有权限。</li><li>第一个root代表该文件的所有者是root用户</li><li>第二个root代表该文件所属群组为root群组</li><li>rwx代表该文件所有者有读写执行权限</li><li>第一个r-x代表所在组的用户对该文件有读和执行的权限，没有写的权限</li><li>第二个r-x代表其他用户对该文件有读和执行的权限，没有写的权限</li></ul><p>解释说明：</p><ul><li>文件或目录权限控制分为读取(r)、写入(w)、执行(x)3种</li><li>具有全部权限的二进制可理解为 “111” 即 十进制的 “7”</li><li>只有读写权限二进制可理解为 “100” 即 十进制的 “4”</li></ul><p>命令示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 abc</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a-x abc</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x abc</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 755 abc</span><br></pre></td></tr></table></figure><p>常用参数解释：</p><ul><li>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是</li><li>+ 表示增加权限、- 表示取消权限</li><li>r 表示可读取，w 表示可写入，x 表示可执行</li><li>-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)</li></ul><h5 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h5><p>打包压缩或解压</p><p>命令语法：tar [选项] [文件…]</p><p>命令示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf abc.tar.gz abc/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf abc.tar.gz</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Linux基本操作&quot;&gt;&lt;a href=&quot;#Linux基本操作&quot; class=&quot;headerlink&quot; title=&quot;Linux基本操作&quot;&gt;&lt;/a&gt;Linux基本操作&lt;/h2&gt;&lt;h5 id=&quot;ls命令&quot;&gt;&lt;a href=&quot;#ls命令&quot; class=&quot;headerlink&quot; title=&quot;ls命令&quot;&gt;&lt;/a&gt;ls命令&lt;/h5&gt;&lt;p&gt;列出目标目录中所有子目录和文件的信息&lt;/p&gt;
&lt;p&gt;命令语法：ls [选项] [目录或文件名]&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://benyang0506.github.io/categories/Linux/"/>
    
    
    <category term="linux" scheme="https://benyang0506.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>寻找重复数</title>
    <link href="https://benyang0506.github.io/2021/09/16/%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/"/>
    <id>https://benyang0506.github.io/2021/09/16/%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/</id>
    <published>2021-09-16T02:00:56.000Z</published>
    <updated>2021-09-16T08:27:56.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><p>传送门：<a href="&lt;https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">&lt;https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a>&gt;</p><p><a href="http://10.129.27.27/contest/9/problem/1002">http://10.129.27.27/contest/9/problem/1002</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p><p>要求算法空间复杂度为 O(1) (不包括输入数组).</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>输入包含两行, 第一行为一个正整数 n, 第二行为 n + 1 个正整数.</p><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>输出为单独一行, 即所有给出的数中重复的数.</p><h5 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 3 4 2 2</span><br></pre></td></tr></table></figure><h5 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h5 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">3 1 3 4 2</span><br></pre></td></tr></table></figure><h5 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="方法一：二分"><a href="#方法一：二分" class="headerlink" title="方法一：二分"></a>方法一：二分</h4><p>我们用$cnt[i]$来记录原数组中小于等于$i$的个数，假设重复的数为$ans$，则<code>1&lt;i&lt;ans</code>时，<code>cnt[i]&lt;=i</code>，<code>ans&lt;=i&lt;=n</code>时，<code>cnt[i]&gt;i</code>；</p><p>已知答案一定在1到$n$之间，二分的思路是每次猜一个数$mid$，然后统计原数组中小于等于$mid$的个数$cnt$，利用上述性质进行二分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 二分</span></span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&lt;=mid)&#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 符合条件</span></span><br><span class="line">            <span class="keyword">if</span>(cnt&gt;mid)&#123;</span><br><span class="line">                r=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(nlgn)$，空间复杂度$O(1)$。</p><h4 id="方法二：位运算"><a href="#方法二：位运算" class="headerlink" title="方法二：位运算"></a>方法二：位运算</h4><p>我们定义数组$v1$，$v1[i]$记录数字1~n的二进制表示中，第$i$位为1的数量；</p><p>接着定义数组$v2$，$v2[i]$记录$nums$数组中所有数的二进制表示中，第$i$位为1的数量。</p><p>因为重复的数会多次出现，所以存在$i$，有$v1[i]&gt;v2[i]$，所有这些$i$的二进制表示组成的和即为重复的数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// 最大位数</span></span><br><span class="line">        <span class="keyword">int</span> bit_Max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(t)&#123;</span><br><span class="line">            t&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            bit_Max++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bit_Max;i++)&#123;</span><br><span class="line">            v1.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">            v2.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bit_Max;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((j&gt;&gt;i)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                    v1[i]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bit_Max;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((nums[j])&gt;&gt;i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                    v2[i]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bit_Max;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v2[i]&gt;v1[i])&#123;</span><br><span class="line">                ans=ans+(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(nlgn)$，空间复杂度$O(1)$。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;p&gt;传送门：&lt;a href=&quot;&amp;lt;https://leetcode-cn.com/problems/intersection-of-two-linked-lists/&quot;&gt;&amp;lt;https://leetcode-cn.com/problems/intersection-of-two-linked-lists/&lt;/a&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://10.129.27.27/contest/9/problem/1002&quot;&gt;http://10.129.27.27/contest/9/problem/1002&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="课堂作业" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E8%AF%BE%E5%A0%82%E4%BD%9C%E4%B8%9A/"/>
    
    
    <category term="双指针" scheme="https://benyang0506.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="位运算" scheme="https://benyang0506.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="二分" scheme="https://benyang0506.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>大餐计数</title>
    <link href="https://benyang0506.github.io/2021/07/08/%E5%A4%A7%E9%A4%90%E8%AE%A1%E6%95%B0/"/>
    <id>https://benyang0506.github.io/2021/07/08/%E5%A4%A7%E9%A4%90%E8%AE%A1%E6%95%B0/</id>
    <published>2021-07-08T07:33:26.000Z</published>
    <updated>2021-07-08T09:04:30.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><p>7.7 每日一题</p><p>传送门：<a href="https://leetcode-cn.com/problems/count-good-meals/">https://leetcode-cn.com/problems/count-good-meals/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p><strong>大餐</strong> 是指 <strong>恰好包含两道不同餐品</strong> 的一餐，其美味程度之和等于 2 的幂。</p><p>你可以搭配 <strong>任意</strong> 两道餐品做一顿大餐。</p><p>给你一个整数数组 <code>deliciousness</code> ，其中 <code>deliciousness[i]</code> 是第 <code>i</code> 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 <strong>大餐</strong> 的数量。结果需要对 <code>1e9 + 7</code> 取余。</p><p>注意，只要餐品下标不同，就可以认为是不同的餐品，即便它们的美味程度相同。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：deliciousness = [1,3,5,7,9]</span><br><span class="line">输出：4</span><br><span class="line">解释：大餐的美味程度组合为 (1,3) 、(1,7) 、(3,5) 和 (7,9) 。</span><br><span class="line">它们各自的美味程度之和分别为 4 、8 、8 和 16 ，都是 2 的幂。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：deliciousness = [1,1,1,3,3,3,7]</span><br><span class="line">输出：15</span><br><span class="line">解释：大餐的美味程度组合为 3 种 (1,1) ，9 种 (1,3) ，和 3 种 (1,7) 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= deliciousness.length &lt;= 1e5</span><br><span class="line">0 &lt;= deliciousness[i] &lt;= 2的20次方</span><br></pre></td></tr></table></figure><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>朴素做法，两层循环枚举两个点，判断和是否为2的幂。</p><h6 id="优化：判断是否为2的幂，有五种方法。"><a href="#优化：判断是否为2的幂，有五种方法。" class="headerlink" title="优化：判断是否为2的幂，有五种方法。"></a>优化：判断是否为2的幂，有五种方法。</h6><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><p>求出第一个大于等于$x$的2的幂，然后判断是否等于。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(k&lt;x)&#123;</span><br><span class="line">k*=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> k==x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(logx)$。</p><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>思路同方法一，但求第一个大于等于$x$的2的幂时通过位运算实现。</p><p>举个栗子，$x=65$，$x-1=64$，二进制表示为$10000000$</p><p>$x|=x&gt;&gt;1$，$x=10000000|01000000=11000000$</p><p>$x|=x&gt;&gt;2$，$x=11000000|00110000=11110000$</p><p>$x|=x&gt;&gt;4$，$x=11110000|00001111=11111111$</p><p>之后$x$无改变，二进制表示每一位均变为$1$，$+1$为$128$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t=x;</span><br><span class="line">x-=<span class="number">1</span>;</span><br><span class="line">x|=x&gt;&gt;<span class="number">1</span>;</span><br><span class="line">x|=x&gt;&gt;<span class="number">2</span>;</span><br><span class="line">x|=x&gt;&gt;<span class="number">4</span>;</span><br><span class="line">x|=x&gt;&gt;<span class="number">8</span>;</span><br><span class="line">x|=x&gt;&gt;<span class="number">16</span>;</span><br><span class="line">x=x&lt;<span class="number">0</span>?<span class="number">1</span>:x+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> x==t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(1)$。</p><h5 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h5><p>为$0$时需要特判</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> (x&amp;(x<span class="number">-1</span>))==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(1)$。</p><h5 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h5><p>为$0$时需要特判</p><p>$ps$：$’==’$优先级比’&amp;’高，所以要加$’()’$，不然结果会出错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> (x&amp;-x)==x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(1)$。</p><h5 id="方法五"><a href="#方法五" class="headerlink" title="方法五"></a>方法五</h5><p>除此之外此题可以先打表，以便判断是否为2的幂，又$x$最大2的21次幂，所以打到21就好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>&gt; ump1; </span><br><span class="line"><span class="keyword">int</span> tmp=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">21</span>;i++)&#123;</span><br><span class="line">    ump1[tmp]=<span class="literal">true</span>;</span><br><span class="line">    tmp*=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(1)$。</p><p>但枚举的时间复杂度为$O(n^2)$，还是会$TLE$，这里只是趁机总结了几种判断一个数是否为2的幂次的方法。</p><h6 id="优化：对第二层枚举，可以考虑枚举2的幂，然后判断差是否在数组中，此处可以通过哈希表实现。边插入边统计，保证不会重复计算。"><a href="#优化：对第二层枚举，可以考虑枚举2的幂，然后判断差是否在数组中，此处可以通过哈希表实现。边插入边统计，保证不会重复计算。" class="headerlink" title="优化：对第二层枚举，可以考虑枚举2的幂，然后判断差是否在数组中，此处可以通过哈希表实现。边插入边统计，保证不会重复计算。"></a>优化：对第二层枚举，可以考虑枚举2的幂，然后判断差是否在数组中，此处可以通过哈希表实现。边插入边统计，保证不会重复计算。</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 哈希表</span></span><br><span class="line">        <span class="comment">// 两个数之和最大为2的21次方，先打个表，存2的0,1,2...,21次幂，记2的幂次共有c个，c=22</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> cnt=<span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>&gt; ump1; </span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">21</span>;i++)&#123;</span><br><span class="line">            ump1[tmp]=<span class="literal">true</span>;</span><br><span class="line">            tmp*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; ump2; <span class="comment">// d中元素的数量</span></span><br><span class="line">        <span class="comment">// 边插入边统计，保证不会重复计算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:d)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j:ump1)&#123;                </span><br><span class="line">                <span class="keyword">if</span>(ump2.<span class="built_in">count</span>(j.first-i))&#123;</span><br><span class="line">                    cnt=(cnt+ump2[j.first-i])%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ump2[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(n*logC)$，$C$为元素值上限。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;p&gt;7.7 每日一题&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/count-good-meals/&quot;&gt;https://leetcode-cn.com/problems/count-good-meals/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="每日一题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="哈希表" scheme="https://benyang0506.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="位运算" scheme="https://benyang0506.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>单词接龙</title>
    <link href="https://benyang0506.github.io/2021/06/25/%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/"/>
    <id>https://benyang0506.github.io/2021/06/25/%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/</id>
    <published>2021-06-25T07:55:17.000Z</published>
    <updated>2021-07-08T09:02:48.859Z</updated>
    
    <content type="html"><![CDATA[<p>127 单词接龙</p><p>传送门：<a href="https://leetcode-cn.com/problems/minimum-absolute-difference-queries/">https://leetcode-cn.com/problems/minimum-absolute-difference-queries/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>字典 <code>wordList</code> 中从单词 <code>beginWord</code> 和 <code>endWord</code> 的 <strong>转换序列</strong> 是一个按下述规格形成的序列：</p><ul><li>序列中第一个单词是 <code>beginWord</code> 。</li><li>序列中最后一个单词是 <code>endWord</code> 。</li><li>每次转换只能改变一个字母。</li><li>转换过程中的中间单词必须是字典 <code>wordList</code> 中的单词。</li></ul><p>给你两个单词 <code>beginWord</code> 和 <code>endWord</code> 和一个字典 <code>wordList</code> ，找到从 <code>beginWord</code> 到 <code>endWord</code> 的 <strong>最短转换序列</strong> 中的 <strong>单词数目</strong> 。如果不存在这样的转换序列，返回 0。</p><p><strong>示例 1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">输出：5</span><br><span class="line">解释：一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, 返回它的长度 5。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line">输出：0</span><br><span class="line">解释：endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= beginWord.length &lt;= 10</span><br><span class="line">endWord.length == beginWord.length</span><br><span class="line">1 &lt;= wordList.length &lt;= 5000</span><br><span class="line">wordList[i].length == beginWord.length</span><br><span class="line">beginWord、endWord 和 wordList[i] 由小写英文字母组成</span><br><span class="line">beginWord != endWord</span><br><span class="line">wordList 中的所有字符串互不相同</span><br></pre></td></tr></table></figure><h3 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h3><p>可以看作最短路问题，这里的每个单词就是一种状态，可以看作一个点，如何两个单词只相差一个字母，那么这两个字母之间就存在一条边，求两个点之间的最短路。</p><p>首先，如果$endWord$不在$wordList$中，不可能存在一种转换序列，返回0；</p><p>标记$wordList$中单词是否访问可以用$map$，每次扩展考虑当前单词的每一位，每一位有25种替换方法，又1 &lt;= beginWord.length &lt;= 10，第一层就有<code>25*10=250</code>种，第二层有<code>250*250=62500</code>种，第三层…，但最多只有<code>5000*250=1250000</code>。</p><p>直到扩展到$endWord$，返回步数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// bfs</span></span><br><span class="line">    string s,e;</span><br><span class="line">    unordered_map&lt;string,<span class="keyword">bool</span>&gt; ump;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">        queue&lt;string&gt; q;</span><br><span class="line">        unordered_map&lt;string,<span class="keyword">int</span>&gt; d;</span><br><span class="line">        q.<span class="built_in">push</span>(s);</span><br><span class="line">        d[s]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            string t=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(t==e) <span class="keyword">return</span> d[t];</span><br><span class="line">            <span class="keyword">int</span> dis=d[t];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> j=<span class="string">&#x27;a&#x27;</span>;j&lt;=<span class="string">&#x27;z&#x27;</span>;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j==t[i]) <span class="keyword">continue</span>;</span><br><span class="line">                    string tt=t.<span class="built_in">substr</span>(<span class="number">0</span>,i)+j+t.<span class="built_in">substr</span>(i+<span class="number">1</span>,t.<span class="built_in">size</span>()<span class="number">-1</span>-i);</span><br><span class="line">                    <span class="comment">// cout&lt;&lt;t&lt;&lt;&quot; &quot;&lt;&lt;tt&lt;&lt;&quot; &quot;;</span></span><br><span class="line">                    <span class="keyword">if</span>(ump[tt])&#123;</span><br><span class="line">                        <span class="keyword">if</span>(d.<span class="built_in">count</span>(tt)==<span class="number">0</span>)&#123;</span><br><span class="line">                            d[tt]=dis+<span class="number">1</span>;</span><br><span class="line">                            q.<span class="built_in">push</span>(tt);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:wordList)&#123;</span><br><span class="line">            ump[i]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s=beginWord;</span><br><span class="line">        e=endWord;</span><br><span class="line">        <span class="keyword">if</span>(!ump[endWord]) <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">bfs</span>()==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bfs</span>()+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="双向bfs"><a href="#双向bfs" class="headerlink" title="双向bfs"></a>双向bfs</h3><p>为了解决$bfs$搜索空间爆炸的问题，加速查找，可以用双向$bfs$，从$beginWord$和$endWord$分别查找。</p><p>两个方向分别$bfs$，每次选择状态数量较少的队列来扩展，可以使两个队列元素数量分布平均，也为了加快遍历的速度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 双向bfs，解决空间爆炸问题</span></span><br><span class="line">    unordered_map&lt;string,<span class="keyword">bool</span>&gt; ump;</span><br><span class="line">    <span class="comment">// beginWord和endWord</span></span><br><span class="line">    string s,e;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// queue:bfs</span></span><br><span class="line">        queue&lt;string&gt; q1,q2;</span><br><span class="line">        <span class="comment">// 标记步数，防止某一状态被重复访问</span></span><br><span class="line">        <span class="comment">// d1[s]=k：由beginWord转换到s需要k次</span></span><br><span class="line">        <span class="comment">// d2[s]=k：由endWord转换到s需要k次</span></span><br><span class="line">        unordered_map&lt;string,<span class="keyword">int</span>&gt; d1,d2;</span><br><span class="line">        q1.<span class="built_in">push</span>(s);</span><br><span class="line">        d1[s]=<span class="number">0</span>;</span><br><span class="line">        q2.<span class="built_in">push</span>(e);</span><br><span class="line">        d2[e]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果有一个queue为空，说明这一端搜到底都搜不到endWord/beginWord</span></span><br><span class="line">        <span class="comment">// 只有两个queue都为空，才有必要继续搜索</span></span><br><span class="line">        <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>()&amp;&amp;!q2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">// 不是双向各走一步，是每次选择一个方向走一步（入队）</span></span><br><span class="line">            <span class="comment">// 为了使两个队列元素数量分布平均，也为了加快遍历的速度，选择元素较少的队列</span></span><br><span class="line">            <span class="keyword">if</span>(q1.<span class="built_in">size</span>()&lt;=q2.<span class="built_in">size</span>())&#123;</span><br><span class="line">                string t=q1.<span class="built_in">front</span>();</span><br><span class="line">                q1.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(d2.<span class="built_in">count</span>(t)!=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> d1[t]+d2[t];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> j=<span class="string">&#x27;a&#x27;</span>;j&lt;=<span class="string">&#x27;z&#x27;</span>;j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(j!=t[i])&#123;</span><br><span class="line">                            string tt=t.<span class="built_in">substr</span>(<span class="number">0</span>,i)+j+t.<span class="built_in">substr</span>(i+<span class="number">1</span>,t.<span class="built_in">size</span>()<span class="number">-1</span>-i);</span><br><span class="line">                            <span class="keyword">if</span>(ump[tt])&#123;</span><br><span class="line">                                <span class="keyword">if</span>(d1.<span class="built_in">count</span>(tt)==<span class="number">0</span>)&#123;</span><br><span class="line">                                    q1.<span class="built_in">push</span>(tt);</span><br><span class="line">                                    d1[tt]=d1[t]+<span class="number">1</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                string t=q2.<span class="built_in">front</span>();</span><br><span class="line">                q2.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(d1.<span class="built_in">count</span>(t)!=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> d1[t]+d2[t];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> j=<span class="string">&#x27;a&#x27;</span>;j&lt;=<span class="string">&#x27;z&#x27;</span>;j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(j!=t[i])&#123;</span><br><span class="line">                            string tt=t.<span class="built_in">substr</span>(<span class="number">0</span>,i)+j+t.<span class="built_in">substr</span>(i+<span class="number">1</span>,t.<span class="built_in">size</span>()<span class="number">-1</span>-i);</span><br><span class="line">                            <span class="keyword">if</span>(ump[tt])&#123;</span><br><span class="line">                                <span class="keyword">if</span>(d2.<span class="built_in">count</span>(tt)==<span class="number">0</span>)&#123;</span><br><span class="line">                                    q2.<span class="built_in">push</span>(tt);</span><br><span class="line">                                    d2[tt]=d2[t]+<span class="number">1</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i: wordList)&#123;</span><br><span class="line">            ump[i]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!ump[endWord]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        s=beginWord;</span><br><span class="line">        e=endWord;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bfs</span>()+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>计算双向$bfs$的时间复杂度：</p><p>记$wordList$长度为$n$，字符串长度为$m$，搜索的结果都会在$wordList$中出现过（不符合条件的剪枝，不入队），加上起点共$n+1$个，</p><p>最坏情况所有结点两两连通，$n$个结点进入队列，每个结点$n$条出边，时间复杂度$O(n^2)$，每次找出边时，时间复杂度$O(m)$，总时间复杂度$O(m*n^2)$。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;127 单词接龙&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-absolute-difference-queries/&quot;&gt;https://leetcode-cn.com/problems/minimum-absolute-difference-queries/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    
    <category term="bfs" scheme="https://benyang0506.github.io/tags/bfs/"/>
    
    <category term="双向bfs" scheme="https://benyang0506.github.io/tags/%E5%8F%8C%E5%90%91bfs/"/>
    
  </entry>
  
  <entry>
    <title>查询差绝对值的最小值</title>
    <link href="https://benyang0506.github.io/2021/06/23/%E6%9F%A5%E8%AF%A2%E5%B7%AE%E7%BB%9D%E5%AF%B9%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
    <id>https://benyang0506.github.io/2021/06/23/%E6%9F%A5%E8%AF%A2%E5%B7%AE%E7%BB%9D%E5%AF%B9%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</id>
    <published>2021-06-23T06:01:28.000Z</published>
    <updated>2021-06-23T06:26:06.613Z</updated>
    
    <content type="html"><![CDATA[<p>第246场周赛 D</p><p>传送门：<a href="https://leetcode-cn.com/problems/minimum-absolute-difference-queries/">https://leetcode-cn.com/problems/minimum-absolute-difference-queries/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>一个数组 <code>a</code> 的 <strong>差绝对值的最小值</strong> 定义为：<code>0 &lt;= i &lt; j &lt; a.length</code> 且 <code>a[i] != a[j]</code> 的 <code>|a[i] - a[j]|</code> 的 <strong>最小值</strong>。如果 <code>a</code> 中所有元素都 <strong>相同</strong> ，那么差绝对值的最小值为 <code>-1</code> 。</p><ul><li>比方说，数组 <code>[5,**2**,**3**,7,2]</code> 差绝对值的最小值是 <code>|2 - 3| = 1</code> 。注意答案不为 <code>0</code> ，因为 <code>a[i]</code> 和 <code>a[j]</code> 必须不相等。</li></ul><p>给你一个整数数组 <code>nums</code> 和查询数组 <code>queries</code> ，其中 <code>queries[i] = [li, ri]</code> 。对于每个查询 <code>i</code> ，计算 <strong>子数组</strong> <code>nums[li...ri]</code> 中 <strong>差绝对值的最小值</strong> ，子数组 <code>nums[li...ri]</code> 包含 <code>nums</code> 数组（下标从 <strong>0</strong> 开始）中下标在 <code>li</code> 和 <code>ri</code> 之间的所有元素（包含 <code>li</code> 和 <code>ri</code> 在内）。</p><p>请你返回 <code>ans</code> <strong>数组</strong>，其中 <code>ans[i]</code> 是第 <code>i</code> 个查询的答案。</p><p><strong>子数组</strong> 是一个数组中连续的一段元素。</p><p><code>|x|</code> 的值定义为：</p><ul><li>如果 <code>x &gt;= 0</code> ，那么值为 <code>x</code> 。</li><li>如果 <code>x &lt; 0</code> ，那么值为 <code>-x</code> 。</li></ul><p><strong>示例 1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,4,8], queries = [[0,1],[1,2],[2,3],[0,3]]</span><br><span class="line">输出：[2,1,4,1]</span><br><span class="line">解释：查询结果如下：</span><br><span class="line">- queries[0] = [0,1]：子数组是 [1,3] ，差绝对值的最小值为 |1-3| = 2 。</span><br><span class="line">- queries[1] = [1,2]：子数组是 [3,4] ，差绝对值的最小值为 |3-4| = 1 。</span><br><span class="line">- queries[2] = [2,3]：子数组是 [4,8] ，差绝对值的最小值为 |4-8| = 4 。</span><br><span class="line">- queries[3] = [0,3]：子数组是 [1,3,4,8] ，差的绝对值的最小值为 |3-4| = 1 。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,5,2,2,7,10], queries = [[2,3],[0,2],[0,5],[3,5]]</span><br><span class="line">输出：[-1,1,1,3]</span><br><span class="line">解释：查询结果如下：</span><br><span class="line">- queries[0] = [2,3]：子数组是 [2,2] ，差绝对值的最小值为 -1 ，因为所有元素相等。</span><br><span class="line">- queries[1] = [0,2]：子数组是 [4,5,2] ，差绝对值的最小值为 |4-5| = 1 。</span><br><span class="line">- queries[2] = [0,5]：子数组是 [4,5,2,2,7,10] ，差绝对值的最小值为 |4-5| = 1 。</span><br><span class="line">- queries[3] = [3,5]：子数组是 [2,7,10] ，差绝对值的最小值为 |7-10| = 3 。</span><br></pre></td></tr></table></figure><h5 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 &lt;= nums.length &lt;= 1e5</span><br><span class="line">1 &lt;= nums[i] &lt;= 100</span><br><span class="line">1 &lt;= queries.length &lt;= 2 * 1e4</span><br><span class="line">0 &lt;= li &lt; ri &lt; nums.length</span><br></pre></td></tr></table></figure><h4 id="前缀和-哈希"><a href="#前缀和-哈希" class="headerlink" title="前缀和+哈希"></a>前缀和+哈希</h4><ul><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><p>数组中数据范围只有100，可以看作突破口。</p><p>预处理前缀和，我们在判断某个数时，如果出现过记为1，没有出现过记为0。</p><p>$q[i][j]$：数字$i$在前$j$位出现过多少次。</p><p>预处理前缀和：<code>10^5*100=10^7​</code>。</p><p>预处理前缀和，可以将判断<code>num[i]</code>中某个数是否出现过的时间复杂度优化为$O(1)$，对每次询问判断差值最大值只需要扫一次$1-100$，共<code>2*10^4*100=2*10^6</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// q[i][j]:</span></span><br><span class="line">    <span class="keyword">int</span> q[<span class="number">102</span>][<span class="number">100002</span>];</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">minDifference</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 &lt;= nums[i] &lt;= 100</span></span><br><span class="line">        <span class="comment">// 暴力：对每次询问 2*1e4： 哈希表扫一次区间1e5，找max1e2，时间复杂度O(2*1e9)</span></span><br><span class="line">        <span class="comment">// 优化：对每次询问 2*1e4：判断1-100每个数是否出现（可以优化到O（100）），找1e2，时间复杂度O(2*1e6)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理0-100每个数是否出现过</span></span><br><span class="line">        <span class="comment">// 对数组中的每个数x，nums[i]==x置为1，nums[i]!=x置为0；</span></span><br><span class="line">        <span class="comment">// 预处理用前缀和O(1e5*1e2)=O(1e7)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tnt=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]==i) tnt=<span class="number">1</span>;</span><br><span class="line">                q[i][j+<span class="number">1</span>]=q[i][j]+tnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以不用vector来存，然后再遍历求Min</span></span><br><span class="line">        <span class="comment">// 不需要额外开空间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;queries.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> last=<span class="number">-1</span>; <span class="comment">// 上一个出现过的数</span></span><br><span class="line">            <span class="keyword">int</span> Min=<span class="number">101</span>;</span><br><span class="line">            <span class="keyword">int</span> l=queries[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> r=queries[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">100</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(q[j][r+<span class="number">1</span>]-q[j][l]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 更新Min</span></span><br><span class="line">                    <span class="keyword">if</span>(last!=<span class="number">-1</span>)&#123;</span><br><span class="line">                        Min=<span class="built_in">min</span>(Min,j-last);</span><br><span class="line">                    &#125;</span><br><span class="line">                    last=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Min==<span class="number">101</span>) Min=<span class="number">-1</span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(Min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;第246场周赛 D&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-absolute-difference-queries/&quot;&gt;https://leetcode-cn.com/problems/minimum-absolute-difference-queries/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="周赛" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="哈希表" scheme="https://benyang0506.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="前缀和" scheme="https://benyang0506.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>统计子岛屿</title>
    <link href="https://benyang0506.github.io/2021/06/23/%E7%BB%9F%E8%AE%A1%E5%AD%90%E5%B2%9B%E5%B1%BF/"/>
    <id>https://benyang0506.github.io/2021/06/23/%E7%BB%9F%E8%AE%A1%E5%AD%90%E5%B2%9B%E5%B1%BF/</id>
    <published>2021-06-23T05:39:29.000Z</published>
    <updated>2021-06-23T05:59:25.201Z</updated>
    
    <content type="html"><![CDATA[<p>第246场周赛 C</p><p>传送门：<a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给你两个 <code>m x n</code> 的二进制矩阵 <code>grid1</code> 和 <code>grid2</code> ，它们只包含 <code>0</code> （表示水域）和 <code>1</code> （表示陆地）。一个 <strong>岛屿</strong> 是由 <strong>四个方向</strong> （水平或者竖直）上相邻的 <code>1</code> 组成的区域。任何矩阵以外的区域都视为水域。</p><p>如果 <code>grid2</code> 的一个岛屿，被 <code>grid1</code> 的一个岛屿 <strong>完全</strong> 包含，也就是说 <code>grid2</code> 中该岛屿的每一个格子都被 <code>grid1</code> 中同一个岛屿完全包含，那么我们称 <code>grid2</code> 中的这个岛屿为 <strong>子岛屿</strong> 。</p><p>请你返回 <code>grid2</code> 中 <strong>子岛屿</strong> 的 <strong>数目</strong> 。</p><p><strong>示例 1</strong></p><p><img src="/2021/06/23/%E7%BB%9F%E8%AE%A1%E5%AD%90%E5%B2%9B%E5%B1%BF/Snipaste_2021-06-23_13-50-41.png" alt></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]</span><br><span class="line">输出：3</span><br><span class="line">解释：如上图所示，左边为 grid1 ，右边为 grid2 。</span><br><span class="line">grid2 中标红的 1 区域是子岛屿，总共有 3 个子岛屿。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><p><img src="/2021/06/23/%E7%BB%9F%E8%AE%A1%E5%AD%90%E5%B2%9B%E5%B1%BF/Snipaste_2021-06-23_13-51-35.png" alt></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]</span><br><span class="line">输出：2 </span><br><span class="line">解释：如上图所示，左边为 grid1 ，右边为 grid2 。</span><br><span class="line">grid2 中标红的 1 区域是子岛屿，总共有 2 个子岛屿。</span><br></pre></td></tr></table></figure><h5 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m == grid1.length == grid2.length</span><br><span class="line">n == grid1[i].length == grid2[i].length</span><br><span class="line">1 &lt;= m, n &lt;= 500</span><br><span class="line">grid1[i][j] 和 grid2[i][j] 都要么是 0 要么是 1 。</span><br></pre></td></tr></table></figure><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>对grid2中的某一个连通块，如果其中的每一个位置在grid1中都为1，那么ans++；（满足此性质的连通块在grid1中也一定是联通的。）</p><p>$FloodFill$搭配$bfs$和$dfs$应该都可以，用$dfs$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// bool vis[501][501]; 不需要vis，可以直接使用g2来判断vis，走过的话将g2[i][j]=0;</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; g1,g2;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 访问到某一个点</span></span><br><span class="line">        <span class="comment">// g2标记访问过</span></span><br><span class="line">        g2[x][y]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 判断g1中是否为1</span></span><br><span class="line">        <span class="keyword">if</span>(!g1[x][y]) flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;   </span><br><span class="line">            x=x+dx[i];</span><br><span class="line">            y=y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;row&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;col&amp;&amp;g2[x][y])&#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">dfs</span>(x,y))</span><br><span class="line">                    flag=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x=x-dx[i];</span><br><span class="line">            y=y-dy[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubIslands</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid1, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 思路：对grid2中的某一个连通块，如果其中的每一个位置在grid1中都为1，那么ans++；（满足此性质的连通块在grid1中也一定是联通的。</span></span><br><span class="line">        g1=grid1;</span><br><span class="line">        g2=grid2;</span><br><span class="line">        col=g2[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        row=g2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(g2[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">dfs</span>(i,j))&#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;第246场周赛 C&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/&quot;&gt;https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="周赛" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="dfs" scheme="https://benyang0506.github.io/tags/dfs/"/>
    
    <category term="FloodFill" scheme="https://benyang0506.github.io/tags/FloodFill/"/>
    
  </entry>
  
  <entry>
    <title>二进制中1的个数</title>
    <link href="https://benyang0506.github.io/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>https://benyang0506.github.io/2021/06/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</id>
    <published>2021-06-23T02:12:28.000Z</published>
    <updated>2021-06-23T02:20:27.778Z</updated>
    
    <content type="html"><![CDATA[<p>6.23 每日一题</p><p>传送门：<a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p><p><strong>示例 1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#x27;1&#x27;。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：00000000000000000000000010000000</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#x27;1&#x27;。</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#x27;1&#x27;。</span><br></pre></td></tr></table></figure><h5 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入必须是长度为 32 的 二进制串 。</span><br></pre></td></tr></table></figure><h4 id="移位-判断"><a href="#移位-判断" class="headerlink" title="移位+判断"></a>移位+判断</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=n&amp;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(x) cnt++;</span><br><span class="line">            n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(k)$，$k$为$n$的位数，为32.</p><h4 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h4><p><code>x&amp;(x-1)</code></p><p>把最低位的1变为0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// lowbit2:把最低位的1变为0</span></span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">lowbit2</span><span class="params">(<span class="keyword">uint32_t</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x&amp;(x<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            n=<span class="built_in">lowbit2</span>(n);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(lgn)$。</p><p><code>x&amp;-x</code></p><p>返回x的最后一位1（从低往高数）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// lowbit:返回x的最后一位1（从低往高数）</span></span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">lowbit2</span><span class="params">(<span class="keyword">uint32_t</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            n-=<span class="built_in">lowbit2</span>(n);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(lgn)$。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;6.23 每日一题&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/&quot;&gt;https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="每日一题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="位运算" scheme="https://benyang0506.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>字符串的排列</title>
    <link href="https://benyang0506.github.io/2021/06/22/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <id>https://benyang0506.github.io/2021/06/22/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</id>
    <published>2021-06-22T09:29:50.000Z</published>
    <updated>2021-06-23T02:11:54.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><p>6.22 每日一题</p><p>传送门：<a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p> <strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure><h5 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= s 的长度 &lt;= 8</span><br></pre></td></tr></table></figure><h4 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h4><p>先求出所有排列结果，然后用$set$去重。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">9</span>];</span><br><span class="line">    map&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>&gt; vis;</span><br><span class="line">    set&lt;string&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k,string s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            string t=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                t=t+s[d[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">insert</span>(t);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">                vis[i]=<span class="literal">true</span>;</span><br><span class="line">                d[k]=i;</span><br><span class="line">                <span class="built_in">dfs</span>(k+<span class="number">1</span>,s);</span><br><span class="line">                vis[i]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">permutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,s);</span><br><span class="line">        vector&lt;string&gt; per;</span><br><span class="line">        per.<span class="built_in">assign</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> per;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(2^8*s)$</p><p>运行时间534ms。</p><h4 id="dfs-1"><a href="#dfs-1" class="headerlink" title="dfs"></a>dfs</h4><p>先求出所有排列结果，然后用$vector$排序再去重。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">9</span>];</span><br><span class="line">    map&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>&gt; vis;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k,string s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            string t=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                t=t+s[d[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(t);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">                vis[i]=<span class="literal">true</span>;</span><br><span class="line">                d[k]=i;</span><br><span class="line">                <span class="built_in">dfs</span>(k+<span class="number">1</span>,s);</span><br><span class="line">                vis[i]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">permutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,s);</span><br><span class="line">        <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line">        ans.<span class="built_in">erase</span>(<span class="built_in">unique</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>()),ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行时间424ms。</p><h4 id="dfs-剪枝"><a href="#dfs-剪枝" class="headerlink" title="dfs+剪枝"></a>dfs+剪枝</h4><p>在$dfs$的时候对重复的排列进行剪枝。</p><p>具体做法：先对$s$进行排序，使得相同元素相邻，然后在$dfs$的过程中，对$s[i]==s[i-1],vis[i-1]==true)$剪枝，因为相同元素$dfs$出来的结果一定相同，后面条件避免在一次排列中相同字符只能用一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">9</span>];</span><br><span class="line">    map&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>&gt; vis;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k,string s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            string t=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                t=t+s[d[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(t);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">// 剪枝，有重复元素跳过</span></span><br><span class="line">            <span class="comment">// 后面条件避免在一次排列中相同字符只能用一次</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;s[i]==s[i<span class="number">-1</span>]&amp;&amp;vis[i<span class="number">-1</span>]==<span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">                vis[i]=<span class="literal">true</span>;</span><br><span class="line">                d[k]=i;</span><br><span class="line">                <span class="built_in">dfs</span>(k+<span class="number">1</span>,s);</span><br><span class="line">                vis[i]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">permutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,s);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行时间116ms。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;p&gt;6.22 每日一题&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/&quot;&gt;https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="每日一题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="dfs" scheme="https://benyang0506.github.io/tags/dfs/"/>
    
  </entry>
  
</feed>
