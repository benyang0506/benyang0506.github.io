<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阿犇</title>
  
  <subtitle>记录生活中的点点滴滴</subtitle>
  <link href="https://benyang0506.github.io/atom.xml" rel="self"/>
  
  <link href="https://benyang0506.github.io/"/>
  <updated>2021-12-09T08:28:53.646Z</updated>
  <id>https://benyang0506.github.io/</id>
  
  <author>
    <name>杨犇</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C4.5算法</title>
    <link href="https://benyang0506.github.io/2021/12/08/C4-5%E7%AE%97%E6%B3%95/"/>
    <id>https://benyang0506.github.io/2021/12/08/C4-5%E7%AE%97%E6%B3%95/</id>
    <published>2021-12-08T14:04:42.000Z</published>
    <updated>2021-12-09T08:28:53.646Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C4-5算法"><a href="#C4-5算法" class="headerlink" title="C4.5算法"></a>C4.5算法</h2><h4 id="C4-5算法简介"><a href="#C4-5算法简介" class="headerlink" title="C4.5算法简介"></a><strong>C4.5算法简介</strong></h4><p>C4.5算法是用于生成决策树的一种经典算法，是ID3算法的一种延伸和优化。C4.5算法对ID3算法主要做了一下几点改进：<br>  （1）通过信息增益率选择分裂属性，克服了ID3算法中通过信息增益倾向于选择拥有多个属性值的属性作为分裂属性的不足；<br>  （2）能够处理离散型和连续型的属性类型，即将连续型的属性进行离散化处理；<br>  （3）构造决策树之后进行剪枝操作；<br>  （4）能够处理具有缺失属性值的训练数据。</p><h4 id="分裂属性的选择——信息增益率"><a href="#分裂属性的选择——信息增益率" class="headerlink" title="分裂属性的选择——信息增益率"></a><strong>分裂属性的选择——信息增益率</strong></h4><p>分裂属性选择的评判标准是决策树算法之间的根本区别。ID3算法由于采用的是信息增益，容易倾向于选择取值较多的属性作为节点。改良后的C4.5算法采用的是信息增益率，信息增益率=信息增益/属性熵，公式：</p><script type="math/tex; mode=display">Gain\_ratio(D,a)=\frac{Gain(D,a)}{IV(a)}</script><p> <strong>信息增益的计算公式</strong>如下（ID3中<a href="https://www.aben.fun/2021/12/04/ID3%E7%AE%97%E6%B3%95/）">https://www.aben.fun/2021/12/04/ID3%E7%AE%97%E6%B3%95/）</a></p><script type="math/tex; mode=display">IG(S|T)=Entropy(S)-\sum_{value(T)}\frac{|S_v|}{S}Entropy(S_v)</script><p>其中$S$为全部样本集合，$value(T)$是属性$T$的所有取值的集合，$v$是$T$的其中一个属性值，$S_v$是$S$中属性$T$的值为$v$的样例集合，$|S_v|$为$S_v$中所含样例数。</p><p>属性熵</p><script type="math/tex; mode=display">IV(a)=-\sum_{i=1}^n{\frac{D^i}{D}log_2(\frac{D^i}{D})}</script><p>当属性有很多值时，虽然信息增益变大了，但是相应的属性熵也会变大。所以最终计算的信息增益率并不是很大。在一定程度上可以避免ID3倾向于选择取值较多的属性作为节点的问题。</p><h4 id="连续型属性的离散化处理"><a href="#连续型属性的离散化处理" class="headerlink" title="连续型属性的离散化处理"></a><strong>连续型属性的离散化处理</strong></h4><p>当属性类型为离散型，无须对数据进行离散化处理；当属性类型为连续型，则需要对数据进行离散化处理。C4.5算法针对连续属性的离散化处理，核心思想：将属性A的N个属性值按照升序排列；通过二分法将属性A的所有属性值分成两部分（共有N-1种划分方法，二分的阈值为相邻两个属性值的中间值）；计算每种划分方法对应的信息增益，选取信息增益最大的划分方法的阈值作为属性A二分的阈值。</p><h4 id="剪枝——PEP-Pessimistic-Error-Pruning-剪枝法"><a href="#剪枝——PEP-Pessimistic-Error-Pruning-剪枝法" class="headerlink" title="剪枝——PEP(Pessimistic Error Pruning)剪枝法"></a><strong>剪枝——PEP(Pessimistic Error Pruning)剪枝法</strong></h4><p>由于决策树的建立完全是依赖于训练样本，因此该决策树对训练样本能够产生完美的拟合效果。但这样的决策树对于测试样本来说过于庞大而复杂，可能产生较高的分类错误率。这种现象就称为过拟合。因此需要将复杂的决策树进行简化，即去掉一些节点解决过拟合问题，这个过程称为剪枝。</p><p>剪枝方法分为预剪枝和后剪枝两大类。预剪枝是在构建决策树的过程中，提前终止决策树的生长，从而避免过多的节点产生。预剪枝方法虽然简单但实用性不强，因为很难精确的判断何时终止树的生长。后剪枝是在决策树构建完成之后，对那些置信度不达标的节点子树用叶子结点代替，该叶子结点的类标号用该节点子树中频率最高的类标记。后剪枝方法又分为两种，一类是把训练数据集分成树的生长集和剪枝集；另一类算法则是使用同一数据集进行决策树生长和剪枝。常见的后剪枝方法有CCP(Cost Complexity Pruning)、REP(Reduced Error Pruning)、PEP(Pessimistic Error Pruning)、MEP(Minimum Error Pruning)。</p><p>C4.5算法采用PEP(Pessimistic Error Pruning)剪枝法。PEP剪枝法由Quinlan提出，是一种自上而下的剪枝法，根据剪枝前后的错误率来判定是否进行子树的修剪，因此不需要单独的剪枝数据集。</p><h4 id="缺失属性值的处理"><a href="#缺失属性值的处理" class="headerlink" title="缺失属性值的处理"></a><strong>缺失属性值的处理</strong></h4><p>训练样本集中有可能会出现一些样本缺失了一些属性值，待分类样本中也会出现这样的情况。当遇到这样的样本集时该如何处理呢？含有缺失属性的样本集会一般会导致三个问题：<br>  （１）在构建决策树时，每一个分裂属性的选取是由训练样本集中所有属性的信息増益率来决定的。而在此阶段，如果训练样本集中有些样本缺少一部分属性，此时该如何计算该属性的信息増益率；<br>  （２）当已经选择某属性作为分裂属性时，样本集应该根据该属性的值来进行分支，但对于那些该属性的值为未知的样本，应该将它分支到哪一棵子树上；<br>  （３）在决策树已经构建完成后，如果待分类样本中有些属性值缺失，则该样本的分类过程如何进行。<br>  针对上述因缺失属性值引起的三个问题，C4.5算法有多种解决方案。<br>  面对问题一，在计算各属性的信息増益率时，若某些样本的属性值未知，那么可以这样处理：计算某属性的信息増益率时忽略掉缺失了此属性的样本；或者通过此属性的样本中出现频率最高的属性值，賦值给缺失了此属性的样本。<br>  面对问题二，假设属性Ａ已被选择作为决策树中的一个分支节点，在对样本集进行分支的时候，对于那些属性Ａ的值未知的样本，可以送样处理：不处理那些属性Ａ未知的样本，即简单的忽略它们；或者根据属性Ａ的其他样本的取值，来对未知样本进行赋值；或者为缺失属性Ａ的样本单独创建一个分支，不过这种方式得到的决策树模型结点数显然要増加，使模型更加复杂了。<br>  面对问题三，根据己经生成的决策树模型，对一个待分类的样本进行分类时，若此样本的属性Ａ的值未知，可以这样处理：待分类样本在到达属性Ａ的分支结点时即可结束分类过程，此样本所属类别为属性Ａ的子树中概率最大的类别；或者把待分类样本的属性Ａ赋予一个最常见的值，然后继续分类过程。<br><img src="/2021/12/08/C4-5%E7%AE%97%E6%B3%95/Snipaste_2021-12-09_16-21-05.png" alt></p><h4 id="C4-5算法优缺点分析"><a href="#C4-5算法优缺点分析" class="headerlink" title="C4.5算法优缺点分析"></a><strong>C4.5算法优缺点分析</strong></h4><p>优点：<br>（1）通过信息增益率选择分裂属性，克服了ID3算法中通过信息增益倾向于选择拥有多个属性值的属性作为分裂属性的不足；<br>（2）能够处理离散型和连续型的属性类型，即将连续型的属性进行离散化处理；<br>（3）构造决策树之后进行剪枝操作；<br>（4）能够处理具有缺失属性值的训练数据。<br>缺点：<br>（1）算法的计算效率较低，特别是针对含有连续属性值的训练样本时表现的尤为突出。<br>（2）算法在选择分裂属性时没有考虑到条件属性间的相关性，只计算数据集中每一个条件属性与决策属性之间的期望信息，有可能影响到属性选择的正确性。优点：<br>（1）通过信息增益率选择分裂属性，克服了ID3算法中通过信息增益倾向于选择拥有多个属性值的属性作为分裂属性的不足；<br>（2）能够处理离散型和连续型的属性类型，即将连续型的属性进行离散化处理；<br>（3）构造决策树之后进行剪枝操作；<br>（4）能够处理具有缺失属性值的训练数据。<br>缺点：<br>（1）算法的计算效率较低，特别是针对含有连续属性值的训练样本时表现的尤为突出。<br>（2）算法在选择分裂属性时没有考虑到条件属性间的相关性，只计算数据集中每一个条件属性与决策属性之间的期望信息，有可能影响到属性选择的正确性。</p><p>参考文章：</p><p><a href="https://zhuanlan.zhihu.com/p/89902999">https://zhuanlan.zhihu.com/p/89902999</a></p><p><a href="https://blog.csdn.net/zhihua_oba/article/details/70632622">https://blog.csdn.net/zhihua_oba/article/details/70632622</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C4-5算法&quot;&gt;&lt;a href=&quot;#C4-5算法&quot; class=&quot;headerlink&quot; title=&quot;C4.5算法&quot;&gt;&lt;/a&gt;C4.5算法&lt;/h2&gt;&lt;h4 id=&quot;C4-5算法简介&quot;&gt;&lt;a href=&quot;#C4-5算法简介&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="集成学习" scheme="https://benyang0506.github.io/categories/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="树模型" scheme="https://benyang0506.github.io/categories/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/%E6%A0%91%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="决策树" scheme="https://benyang0506.github.io/tags/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    
    <category term="C4.5" scheme="https://benyang0506.github.io/tags/C4-5/"/>
    
  </entry>
  
  <entry>
    <title>超级次方（递归+快速幂）</title>
    <link href="https://benyang0506.github.io/2021/12/06/%E8%B6%85%E7%BA%A7%E6%AC%A1%E6%96%B9/"/>
    <id>https://benyang0506.github.io/2021/12/06/%E8%B6%85%E7%BA%A7%E6%AC%A1%E6%96%B9/</id>
    <published>2021-12-06T00:58:37.000Z</published>
    <updated>2021-12-06T02:17:59.638Z</updated>
    
    <content type="html"><![CDATA[<p>372 超级次方</p><p>传送门：<a href="https://leetcode-cn.com/problems/super-pow/">https://leetcode-cn.com/problems/super-pow/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>你的任务是计算 $a^b$ 对 <code>1337</code> 取模，<code>a</code> 是一个正整数，<code>b</code> 是一个非常大的正整数且会以数组形式给出。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = 2, b = [3]</span><br><span class="line">输出：8</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = 2, b = [1,0]</span><br><span class="line">输出：1024</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = 1, b = [4,3,3,8,5,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = 2147483647, b = [2,0,0]</span><br><span class="line">输出：1198</span><br></pre></td></tr></table></figure><p><strong>数据范围</strong></p><ul><li><p><code>1 &lt;= a &lt;= 2^31 - 1</code></p></li><li><p><code>1 &lt;= b.length &lt;= 2000</code></p></li><li><p><code>0 &lt;= b[i] &lt;= 9</code></p></li><li><code>b</code> 不含前导 0</li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h4><p>今天也是抄三叶姐姐题解的一天，真好~</p><p>$a^k=a^{(k/10<em>10)+k \mod10}=a^{k/10</em>10}<em>a^{k \mod10}=(a^{k/10})^{10}</em>a^{k\mod10}$</p><p>举个例子</p><p>$15^{1234}=15^{1230}*15^4$</p><p>$15^{1234}=(15^{123})^{10}*15^4$</p><p>出现了递归子结构，最后需要实际计算的次方小于10。</p><h4 id="递归-快速幂"><a href="#递归-快速幂" class="headerlink" title="递归+快速幂"></a>递归+快速幂</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 9.21-9.35</span></span><br><span class="line">    <span class="keyword">int</span> MOD=<span class="number">1337</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, vector&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k=b.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(a,b,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a,vector&lt;<span class="keyword">int</span>&gt;&amp; b,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 前半部分需要递归计算，最后一位直接可以求出</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="built_in">dfs</span>(a,b,k<span class="number">-1</span>),<span class="number">10</span>)*<span class="built_in">pow</span>(a,b[k])%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                ans=(ans*a)%MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            a=a*a%MOD;</span><br><span class="line">            b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="迭代-快速幂"><a href="#迭代-快速幂" class="headerlink" title="迭代+快速幂"></a>迭代+快速幂</h4><p>$15^{1234}=15^{1230}*15^4$</p><p>$15^{1234}=(15^{123})^{10}*15^4$</p><p>$15^{1234}=((15^{12})^{10}<em>15^3)^{10}</em>15^4$</p><p>$15^{1234}=(((15^1)^{10}<em>15^2)^{10}</em>15^3)^{10}*15^4$</p><p>迭代版本更加好理解一些~</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 9.37-10.17 迭代版本</span></span><br><span class="line">    <span class="keyword">int</span> MOD=<span class="number">1337</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, vector&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=b.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            ans=(ans*<span class="built_in">pow</span>(a,b[i]))%MOD;</span><br><span class="line">            a=<span class="built_in">pow</span>(a,<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                ans=ans*a%MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            a=a*a%MOD;</span><br><span class="line">            b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;372 超级次方&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/super-pow/&quot;&gt;https://leetcode-cn.com/problems/super-pow/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode - 每日一题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="递归" scheme="https://benyang0506.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="快速幂" scheme="https://benyang0506.github.io/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>ID3算法</title>
    <link href="https://benyang0506.github.io/2021/12/04/ID3%E7%AE%97%E6%B3%95/"/>
    <id>https://benyang0506.github.io/2021/12/04/ID3%E7%AE%97%E6%B3%95/</id>
    <published>2021-12-04T12:45:37.000Z</published>
    <updated>2021-12-09T08:28:15.472Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a>ID3算法</h2><h4 id="决策树是如何工作的"><a href="#决策树是如何工作的" class="headerlink" title="决策树是如何工作的"></a>决策树是如何工作的</h4><p>一棵决策树包含一个根结点、若干个内部结点和若干个叶结点；叶结点对应于决策结果，其他每个结点则对应一个属性测试；每个结点包含的样本根据属性测试的结果被划分到子结点中；根结点包含样本全集，从根结点到每个叶结点的每个叶结点的路径对应一个判定测试序列。决策树学习的目的是为了产生一棵泛化能力强，也就是能够处理未见实例的决策树。</p><h4 id="ID3算法介绍"><a href="#ID3算法介绍" class="headerlink" title="ID3算法介绍"></a>ID3算法介绍</h4><p><strong>ID3算法</strong>是决策树的一种，它是基于奥卡姆剃刀原理的，即用尽量用较少的东西做更多的事。ID3算法，即Iterative Dichotomiser 3，迭代二叉树3代，是Ross Quinlan发明的一种决策树算法，这个算法的基础就是上面提到的奥卡姆剃刀原理，越是小型的决策树越优于大的决策树，尽管如此，也不总是生成最小的树型结构，而是一个启发式算法。</p><p>在信息论中，期望信息越小，那么信息增益就越大，从而纯度就越高。ID3算法的核心思想就是以信息增益来度量属性的选择，选择分裂后信息增益最大的属性进行分裂。该算法采用自顶向下的贪婪搜索遍历可能的决策空间。</p><h4 id="信息熵与信息增益"><a href="#信息熵与信息增益" class="headerlink" title="信息熵与信息增益"></a><strong>信息熵与信息增益</strong></h4><p>在信息增益中，重要性的衡量标准就是看特征能够为分类系统带来多少信息，带来的信息越多，该特征越重要。在认识信息增益之前，先来看看<strong>信息熵</strong>的定义</p><p><strong>熵</strong>这个概念最早起源于物理学，在物理学中是用来度量一个热力学系统的无序程度，而在信息学里面，熵是对不确定性的度量。在<strong>1948</strong>年，<strong>香农</strong>引入了<strong>信息熵</strong>，将其定义为离散随机事件出现的概率，一个系统越是有序，信息熵就越低，反之一个系统越是混乱，它的信息熵就越高。所以信息熵可以被认为是系统有序化程度的一个度量。</p><p>假如一个随机变量$X$的取值为$X={x_1,x_2,…,x_n} $，每一种取到的概率分别为${p_1,p_2,…,p_n}$，那么$X$的熵定义为</p><script type="math/tex; mode=display">H(X)=-\sum_{i=1}^n{p_ilog_2p_i}</script><p>意思是一个变量的变化情况可能越多，那么它携带的信息量就越大。</p><p>对于<strong>分类系统</strong>来说，类别$C$是变量，它的取值是${C_1,C_2,…,C_n}$，而每一个类别出现的概率分别是</p><script type="math/tex; mode=display">P(C_1),P(C_2),...,P(C_n)</script><p>而这里的$n$就是类别的总数，此时分类系统的熵就可以表示为</p><script type="math/tex; mode=display">H(C)=-\sum_{i=1}^n{P(C_i)log_2P(C_i)}</script><p>以上就是信息熵的定义，接下来介绍<strong>信息增益</strong>。</p><p>信息增益是针对一个一个特征而言的，就是看一个特征$t$，系统有它和没有它时的信息量各是多少，两者的差值就是这个特征给系统带来的信息量，即<strong>信息增益</strong>。在决策树分类问题中，信息增益就是决策树在进行属性选择划分前和划分后信息的差值。</p><p>假设当前信息的熵为$Entropy(S)$，划分后的信息熵为$Entropy(S|T)$，代表在特征属性$T$的条件下样本的条件熵。那么最终得到特征属性$T$带来的信息增益为</p><script type="math/tex; mode=display">IG(T)=Entropy(S)-Entropy(S|T)</script><p> <strong>信息增益的计算公式</strong>如下</p><script type="math/tex; mode=display">IG(S|T)=Entropy(S)-\sum_{value(T)}\frac{|S_v|}{S}Entropy(S_v)</script><p>其中$S$为全部样本集合，$value(T)$是属性$T$的所有取值的集合，$v$是$T$的其中一个属性值，$S_v$是$S$中属性$T$的值为$v$的样例集合，$|S_v|$为$S_v$中所含样例数。</p><p>在决策树的每一个非叶子结点划分之前，先计算每一个属性所带来的信息增益，选择最大信息增益的属性来划分，因为信息增益越大，区分样本的能力就越强，越具有代表性，很显然这是一种自顶向下的贪心策略。以上就是<strong>ID3算法</strong>的核心思想。</p><h5 id="决策树停止的条件"><a href="#决策树停止的条件" class="headerlink" title="决策树停止的条件"></a>决策树停止的条件</h5><ol><li>该群数据的每一个数据已经归类到每一类数据中，即数据已经不能继续再分</li><li>该群数据已经找不到新的属性进行节点分割</li><li>该群数据没有任何未处理的数据</li></ol><h4 id="ID3算法实现"><a href="#ID3算法实现" class="headerlink" title="ID3算法实现"></a>ID3算法实现</h4><p>阅读$sklearn$官方文档可知，$sklearn$的决策树仅仅是实现了$cart$树而已，<br>当信息计算方式为$Gini$，$Entropy$，就用来分类。注意，$sklearn$并没有实现$ID3$，但是$cart$中使用$entropy$的效果，等效于“二叉树的$ID3$”，因为$ID3$可以是“二叉决策树”，也可以是“多叉决策树”，所以$sklearn$使用决策树+$entropy$方式时，无法实现“基于$ID3$算法的多叉决策树”。</p><p><a href="https://scikit-learn.org/stable/modules/tree.html#tree-algorithms-id3-c4-5-c5-0-and-cart">https://scikit-learn.org/stable/modules/tree.html#tree-algorithms-id3-c4-5-c5-0-and-cart</a></p><p>参考文章：</p><p><a href="https://www.cnblogs.com/starfire86/p/5749328.html">https://www.cnblogs.com/starfire86/p/5749328.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ID3算法&quot;&gt;&lt;a href=&quot;#ID3算法&quot; class=&quot;headerlink&quot; title=&quot;ID3算法&quot;&gt;&lt;/a&gt;ID3算法&lt;/h2&gt;&lt;h4 id=&quot;决策树是如何工作的&quot;&gt;&lt;a href=&quot;#决策树是如何工作的&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="集成学习" scheme="https://benyang0506.github.io/categories/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="树模型" scheme="https://benyang0506.github.io/categories/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/%E6%A0%91%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="ID3" scheme="https://benyang0506.github.io/tags/ID3/"/>
    
    <category term="决策树" scheme="https://benyang0506.github.io/tags/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>KMP字符串</title>
    <link href="https://benyang0506.github.io/2021/11/25/KMP%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://benyang0506.github.io/2021/11/25/KMP%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2021-11-25T02:57:36.000Z</published>
    <updated>2021-11-30T14:55:59.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="KMP字符串"><a href="#KMP字符串" class="headerlink" title="KMP字符串"></a>KMP字符串</h5><p>传送门：<a href="https://www.acwing.com/problem/content/833/">https://www.acwing.com/problem/content/833/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给定一个模式串 S，以及一个模板串 P，所有字符串中只包含大小写英文字母以及阿拉伯数字。</p><p>模板串 P 在模式串 S 中多次作为子串出现。</p><p>求出模板串 P 在模式串 S 中所有出现的位置的起始下标。</p><h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行输入整数 NN，表示字符串 PP 的长度。</p><p>第二行输入字符串 PP。</p><p>第三行输入整数 MM，表示字符串 SS 的长度。</p><p>第四行输入字符串 SS。</p><h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><p>共一行，输出所有出现位置的起始下标（下标从 0 开始计数），整数之间用空格隔开。</p><h5 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h5><p><code>1&lt;=N&lt;=1e5</code></p><p><code>1&lt;=M&lt;=1e6</code></p><h5 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">aba</span><br><span class="line">5</span><br><span class="line">ababa</span><br></pre></td></tr></table></figure><h5 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 2</span><br></pre></td></tr></table></figure><h3 id="暴力："><a href="#暴力：" class="headerlink" title="暴力："></a>暴力：</h3><p>双指针，两层循环。</p><p>程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m;</span><br><span class="line">string s,p;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;p&gt;&gt;m&gt;&gt;s;</span><br><span class="line">    for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">        bool flag=true;</span><br><span class="line">        for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">            if(s[i+j]!=p[j])&#123;</span><br><span class="line">                flag=false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag) cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>$next[i]=j$</p><p>字符串$p$为模板串， $p[1,j]=p[i-j+1]$，前缀与后缀相同且最长。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;KMP字符串&quot;&gt;&lt;a href=&quot;#KMP字符串&quot; class=&quot;headerlink&quot; title=&quot;KMP字符串&quot;&gt;&lt;/a&gt;KMP字符串&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://www.acwing.com/problem/content/833/&quot;&gt;https://www.acwing.com/problem/content/833/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="模板题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%A8%A1%E6%9D%BF%E9%A2%98/"/>
    
    
    <category term="kmp" scheme="https://benyang0506.github.io/tags/kmp/"/>
    
  </entry>
  
  <entry>
    <title>第65场双周赛D（二分+贪心）</title>
    <link href="https://benyang0506.github.io/2021/11/18/%E7%AC%AC65%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9BD%EF%BC%88%E4%BA%8C%E5%88%86-%E8%B4%AA%E5%BF%83%EF%BC%89/"/>
    <id>https://benyang0506.github.io/2021/11/18/%E7%AC%AC65%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9BD%EF%BC%88%E4%BA%8C%E5%88%86-%E8%B4%AA%E5%BF%83%EF%BC%89/</id>
    <published>2021-11-18T02:47:48.633Z</published>
    <updated>2021-11-18T03:27:03.843Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="你可以安排的最多任务数目"><a href="#你可以安排的最多任务数目" class="headerlink" title="你可以安排的最多任务数目"></a>你可以安排的最多任务数目</h5><p>传送门：<a href="https://leetcode-cn.com/problems/maximum-number-of-tasks-you-can-assign/">https://leetcode-cn.com/problems/maximum-number-of-tasks-you-can-assign/</a></p><span id="more"></span><p>给你 <code>n</code> 个任务和 <code>m</code> 个工人。每个任务需要一定的力量值才能完成，需要的力量值保存在下标从 <strong>0</strong> 开始的整数数组 <code>tasks</code> 中，第 <code>i</code> 个任务需要 <code>tasks[i]</code> 的力量才能完成。每个工人的力量值保存在下标从 <strong>0</strong> 开始的整数数组 <code>workers</code> 中，第 <code>j</code> 个工人的力量值为 <code>workers[j]</code> 。每个工人只能完成 <strong>一个</strong> 任务，且力量值需要 <strong>大于等于</strong> 该任务的力量要求值（即 <code>workers[j] &gt;= tasks[i]</code> ）。</p><p>除此以外，你还有 <code>pills</code> 个神奇药丸，可以给 <strong>一个工人的力量值</strong> 增加 <code>strength</code> 。你可以决定给哪些工人使用药丸，但每个工人 <strong>最多</strong> 只能使用 <strong>一片</strong> 药丸。</p><p>给你下标从 <strong>0</strong> 开始的整数数组<code>tasks</code> 和 <code>workers</code> 以及两个整数 <code>pills</code> 和 <code>strength</code> ，请你返回 <strong>最多</strong> 有多少个任务可以被完成。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [3,2,1], workers = [0,3,3], pills = 1, strength = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">我们可以按照如下方案安排药丸：</span><br><span class="line">- 给 0 号工人药丸。</span><br><span class="line">- 0 号工人完成任务 2（0 + 1 &gt;= 1）</span><br><span class="line">- 1 号工人完成任务 1（3 &gt;= 2）</span><br><span class="line">- 2 号工人完成任务 0（3 &gt;= 3）</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [5,4], workers = [0,0,0], pills = 1, strength = 5</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">我们可以按照如下方案安排药丸：</span><br><span class="line">- 给 0 号工人药丸。</span><br><span class="line">- 0 号工人完成任务 0（0 + 5 &gt;= 5）</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [10,15,30], workers = [0,10,10,10,10], pills = 3, strength = 10</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">我们可以按照如下方案安排药丸：</span><br><span class="line">- 给 0 号和 1 号工人药丸。</span><br><span class="line">- 0 号工人完成任务 0（0 + 10 &gt;= 10）</span><br><span class="line">- 1 号工人完成任务 1（10 + 10 &gt;= 15）</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [5,9,8,5,9], workers = [1,6,4,2,6], pills = 1, strength = 5</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">我们可以按照如下方案安排药丸：</span><br><span class="line">- 给 2 号工人药丸。</span><br><span class="line">- 1 号工人完成任务 0（6 &gt;= 5）</span><br><span class="line">- 2 号工人完成任务 2（4 + 5 &gt;= 8）</span><br><span class="line">- 4 号工人完成任务 3（6 &gt;= 5）</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == tasks.length</code></li><li><p><code>m == workers.length</code></p></li><li><p><code>1 &lt;= n, m &lt;= 5 * 1e4</code></p></li><li><code>0 &lt;= pills &lt;= m</code></li><li><code>0 &lt;= tasks[i], workers[j], strength &lt;= 1e9</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="二分-贪心"><a href="#二分-贪心" class="headerlink" title="二分+贪心"></a>二分+贪心</h4><p>假如使用药丸以后，$k$个任务可以被完成，那么小于$k$个任务也一定能完成，求满足条件的最大的$k$，考虑二分。</p><p>需要检查$mid$个任务是否可以被完成，如何检查？</p><p>假设可以完成$k$个任务，那么给$workers$中力量最大的k个人使用药丸以后，去完成$tasks$中需要力量最小的$k$个任务，一定可以完成。</p><p>从易到难遍历最简单的$k$个任务，然后从最强的$k$个$workers$中由弱到强匹配，看能否完成（由弱到强匹配为什么最优？因为假如当前最弱$worker$可以满足，那么任意其它$worker$也可以满足，交换后仍然可行）；如果不能完成，则给当前工人使用药丸，然后匹配能满足的最难的任务A（为什么最优，因为如果匹配最简单的任务B，另一个$worker$也可以满足A，交换后仍然可行）如果存在不能匹配则失败。</p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 9.52-10.45</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxTaskAssign</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; tasks, vector&lt;<span class="keyword">int</span>&gt;&amp; workers, <span class="keyword">int</span> pills, <span class="keyword">int</span> strength)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 二分</span></span><br><span class="line">        <span class="built_in">sort</span>(tasks.<span class="built_in">begin</span>(),tasks.<span class="built_in">end</span>(),less&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="built_in">sort</span>(workers.<span class="built_in">begin</span>(),workers.<span class="built_in">end</span>(),less&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">int</span> m=workers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n=tasks.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="built_in">min</span>(m,n);</span><br><span class="line">        <span class="keyword">auto</span> check=[&amp;](<span class="keyword">int</span> k)-&gt;<span class="keyword">bool</span>&#123;</span><br><span class="line">            <span class="comment">// 从小到大匹配tasks</span></span><br><span class="line">            <span class="comment">// tasks: tasks[0]...tasks[k-1]</span></span><br><span class="line">            <span class="comment">// workers[m-k]...workers[m-1]</span></span><br><span class="line">            multiset&lt;<span class="keyword">int</span>&gt; <span class="built_in">t</span>(tasks.<span class="built_in">begin</span>(),tasks.<span class="built_in">begin</span>()+k);</span><br><span class="line">            <span class="keyword">int</span> use=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=m-k;i&lt;m;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(*t.<span class="built_in">begin</span>()&lt;=workers[i])&#123;</span><br><span class="line">                    t.<span class="built_in">erase</span>(t.<span class="built_in">begin</span>());</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 给workers[i]使用药丸，然后找workers[i]+strength大于等于的最大的tasks</span></span><br><span class="line">                use+=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(use&gt;pills) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">int</span> now_strength=workers[i]+strength;</span><br><span class="line">                <span class="comment">// lower_bound 返回数组中第一个大于等于num的位置</span></span><br><span class="line">                <span class="comment">// upper_bound 返回数组中第一个大于num的位置</span></span><br><span class="line">                <span class="comment">// auto it=upper_bound(t.begin(),t.end(),now_strength);</span></span><br><span class="line">                <span class="keyword">auto</span> it=t.<span class="built_in">upper_bound</span>(now_strength);</span><br><span class="line">                <span class="keyword">if</span>(it==t.<span class="built_in">begin</span>())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                it--;</span><br><span class="line">                t.<span class="built_in">erase</span>(it);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">int</span> mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid))&#123;</span><br><span class="line">                l=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                r=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>auto it=upper_bound(t.begin(),t.end(),now_strength);</code></p><p><code>auto it=t.upper_bound(now_strength);</code></p><p>使用上面语句会$TLE$，下面$AC$，其中$t$的数据类型为$multiset$。</p><p>调用$multiset$自身的$upper_bound$是在树上查找，时间复杂度$O(logn)$;</p><p>用$function$调用$upper_bound$时间复杂度为$O(n)$。</p><p>时间复杂度：$O(nlogn+mlogm+min(m,n)log^2(min(m,n)))$</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;你可以安排的最多任务数目&quot;&gt;&lt;a href=&quot;#你可以安排的最多任务数目&quot; class=&quot;headerlink&quot; title=&quot;你可以安排的最多任务数目&quot;&gt;&lt;/a&gt;你可以安排的最多任务数目&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-number-of-tasks-you-can-assign/&quot;&gt;https://leetcode-cn.com/problems/maximum-number-of-tasks-you-can-assign/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="周赛" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E5%91%A8%E8%B5%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>完美矩形（扫描线）</title>
    <link href="https://benyang0506.github.io/2021/11/16/%E5%AE%8C%E7%BE%8E%E7%9F%A9%E5%BD%A2%EF%BC%88%E6%89%AB%E6%8F%8F%E7%BA%BF%EF%BC%89/"/>
    <id>https://benyang0506.github.io/2021/11/16/%E5%AE%8C%E7%BE%8E%E7%9F%A9%E5%BD%A2%EF%BC%88%E6%89%AB%E6%8F%8F%E7%BA%BF%EF%BC%89/</id>
    <published>2021-11-16T10:05:38.000Z</published>
    <updated>2021-11-16T10:36:46.330Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="11-16-每日一题-完美矩形"><a href="#11-16-每日一题-完美矩形" class="headerlink" title="11.16 每日一题 完美矩形"></a>11.16 每日一题 完美矩形</h5><p>传送门：<a href="https://leetcode-cn.com/problems/perfect-rectangle/">https://leetcode-cn.com/problems/perfect-rectangle/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给你一个数组 <code>rectangles</code> ，其中 <code>rectangles[i] = [xi, yi, ai, bi]</code> 表示一个坐标轴平行的矩形。这个矩形的左下顶点是 <code>(xi, yi)</code> ，右上顶点是 <code>(ai, bi)</code> 。</p><p>如果所有矩形一起精确覆盖了某个矩形区域，则返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="/2021/11/16/%E5%AE%8C%E7%BE%8E%E7%9F%A9%E5%BD%A2%EF%BC%88%E6%89%AB%E6%8F%8F%E7%BA%BF%EF%BC%89/1.png" alt></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]</span><br><span class="line">输出：true</span><br><span class="line">解释：5 个矩形一起可以精确地覆盖一个矩形区域。 </span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/2021/11/16/%E5%AE%8C%E7%BE%8E%E7%9F%A9%E5%BD%A2%EF%BC%88%E6%89%AB%E6%8F%8F%E7%BA%BF%EF%BC%89/2.png" alt></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]</span><br><span class="line">输出：false</span><br><span class="line">解释：两个矩形之间有间隔，无法覆盖成一个矩形。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="/2021/11/16/%E5%AE%8C%E7%BE%8E%E7%9F%A9%E5%BD%A2%EF%BC%88%E6%89%AB%E6%8F%8F%E7%BA%BF%EF%BC%89/3.png" alt></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[3,2,4,4]]</span><br><span class="line">输出：false</span><br><span class="line">解释：图形顶端留有空缺，无法覆盖成一个矩形。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><p><img src="/2021/11/16/%E5%AE%8C%E7%BE%8E%E7%9F%A9%E5%BD%A2%EF%BC%88%E6%89%AB%E6%8F%8F%E7%BA%BF%EF%BC%89/4.png" alt></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]</span><br><span class="line">输出：false</span><br><span class="line">解释：因为中间有相交区域，虽然形成了矩形，但不是精确覆盖。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= rectangles.length &lt;= 2 * 1e4</span><br><span class="line">rectangles[i].length == 4</span><br><span class="line">-1e5 &lt;= xi, yi, ai, bi &lt;= 1e5</span><br></pre></td></tr></table></figure><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>观察样例找规律可知，完美矩形的充要条件为：拼接后得到的矩形面积等于所有矩形面积之和，图形中的顶点出现次数为2或4（大矩形的四个顶点为1除外）。</p><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt;, <span class="keyword">int</span>&gt; times; </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRectangleCover</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; rectangles)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 面积是否相等；所有顶点出现两次或四次</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum_area=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> minX=<span class="number">0x3f3f3f3f</span>,minY=<span class="number">0x3f3f3f3f</span>,maxX=<span class="number">-0x3f3f3f3f</span>,maxY=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rectangles.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> x1=rectangles[i][<span class="number">0</span>],y1=rectangles[i][<span class="number">1</span>],x2=rectangles[i][<span class="number">2</span>],y2=rectangles[i][<span class="number">3</span>];</span><br><span class="line">            minX=<span class="built_in">min</span>(minX,x1);</span><br><span class="line">            minY=<span class="built_in">min</span>(minY,y1);</span><br><span class="line">            maxX=<span class="built_in">max</span>(maxX,x2);</span><br><span class="line">            maxY=<span class="built_in">max</span>(maxY,y2);</span><br><span class="line">            sum_area+=(x2-x1)*(y2-y1);</span><br><span class="line">            times[&#123;x1,y1&#125;]++;</span><br><span class="line">            times[&#123;x2,y2&#125;]++;</span><br><span class="line">            times[&#123;x1,y2&#125;]++;</span><br><span class="line">            times[&#123;x2,y1&#125;]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum_area!=(maxX-minX)*(maxY-minY))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:times)&#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;i.second&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>((i.first.first==minX&amp;&amp;i.first.second==minY)||(i.first.first==maxX&amp;&amp;i.first.second==maxY)||</span><br><span class="line">            (i.first.first==minX&amp;&amp;i.first.second==maxY)||(i.first.first==maxX&amp;&amp;i.first.second==minY))&#123;</span><br><span class="line">                <span class="keyword">if</span>(i.second!=<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">// cout&lt;&lt;&quot;1&quot;&lt;&lt;endl;</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i.second!=<span class="number">2</span>&amp;&amp;i.second!=<span class="number">4</span>)&#123;</span><br><span class="line">                cout&lt;&lt;i.first.first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i.first.second&lt;&lt;endl;</span><br><span class="line">                cout&lt;&lt;i.second&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法二（扫描线）"><a href="#方法二（扫描线）" class="headerlink" title="方法二（扫描线）"></a>方法二（扫描线）</h3><p>扫描线解法：<br>将每个矩形看成两条竖直方向的直线，以$(x,y1,y2,flag)$的格式存，$flag$区分矩形的左边还是右边；<br>每一条非边缘的竖线，左右两边一定成对存在；<br>每一条边缘的竖线，左或右只出现一次；</p><p>其中，对非边缘的竖线，可以由无缝拼接而成的竖线成对存在（ps，成对存在的线段在$y$方向上可以不相邻，因此对同一个$x$，可能需要存多个线段，然后一一匹配）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 扫描线解法</span></span><br><span class="line">    <span class="comment">// 将每个矩形看成两条竖直方向的直线，以(x,y1,y2,flag)的格式存，flag区分矩形的左边还是右边</span></span><br><span class="line">    <span class="comment">// 每一条非边缘的竖线，左右两边成对存在</span></span><br><span class="line">    <span class="comment">// 每一条边缘的竖线，左或右只出现一次</span></span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; vt;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRectangleCover</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; rectangles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=rectangles.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            vt.<span class="built_in">push_back</span>(&#123;rectangles[i][<span class="number">0</span>],rectangles[i][<span class="number">1</span>],rectangles[i][<span class="number">3</span>],<span class="number">0</span>&#125;);</span><br><span class="line">            vt.<span class="built_in">push_back</span>(&#123;rectangles[i][<span class="number">2</span>],rectangles[i][<span class="number">1</span>],rectangles[i][<span class="number">3</span>],<span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(vt.<span class="built_in">begin</span>(),vt.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每个矩形存两条边</span></span><br><span class="line">        <span class="keyword">int</span> m=vt.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;m;)&#123;</span><br><span class="line">            <span class="keyword">int</span> r=l;</span><br><span class="line">            <span class="keyword">while</span>(r&lt;m&amp;&amp;vt[r][<span class="number">0</span>]==vt[l][<span class="number">0</span>])&#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 区间[l,r)</span></span><br><span class="line">            <span class="comment">// 只存ymin和ymax是错误的，对同一个x，y方向可能被分成多段，所以要将每一段都存下来。</span></span><br><span class="line">            vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; left;</span><br><span class="line">            vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; right;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;r;i++)&#123;</span><br><span class="line">                <span class="comment">// 左边</span></span><br><span class="line">                <span class="keyword">if</span>(vt[i][<span class="number">3</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">                    vector&lt;<span class="keyword">int</span>&gt; cur=&#123;vt[i][<span class="number">1</span>],vt[i][<span class="number">2</span>]&#125;;</span><br><span class="line">                    <span class="keyword">if</span>(left.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                        left.<span class="built_in">push_back</span>(cur);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(left[left.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>]&gt;cur[<span class="number">0</span>])&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(left[left.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>]==cur[<span class="number">0</span>])&#123;</span><br><span class="line">                            left[left.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>]=cur[<span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            left.<span class="built_in">push_back</span>(cur);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(vt[i][<span class="number">3</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">// 右边</span></span><br><span class="line">                    vector&lt;<span class="keyword">int</span>&gt; cur=&#123;vt[i][<span class="number">1</span>],vt[i][<span class="number">2</span>]&#125;;</span><br><span class="line">                    <span class="keyword">if</span>(right.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                        right.<span class="built_in">push_back</span>(cur);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(right[right.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>]&gt;cur[<span class="number">0</span>])&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(right[right.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>]==cur[<span class="number">0</span>])&#123;</span><br><span class="line">                            right[right.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>]=cur[<span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            right.<span class="built_in">push_back</span>(cur);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 非边缘</span></span><br><span class="line">            <span class="keyword">if</span>(l&gt;<span class="number">0</span>&amp;&amp;r&lt;m)&#123;</span><br><span class="line">                <span class="comment">// cout&lt;&lt;&quot;1&quot;&lt;&lt;endl;</span></span><br><span class="line">                <span class="keyword">if</span>(left.<span class="built_in">size</span>()!=right.<span class="built_in">size</span>())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;left.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(left[j][<span class="number">0</span>]!=right[j][<span class="number">0</span>]||left[j][<span class="number">1</span>]!=right[j][<span class="number">1</span>])&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(left.<span class="built_in">size</span>()==<span class="number">0</span>&amp;&amp;right.<span class="built_in">size</span>()==<span class="number">1</span>||left.<span class="built_in">size</span>()==<span class="number">1</span>||right.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l=r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;11-16-每日一题-完美矩形&quot;&gt;&lt;a href=&quot;#11-16-每日一题-完美矩形&quot; class=&quot;headerlink&quot; title=&quot;11.16 每日一题 完美矩形&quot;&gt;&lt;/a&gt;11.16 每日一题 完美矩形&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/perfect-rectangle/&quot;&gt;https://leetcode-cn.com/problems/perfect-rectangle/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="每日一题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="扫描线" scheme="https://benyang0506.github.io/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>第262场双周赛D</title>
    <link href="https://benyang0506.github.io/2021/11/02/%E7%AC%AC262%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9BD/"/>
    <id>https://benyang0506.github.io/2021/11/02/%E7%AC%AC262%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9BD/</id>
    <published>2021-11-02T13:02:26.000Z</published>
    <updated>2021-11-02T13:52:50.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="将数组分成两个数组并最小化数组和的差"><a href="#将数组分成两个数组并最小化数组和的差" class="headerlink" title="将数组分成两个数组并最小化数组和的差"></a>将数组分成两个数组并最小化数组和的差</h5><p>传送门：<a href="https://leetcode-cn.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/">https://leetcode-cn.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给你一个长度为 <code>2 * n</code> 的整数数组。你需要将 <code>nums</code> 分成 <strong>两个</strong> 长度为 <code>n</code> 的数组，分别求出两个数组的和，并 <strong>最小化</strong> 两个数组和之 <strong>差的绝对值</strong> 。<code>nums</code> 中每个元素都需要放入两个数组之一。</p><p>请你返回 <strong>最小</strong> 的数组和之差。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,9,7,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：最优分组方案是分成 [3,9] 和 [7,3] 。</span><br><span class="line">数组和之差的绝对值为 abs((3 + 9) - (7 + 3)) = 2 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-36,36]</span><br><span class="line">输出：72</span><br><span class="line">解释：最优分组方案是分成 [-36] 和 [36] 。</span><br><span class="line">数组和之差的绝对值为 abs((-36) - (36)) = 72 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,-1,0,4,-2,-9]</span><br><span class="line">输出：0</span><br><span class="line">解释：最优分组方案是分成 [2,4,-9] 和 [-1,0,-2] 。</span><br><span class="line">数组和之差的绝对值为 abs((2 + 4 + -9) - (-1 + 0 + -2)) = 0 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= n &lt;= 15</span><br><span class="line">nums.length == 2 * n</span><br><span class="line">-10^7 &lt;= nums[i] &lt;= 10^7</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>最接近目标值的子序列和问题，与</p><p><a href="https://www.aben.fun/2021/11/02/%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/#more">https://www.aben.fun/2021/11/02/%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/#more</a></p><p>非常类似。</p><p>搜索所有子集的时间复杂度较大的时候，可以考虑把原始集合划分成两个相等长度的集合，分别求子集。</p><p>这里把原数组划分成$sum1、sum2$两个长度为$n$的集合，分别求出其中所有子集的和（位运算），按组成子集的的元素个数分组。</p><p>然后开始合并两个子集，由于固定合并之后的长度为$n$，所以需要遍历$sum1$中组成元素个数从$0-n$的子集（对应$sum2$中为($n-i$)），可以用双指针或者二分求出于$sum/2$的最小差值。</p><p>将所有的元素*2是为了避免$sum/2$不是整数。</p><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><h5 id="折半搜索-状态压缩-双指针"><a href="#折半搜索-状态压缩-双指针" class="headerlink" title="折半搜索+状态压缩+双指针"></a>折半搜索+状态压缩+双指针</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; sum1,vector&lt;<span class="keyword">int</span>&gt;&amp; sum2,<span class="keyword">int</span> halfsum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Min=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=sum2.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;sum1.<span class="built_in">size</span>()&amp;&amp;j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            Min=<span class="built_in">min</span>(Min,<span class="built_in">abs</span>(sum1[i]+sum2[j]-halfsum));</span><br><span class="line">            <span class="keyword">if</span>(sum1[i]+sum2[j]&gt;=halfsum)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumDifference</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保证sum/2为整数</span></span><br><span class="line">        <span class="keyword">int</span> halfsum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            halfsum+=nums[i];</span><br><span class="line">            nums[i]*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>()/<span class="number">2</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">sum1</span>(n+<span class="number">1</span>);</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">sum2</span>(n+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    k++;</span><br><span class="line">                    s+=nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sum1[k].<span class="built_in">push_back</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    k++;</span><br><span class="line">                    s+=nums[n+j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sum2[k].<span class="built_in">push_back</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 问题变成了从16组两个元素个数不超过C(7,15)的列表中找出和最接近原来总和一半的方案，取得的两组的元素和为n</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; sum:sum1)&#123;</span><br><span class="line">            <span class="built_in">sort</span>(sum.<span class="built_in">begin</span>(),sum.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; sum:sum2)&#123;</span><br><span class="line">            <span class="built_in">sort</span>(sum.<span class="built_in">begin</span>(),sum.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> Min=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            Min=<span class="built_in">min</span>(Min,<span class="built_in">getMin</span>(sum1[i],sum2[n-i],halfsum));</span><br><span class="line">            <span class="keyword">if</span>(Min==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="折半搜索-状态压缩-二分"><a href="#折半搜索-状态压缩-二分" class="headerlink" title="折半搜索+状态压缩+二分"></a>折半搜索+状态压缩+二分</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumDifference</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保证sum/2为整数</span></span><br><span class="line">        <span class="keyword">int</span> halfsum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            halfsum+=nums[i];</span><br><span class="line">            nums[i]*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>()/<span class="number">2</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">sum1</span>(n+<span class="number">1</span>);</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">sum2</span>(n+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    k++;</span><br><span class="line">                    s+=nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sum1[k].<span class="built_in">push_back</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    k++;</span><br><span class="line">                    s+=nums[n+j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sum2[k].<span class="built_in">push_back</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> Min=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="comment">// 问题变成了从16组两个元素个数不超过C(7,15)的列表中找出和最接近原来总和一半的方案，取得的两组的元素和为n</span></span><br><span class="line">        <span class="comment">// 二分</span></span><br><span class="line">        <span class="comment">// 对sum2进行排序，对sum1中的每个i中的值，二分sum2中的n-i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; sum:sum2)&#123;</span><br><span class="line">            <span class="built_in">sort</span>(sum.<span class="built_in">begin</span>(),sum.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sum1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> x=sum1[i];</span><br><span class="line">            <span class="keyword">auto</span> y=sum2[n-i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> num:x)&#123;</span><br><span class="line">                <span class="keyword">int</span> l=<span class="number">0</span>,r=y.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(num+y[mid]-halfsum&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                        r=mid;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        l=mid+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Min=<span class="built_in">min</span>(Min,<span class="built_in">abs</span>(num+y[l]-halfsum));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;将数组分成两个数组并最小化数组和的差&quot;&gt;&lt;a href=&quot;#将数组分成两个数组并最小化数组和的差&quot; class=&quot;headerlink&quot; title=&quot;将数组分成两个数组并最小化数组和的差&quot;&gt;&lt;/a&gt;将数组分成两个数组并最小化数组和的差&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/&quot;&gt;https://leetcode-cn.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="周赛" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="双指针" scheme="https://benyang0506.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="二分" scheme="https://benyang0506.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
    <category term="状态压缩" scheme="https://benyang0506.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="折半搜索" scheme="https://benyang0506.github.io/tags/%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>最接近目标值的子序列和</title>
    <link href="https://benyang0506.github.io/2021/11/02/%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/"/>
    <id>https://benyang0506.github.io/2021/11/02/%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/</id>
    <published>2021-11-02T01:36:13.000Z</published>
    <updated>2021-11-02T13:49:09.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="最接近目标值的子序列和"><a href="#最接近目标值的子序列和" class="headerlink" title="最接近目标值的子序列和"></a>最接近目标值的子序列和</h5><p>传送门：<a href="https://leetcode-cn.com/problems/closest-subsequence-sum/">https://leetcode-cn.com/problems/closest-subsequence-sum/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给你一个整数数组 <code>nums</code> 和一个目标值 <code>goal</code> 。</p><p>你需要从 <code>nums</code> 中选出一个子序列，使子序列元素总和最接近 <code>goal</code> 。也就是说，如果子序列元素和为 <code>sum</code> ，你需要 <strong>最小化绝对差</strong> <code>abs(sum - goal)</code> 。</p><p>返回 <code>abs(sum - goal)</code> 可能的 <strong>最小值</strong> 。</p><p>注意，数组的子序列是通过移除原始数组中的某些元素（可能全部或无）而形成的数组。</p><p> <strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,-7,3,5], goal = 6</span><br><span class="line">输出：0</span><br><span class="line">解释：选择整个数组作为选出的子序列，元素和为 6 。</span><br><span class="line">子序列和与目标值相等，所以绝对差为 0 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [7,-9,15,-2], goal = -5</span><br><span class="line">输出：1</span><br><span class="line">解释：选出子序列 [7,-9,-2] ，元素和为 -4 。</span><br><span class="line">绝对差为 abs(-4 - (-5)) = abs(1) = 1 ，是可能的最小值。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3], goal = -7</span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums.length &lt;= 40</span><br><span class="line">-10^7 &lt;= nums[i] &lt;= 10^7</span><br><span class="line">-10^9 &lt;= goal &lt;= 10^9</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>枚举子集的基础题目：<a href="https://leetcode-cn.com/problems/subsets/">https://leetcode-cn.com/problems/subsets/</a></p><p>两种求所有子集的方法：</p><ul><li>$dfs$</li><li>位运算</li></ul><p>枚举所有子集的时间复杂度为$2^n$，$n=40$，加上每次需要求和运算，时间复杂度太高。</p><p>一个技巧：将$n=40$的数组拆成两部分，每部分元素个数为20，枚举每一部分所有子集的时间复杂度为$2^{20}\approx10^6$，接着枚举每一部分所有子集的和，记为$sum1$，$sum2$，时间复杂度$O((n/2)*2^{n/2})$，大概在$10^7$左右。</p><p>原数组的子序列和，必然为下列三者之一：</p><ul><li><p>$sum1$中某个元素</p></li><li><p>$sum2$中某个元素</p></li><li>$sum1$中某个元素与$sum2$中某个元素之和</li></ul><p>前两种情况直接遍历就可以得到，第三种情况为给定两个有序数组，分别从两个数组中各取出一个数字，使他们的和最接近$goal$，相关题目：<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/。">https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/。</a></p><p>考虑双指针，将$i$指向$sum1$中第一个元素，将$j$指向$sum2$中最后一个元素，每次计算$sum1[i]$与$sum2[j]$的和$s$。</p><p>如果$s&lt;goal$，则对于当前的$i$，剩余所有的$j$都不用考虑了（和只可能更小），于是将$i$右移一个位置；</p><p>如果$s&gt;=goal$，则对于当前的$j$，剩余所有的$i$都不需要考虑了（和只可能更大），于是将$j$左移一个位置。</p><p>这部分排序时间复杂度为$O(2^{n/2}log{2^{n/2}})$，大概在$10^7$左右，双指针时间复杂度$O(2^{n/2})$。</p><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; sum1;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; sum2;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minAbsDifference</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> goal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 位运算求subset</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;(n/<span class="number">2</span>));i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n/<span class="number">2</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    sum+=nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sum1.<span class="built_in">push_back</span>(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;(n-n/<span class="number">2</span>));i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(n-n/<span class="number">2</span>);j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    sum+=nums[n/<span class="number">2</span>+j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sum2.<span class="built_in">push_back</span>(sum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(sum1.<span class="built_in">begin</span>(),sum1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(sum2.<span class="built_in">begin</span>(),sum2.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> Min=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sum1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(sum1[i]-goal)&lt;Min)&#123;</span><br><span class="line">                Min=<span class="built_in">abs</span>(sum1[i]-goal);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sum2.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(sum2[i]-goal)&lt;Min)&#123;</span><br><span class="line">                Min=<span class="built_in">abs</span>(sum2[i]-goal);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从sum1中挑选一个数，从sum2中挑选一个数，使二者之和与goal的差最小</span></span><br><span class="line">        <span class="comment">// 双指针做法</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=sum2.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;sum1.<span class="built_in">size</span>()&amp;&amp;j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            Min=<span class="built_in">min</span>(Min,<span class="built_in">abs</span>(sum1[i]+sum2[j]-goal));</span><br><span class="line">            <span class="keyword">if</span>(sum1[i]+sum2[j]&lt;=goal)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;最接近目标值的子序列和&quot;&gt;&lt;a href=&quot;#最接近目标值的子序列和&quot; class=&quot;headerlink&quot; title=&quot;最接近目标值的子序列和&quot;&gt;&lt;/a&gt;最接近目标值的子序列和&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/closest-subsequence-sum/&quot;&gt;https://leetcode-cn.com/problems/closest-subsequence-sum/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    
    <category term="双指针" scheme="https://benyang0506.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="状态压缩" scheme="https://benyang0506.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="折半搜索" scheme="https://benyang0506.github.io/tags/%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Attention Is All You Need</title>
    <link href="https://benyang0506.github.io/2021/11/01/Attention-Is-All-You-Need/"/>
    <id>https://benyang0506.github.io/2021/11/01/Attention-Is-All-You-Need/</id>
    <published>2021-11-01T11:39:27.000Z</published>
    <updated>2021-11-01T13:43:37.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Attention-Is-All-You-Need"><a href="#Attention-Is-All-You-Need" class="headerlink" title="Attention Is All You Need"></a>Attention Is All You Need</h2><p>原文链接：<a href="https://arxiv.org/abs/1706.03762">https://arxiv.org/abs/1706.03762</a><br>中英文对应（来自一译）：<a href="https://www.yiyibooks.cn/yiyibooks/Attention_Is_All_You_Need/index.html">https://www.yiyibooks.cn/yiyibooks/Attention_Is_All_You_Need/index.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Attention-Is-All-You-Need&quot;&gt;&lt;a href=&quot;#Attention-Is-All-You-Need&quot; class=&quot;headerlink&quot; title=&quot;Attention Is All You Need&quot;&gt;&lt;/a&gt;Attention I</summary>
      
    
    
    
    <category term="nlp" scheme="https://benyang0506.github.io/categories/nlp/"/>
    
    
    <category term="transformer" scheme="https://benyang0506.github.io/tags/transformer/"/>
    
  </entry>
  
  <entry>
    <title>八股搭建神经网络</title>
    <link href="https://benyang0506.github.io/2021/10/28/%E5%85%AB%E8%82%A1%E6%90%AD%E5%BB%BA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>https://benyang0506.github.io/2021/10/28/%E5%85%AB%E8%82%A1%E6%90%AD%E5%BB%BA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</id>
    <published>2021-10-28T11:10:32.000Z</published>
    <updated>2021-10-28T11:18:58.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用八股搭建神经网络"><a href="#使用八股搭建神经网络" class="headerlink" title="使用八股搭建神经网络"></a>使用八股搭建神经网络</h2><p>用Tensorflow API: tf. keras</p><h4 id="六步法搭建神经网络"><a href="#六步法搭建神经网络" class="headerlink" title="六步法搭建神经网络"></a>六步法搭建神经网络</h4><p>第一步：import相关模块，如import tensorflow as tf。</p><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><p>第二步：指定输入网络的训练集和测试集，如指定训练集的输入x_train和标签y_train，测试集的输<br>入x_test和标签y_test。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mnist = tf.keras.datasets.mnist</span><br><span class="line">(x_train,y_train),(x_test,y_test)=mnist.load_data()</span><br><span class="line">x_train,x_test=x_train/<span class="number">255.0</span>,x_test/<span class="number">255.0</span></span><br></pre></td></tr></table></figure><p>第三步：逐层搭建网络结构，model = tf.keras.models.Sequential()。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">model=tf.keras.models.Sequential([</span><br><span class="line">    tf.keras.layers.Flatten(),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">128</span>,activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">10</span>,activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>第四步：在model.compile()中配置训练方法，选择训练时使用的优化器、损失函数和最终评价指标。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">             loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=<span class="literal">False</span>),</span><br><span class="line">             metrics=[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>])</span><br></pre></td></tr></table></figure><h4 id="断点续训，读取模型"><a href="#断点续训，读取模型" class="headerlink" title="断点续训，读取模型"></a>断点续训，读取模型</h4><p>定义存放模型的路径和文件名，命名为ckpt文件</p><p>生成ckpt文件时会同步生成index索引表，所以判断索引表是否存在，来判断是否存在模型参数</p><p>如有索引表，则直接读取ckpt文件中的模型参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">checkpoint_save_path=<span class="string">&quot;./checkpoint/mnist.ckpt&quot;</span></span><br><span class="line"><span class="keyword">if</span> os.path.exists(checkpoint_save_path+<span class="string">&#x27;.index&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--------------load the model---------------&#x27;</span>)</span><br><span class="line">    model.load_weights(checkpoint_save_path)</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>--------------load the model---------------</code></pre><h4 id="保存模型"><a href="#保存模型" class="headerlink" title="保存模型"></a>保存模型</h4><p>第五步：在model.fit()中执行训练过程，告知训练集和测试集的输入值和标签、每个batch的大小（batchsize）和数据集的迭代次数（epoch）。</p><p>第六步：使用model.summary()打印网络结构，统计参数数目。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cp_callback = tf.keras.callbacks.ModelCheckpoint(filepath=checkpoint_save_path,</span><br><span class="line">                                                save_weights_only=<span class="literal">True</span>,</span><br><span class="line">                                                save_best_only=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">history = model.fit(x_train,y_train,batch_size=<span class="number">32</span>,epochs=<span class="number">5</span>,validation_data=(x_test,y_test),validation_freq=<span class="number">1</span>,callbacks=[cp_callback])</span><br><span class="line">model.summary()</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>Epoch 1/51875/1875 [==============================] - 2s 886us/step - loss: 0.0118 - sparse_categorical_accuracy: 0.9962 - val_loss: 0.0801 - val_sparse_categorical_accuracy: 0.9797Epoch 2/51875/1875 [==============================] - 1s 667us/step - loss: 0.0101 - sparse_categorical_accuracy: 0.9967 - val_loss: 0.0899 - val_sparse_categorical_accuracy: 0.9798Epoch 3/51875/1875 [==============================] - 1s 695us/step - loss: 0.0086 - sparse_categorical_accuracy: 0.9974 - val_loss: 0.0879 - val_sparse_categorical_accuracy: 0.9807Epoch 4/51875/1875 [==============================] - 1s 694us/step - loss: 0.0095 - sparse_categorical_accuracy: 0.9970 - val_loss: 0.0979 - val_sparse_categorical_accuracy: 0.9782Epoch 5/51875/1875 [==============================] - 1s 687us/step - loss: 0.0060 - sparse_categorical_accuracy: 0.9981 - val_loss: 0.0997 - val_sparse_categorical_accuracy: 0.9800Model: &quot;sequential&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================flatten (Flatten)            (None, 784)               0         _________________________________________________________________dense (Dense)                (None, 128)               100480    _________________________________________________________________dense_1 (Dense)              (None, 10)                1290      =================================================================Total params: 101,770Trainable params: 101,770Non-trainable params: 0_________________________________________________________________</code></pre><h4 id="设置输出格式"><a href="#设置输出格式" class="headerlink" title="设置输出格式"></a>设置输出格式</h4><p>np.set printoptions(threshold=超过多少省略显示)</p><p>np.set_printoptions(threshold=np.inf) # np. inf表示无限大</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.set_printoptions(threshold=np.inf)</span></span><br><span class="line">np.set_printoptions(threshold=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(model.trainable_variables)</span><br></pre></td></tr></table></figure><pre><code>[&lt;tf.Variable &#39;dense/kernel:0&#39; shape=(784, 128) dtype=float32, numpy=array([[-0.05238347, -0.06266207, -0.07440181, ...,  0.0417512 ,        -0.05344176,  0.02906115],       [-0.00369083,  0.01099763, -0.00766775, ...,  0.07014749,        -0.03556629,  0.01387362],       [-0.07415341, -0.01817401,  0.00419831, ...,  0.06153186,        -0.01100198,  0.0544705 ],       ...,       [ 0.06579664, -0.06812809, -0.05979012, ..., -0.0540199 ,         0.04981285,  0.066493  ],       [-0.0601579 ,  0.06772352, -0.0692725 , ..., -0.04544504,        -0.08102902,  0.02741539],       [-0.044352  , -0.07048865,  0.00934549, ...,  0.032233  ,        -0.00784087,  0.05623148]], dtype=float32)&gt;, &lt;tf.Variable &#39;dense/bias:0&#39; shape=(128,) dtype=float32, numpy=array([-0.14855091, -0.07285158, -0.09825671, ...,  0.07643671,       -0.1354494 ,  0.08794942], dtype=float32)&gt;, &lt;tf.Variable &#39;dense_1/kernel:0&#39; shape=(128, 10) dtype=float32, numpy=array([[ 2.43996501e-01, -2.15584278e-01,  2.29047656e-01, ...,        -6.07578419e-02,  9.98528376e-02,  1.91292807e-01],       [ 2.44029671e-01,  4.49361429e-02, -9.02478278e-01, ...,        -9.88776796e-03,  4.69152890e-02,  1.93796545e-01],       [-1.17883611e+00,  3.15114379e-01,  3.47505659e-01, ...,         3.69858891e-01,  3.26448739e-01, -8.94050360e-01],       ...,       [-5.94317436e-01, -2.05278710e-01, -7.61512935e-01, ...,         3.76689643e-01,  1.37598768e-01,  1.51904374e-01],       [-2.08765984e-01,  1.04028150e-01,  1.08290091e-01, ...,        -6.63495797e-04,  1.37945980e-01,  1.77999035e-01],       [ 4.85304482e-02, -2.46528938e-01, -5.67862451e-01, ...,        -4.70214367e-01, -3.69332522e-01,  1.24029376e-01]], dtype=float32)&gt;, &lt;tf.Variable &#39;dense_1/bias:0&#39; shape=(10,) dtype=float32, numpy=array([-0.1546798 , -0.22612654, -0.10529487, -0.1593509 ,  0.18012638,        0.10057895, -0.01941594, -0.1304893 ,  0.35250106,  0.02564381],      dtype=float32)&gt;]</code></pre><h4 id="参数保存"><a href="#参数保存" class="headerlink" title="参数保存"></a>参数保存</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file=<span class="built_in">open</span>(<span class="string">&#x27;./weights.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> model.trainable_variables:</span><br><span class="line">    file.write(<span class="built_in">str</span>(v.name)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    file.write(<span class="built_in">str</span>(v.shape)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    file.write(<span class="built_in">str</span>(v.numpy())+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><h4 id="显示训练集和验证集的acc和loss曲线"><a href="#显示训练集和验证集的acc和loss曲线" class="headerlink" title="显示训练集和验证集的acc和loss曲线"></a>显示训练集和验证集的acc和loss曲线</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">acc=history.history[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>]</span><br><span class="line">val_acc=history.history[<span class="string">&#x27;val_sparse_categorical_accuracy&#x27;</span>]</span><br><span class="line">loss=history.history[<span class="string">&#x27;loss&#x27;</span>]</span><br><span class="line">val_loss=history.history[<span class="string">&#x27;val_loss&#x27;</span>]</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">plt.plot(acc,label=<span class="string">&#x27;Training Accuracy&#x27;</span>)</span><br><span class="line">plt.plot(val_acc,label=<span class="string">&#x27;Validation Accuracy&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Training and Validation Accuracy&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">plt.plot(loss,label=<span class="string">&#x27;Training loss&#x27;</span>)</span><br><span class="line">plt.plot(val_loss,label=<span class="string">&#x27;Validation Loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and Validation Loss&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2021/10/28/%E5%85%AB%E8%82%A1%E6%90%AD%E5%BB%BA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/output_21_0.png" style="zoom:90%;"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;使用八股搭建神经网络&quot;&gt;&lt;a href=&quot;#使用八股搭建神经网络&quot; class=&quot;headerlink&quot; title=&quot;使用八股搭建神经网络&quot;&gt;&lt;/a&gt;使用八股搭建神经网络&lt;/h2&gt;&lt;p&gt;用Tensorflow API: tf. keras&lt;/p&gt;
&lt;h4 id=&quot;六步法搭建神经网络&quot;&gt;&lt;a href=&quot;#六步法搭建神经网络&quot; class=&quot;headerlink&quot; title=&quot;六步法搭建神经网络&quot;&gt;&lt;/a&gt;六步法搭建神经网络&lt;/h4&gt;&lt;p&gt;第一步：import相关模块，如import tensorflow as tf。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习/深度学习基础" scheme="https://benyang0506.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="tensorflow" scheme="https://benyang0506.github.io/tags/tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>第63场双周赛D</title>
    <link href="https://benyang0506.github.io/2021/10/28/%E7%AC%AC63%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9BD/"/>
    <id>https://benyang0506.github.io/2021/10/28/%E7%AC%AC63%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9BD/</id>
    <published>2021-10-28T10:47:40.000Z</published>
    <updated>2021-10-28T10:56:15.040Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="两个有序数组的第K小乘积"><a href="#两个有序数组的第K小乘积" class="headerlink" title="两个有序数组的第K小乘积"></a>两个有序数组的第K小乘积</h5><p>传送门：<a href="https://leetcode-cn.com/problems/kth-smallest-product-of-two-sorted-arrays/">https://leetcode-cn.com/problems/kth-smallest-product-of-two-sorted-arrays/</a></p><span id="more"></span><p>给你两个 <strong>从小到大排好序</strong> 且下标从 <strong>0</strong> 开始的整数数组 <code>nums1</code> 和 <code>nums2</code> 以及一个整数 <code>k</code> ，请你返回第 <code>k</code> （从 <strong>1</strong> 开始编号）小的 <code>nums1[i] * nums2[j]</code> 的乘积，其中 <code>0 &lt;= i &lt; nums1.length</code> 且 <code>0 &lt;= j &lt; nums2.length</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [2,5], nums2 = [3,4], k = 2</span><br><span class="line">输出：8</span><br><span class="line">解释：第 2 小的乘积计算如下：</span><br><span class="line">- nums1[0] * nums2[0] = 2 * 3 = 6</span><br><span class="line">- nums1[0] * nums2[1] = 2 * 4 = 8</span><br><span class="line">第 2 小的乘积为 8 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [-4,-2,0,3], nums2 = [2,4], k = 6</span><br><span class="line">输出：0</span><br><span class="line">解释：第 6 小的乘积计算如下：</span><br><span class="line">- nums1[0] * nums2[1] = (-4) * 4 = -16</span><br><span class="line">- nums1[0] * nums2[0] = (-4) * 2 = -8</span><br><span class="line">- nums1[1] * nums2[1] = (-2) * 4 = -8</span><br><span class="line">- nums1[1] * nums2[0] = (-2) * 2 = -4</span><br><span class="line">- nums1[2] * nums2[0] = 0 * 2 = 0</span><br><span class="line">- nums1[2] * nums2[1] = 0 * 4 = 0</span><br><span class="line">第 6 小的乘积为 0 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [-2,-1,0,1,2], nums2 = [-3,-1,2,4,5], k = 3</span><br><span class="line">输出：-6</span><br><span class="line">解释：第 3 小的乘积计算如下：</span><br><span class="line">- nums1[0] * nums2[4] = (-2) * 5 = -10</span><br><span class="line">- nums1[0] * nums2[3] = (-2) * 4 = -8</span><br><span class="line">- nums1[4] * nums2[0] = 2 * (-3) = -6</span><br><span class="line">第 3 小的乘积为 -6 。</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h5 id="二分-二分"><a href="#二分-二分" class="headerlink" title="二分+二分"></a>二分+二分</h5><p>假设$f(x)$为满足$nums1[i]$与$nums2[j] $的乘积小于等于$x$的组数，显然函数随$x$递增，可以二分。</p><p>计算满足$nums1[i]$与$nums2[j] $的乘积小于等于$x$的组数时，枚举$nums1$中的数$u$，每次固定$u$，二分$nums2$，寻找$nums2$中有多少个数满足$u*nums2[j]&lt;=x$。</p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; B;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">check</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> u:A)&#123;</span><br><span class="line">            <span class="keyword">if</span>(u&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 为什么不是break？考虑B[0]为负数的情况，A[0]*B[0]最大，所以要继续朝A[0]后面搜索</span></span><br><span class="line">                <span class="keyword">if</span>(u*B[<span class="number">0</span>]&gt;x) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 固定A，二分最大的乘积&lt;=x的B的索引</span></span><br><span class="line">                <span class="keyword">int</span> l=<span class="number">0</span>,r=B.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                    <span class="keyword">int</span> mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(u*B[mid]&lt;=x)&#123;</span><br><span class="line">                        l=mid;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        r=mid<span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt+=l+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(u&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 先取乘积最小的组合</span></span><br><span class="line">                <span class="keyword">if</span>(u*B[B.<span class="built_in">size</span>()<span class="number">-1</span>]&gt;x) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> l=<span class="number">0</span>,r=B.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(u*B[mid]&lt;=x)&#123;</span><br><span class="line">                        r=mid;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        l=mid+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt+=B.<span class="built_in">size</span>()-l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(u==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(x&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    cnt+=B.<span class="built_in">size</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">kthSmallestProduct</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">long</span> <span class="keyword">long</span> k)</span> </span>&#123;</span><br><span class="line">        A=nums1;</span><br><span class="line">        B=nums2;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> l=<span class="number">-1e10</span><span class="number">-10</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> r=<span class="number">1e10</span>+<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 二分乘积&lt;=x的组数</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid)&gt;=k)&#123;</span><br><span class="line">                r=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;两个有序数组的第K小乘积&quot;&gt;&lt;a href=&quot;#两个有序数组的第K小乘积&quot; class=&quot;headerlink&quot; title=&quot;两个有序数组的第K小乘积&quot;&gt;&lt;/a&gt;两个有序数组的第K小乘积&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/kth-smallest-product-of-two-sorted-arrays/&quot;&gt;https://leetcode-cn.com/problems/kth-smallest-product-of-two-sorted-arrays/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="周赛" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="二分" scheme="https://benyang0506.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>删除无效的括号</title>
    <link href="https://benyang0506.github.io/2021/10/27/%E5%88%A0%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>https://benyang0506.github.io/2021/10/27/%E5%88%A0%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</id>
    <published>2021-10-27T02:19:28.000Z</published>
    <updated>2021-10-28T10:58:12.678Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="10-27-每日一题"><a href="#10-27-每日一题" class="headerlink" title="10.27 每日一题"></a>10.27 每日一题</h5><p>传送门：<a href="https://leetcode-cn.com/problems/remove-invalid-parentheses/">https://leetcode-cn.com/problems/remove-invalid-parentheses/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给你一个由若干括号和字母组成的字符串 <code>s</code> ，删除最小数量的无效括号，使得输入的字符串有效。</p><p>返回所有可能的结果。答案可以按 <strong>任意顺序</strong> 返回。</p><p> <strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()())()&quot;</span><br><span class="line">输出：[&quot;(())()&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;(a)())()&quot;</span><br><span class="line">输出：[&quot;(a())()&quot;,&quot;(a)()()&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;)(&quot;</span><br><span class="line">输出：[&quot;&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 25</code></li><li><code>s</code> 由小写英文字母以及括号 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 组成</li><li><code>s</code> 中至多含 <code>20</code> 个括号</li></ul><h3 id="方法一：dfs-剪枝"><a href="#方法一：dfs-剪枝" class="headerlink" title="方法一：dfs+剪枝"></a>方法一：dfs+剪枝</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h5 id="我们发现，删除的无效括号的最小数量是可以提前求出来的。"><a href="#我们发现，删除的无效括号的最小数量是可以提前求出来的。" class="headerlink" title="我们发现，删除的无效括号的最小数量是可以提前求出来的。"></a>我们发现，删除的无效括号的最小数量是可以提前求出来的。</h5><p>可以用一个计数器$lnum$来模拟栈，往栈中不断地添加左括号；</p><p>之后出现的右括号都可以去栈中匹配左括号，最后栈中剩下的即为要删去的左括号，数量等于$lnum$。</p><p>右括号出现时，栈中没有左括号用来匹配，则右括号需要删去，计数器$rnum$++，记录需要删去的右括号数量。</p><h5 id="dfs-搜索"><a href="#dfs-搜索" class="headerlink" title="$dfs$搜索"></a>$dfs$搜索</h5><p>$dfs$所有删去$lnum$个左括号、$rnum$个右括号的序列，并判断是否有效。</p><h5 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h5><p>记录当前序列中的左括号数目$lc$与右括号数目$rc$，如果右括号数目$rc&gt;lc$，则这个序列一定为无效序列，停止搜索。</p><h5 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h5><p>按照上述算法搜索出的结果中可能含有重复序列，比如当前遇到的字符串为” (((())”，去掉前四个左括号中的任意一个，生成的字符串是一样的，均为 “(())”。</p><ul><li><p>在最后的结果中去重，可以使用哈希表/$set$/$sort+unique$。</p></li><li><p>在搜索过程中，遇到相邻元素相同的情况时，只需要搜索一次就好。（剪枝）</p></li></ul><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(st.<span class="built_in">top</span>()!=<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        st.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(string s,<span class="keyword">int</span> lremove,<span class="keyword">int</span> rremove,<span class="keyword">int</span> start,<span class="keyword">int</span> lc,<span class="keyword">int</span> rc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lremove==<span class="number">0</span>&amp;&amp;rremove==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isValid</span>(s))&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=start &amp;&amp; s[i]==s[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>) lc++;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>) rc++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 去掉一个左括号</span></span><br><span class="line">            <span class="keyword">if</span>(lremove&gt;<span class="number">0</span>&amp;&amp;s[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">dfs</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>,i)+s.<span class="built_in">substr</span>(i+<span class="number">1</span>),lremove<span class="number">-1</span>,rremove,i,lc,rc);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//去掉一个右括号</span></span><br><span class="line">            <span class="keyword">if</span>(rremove&gt;<span class="number">0</span>&amp;&amp;s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">dfs</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>,i)+s.<span class="built_in">substr</span>(i+<span class="number">1</span>),lremove,rremove<span class="number">-1</span>,i,lc,rc);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                lc++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                rc++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rc&gt;lc)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">removeInvalidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先计算需要删除的左括号数量、右括号数量</span></span><br><span class="line">        <span class="keyword">int</span> lnum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rnum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                lnum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(lnum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    lnum--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    rnum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dfs</span>(s,lnum,rnum,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// sort(ans.begin(),ans.end());</span></span><br><span class="line">        <span class="comment">// ans.erase(unique(ans.begin(),ans.end()),ans.end());</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n*2^n)$，$n$为字符串的长度，长度为$n$的字符串最多有$2^n$个子串，需要对每个子串进行一次合法性判断。</p><h3 id="方法二：bfs"><a href="#方法二：bfs" class="headerlink" title="方法二：bfs"></a>方法二：bfs</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>注意到题目说的是删去最少的括号，我们可以每次删去一个括号，就所有删去一个括号的操作作为$bfs$的一层，判断这一层有没有符合条件的序列；如果没有就继续删一个括号，转向下一层，以此类推，一旦在某一层找到答案便停止搜索。</p><p>我们做$bfs$，上一层$level$和下一层$level$之间的关系为：把所有上一层$level$中的每个元素都拿出来，列举出在删除一个括号后的所有可能的情况。(不管删除以后是否合法），添加到下一个$level$中的元素。</p><p>例如：$current level$是 <code>[&quot;(()&quot;, &quot;())&quot;]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 那么下一层level中的元素应该是:</span><br><span class="line"></span><br><span class="line">    1. 对 &quot;(()&quot; 删除一个括号的所有可能为： (), (), ((</span><br><span class="line">    2. 对 &quot;())&quot; 删除一个括号的所有可能为： (), )), ()</span><br></pre></td></tr></table></figure><p>注意到有重复的序列，可以使用$unordered_set$代替$queue$，以达到去重的目的。</p><h4 id="程序-1"><a href="#程序-1" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isvalid</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                ans--;</span><br><span class="line">                <span class="keyword">if</span>(ans&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bfs</span></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">removeInvalidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// unordered_set模拟队列</span></span><br><span class="line">        <span class="comment">// 每一层删去一些字符后会有重复元素，可以在进队前去重</span></span><br><span class="line">        unordered_set&lt;string&gt; q;</span><br><span class="line">        <span class="comment">// 存答案</span></span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        q.<span class="built_in">insert</span>(s);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">// 遍历这一层中的所有序列，如果有符合条件的，加入ans中，并且终止向下一层搜索。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> ss:q)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">isvalid</span>(ss))&#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(ss);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ans.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 继续搜索下一层</span></span><br><span class="line">            unordered_set&lt;string&gt; curq;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> ss:q)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ss.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;ss[i]==ss[i<span class="number">-1</span>])&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(ss[i]==<span class="string">&#x27;(&#x27;</span>||ss[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                        curq.<span class="built_in">insert</span>(ss.<span class="built_in">substr</span>(<span class="number">0</span>,i)+ss.<span class="built_in">substr</span>(i+<span class="number">1</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            q=curq;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n*2^n)$，$n$为字符串的长度，长度为$n$的字符串最多有$2^n$个子串，需要对每个子串进行一次合法性判断。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;10-27-每日一题&quot;&gt;&lt;a href=&quot;#10-27-每日一题&quot; class=&quot;headerlink&quot; title=&quot;10.27 每日一题&quot;&gt;&lt;/a&gt;10.27 每日一题&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/remove-invalid-parentheses/&quot;&gt;https://leetcode-cn.com/problems/remove-invalid-parentheses/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="每日一题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="dfs" scheme="https://benyang0506.github.io/tags/dfs/"/>
    
    <category term="bfs" scheme="https://benyang0506.github.io/tags/bfs/"/>
    
  </entry>
  
  <entry>
    <title>Jupyter notebook 快捷键</title>
    <link href="https://benyang0506.github.io/2021/10/26/Jupyter-notebook%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://benyang0506.github.io/2021/10/26/Jupyter-notebook%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2021-10-26T11:52:57.000Z</published>
    <updated>2021-10-26T12:05:26.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Jupyter-notebook-快捷键"><a href="#Jupyter-notebook-快捷键" class="headerlink" title="Jupyter notebook 快捷键"></a>Jupyter notebook 快捷键</h2><h5 id="Jupyter-Notebook-有两种键盘输入模式。"><a href="#Jupyter-Notebook-有两种键盘输入模式。" class="headerlink" title="Jupyter Notebook 有两种键盘输入模式。"></a>Jupyter Notebook 有两种键盘输入模式。</h5><p>编辑模式，允许你往单元中键入代码或文本；这时的单元框线是绿色的。</p><span id="more"></span><p>命令模式，键盘输入运行程序命令；这时的单元框线是灰色的。</p><h3 id="命令模式-按键-Esc-开启"><a href="#命令模式-按键-Esc-开启" class="headerlink" title="命令模式 (按键 Esc 开启)"></a>命令模式 (按键 Esc 开启)</h3><ul><li>Enter : 转入编辑模式</li><li>Shift-Enter : 运行本单元，选中下个单元</li><li>Ctrl-Enter : 运行本单元</li><li>Alt-Enter : 运行本单元，在其下插入新单元</li><li>Y : 单元转入代码状态</li><li>M :单元转入markdown状态</li><li>R : 单元转入raw状态</li><li>1 : 设定 1 级标题</li><li>2 : 设定 2 级标题</li><li>3 : 设定 3 级标题</li><li>4 : 设定 4 级标题</li><li>5 : 设定 5 级标题</li><li>6 : 设定 6 级标题</li><li>Up : 选中上方单元</li><li>K : 选中上方单元</li><li>Down : 选中下方单元</li><li>J : 选中下方单元</li><li>Shift-K : 扩大选中上方单元</li><li>Shift-J : 扩大选中下方单元</li><li>A : 在上方插入新单元</li><li>B : 在下方插入新单元</li><li>X : 剪切选中的单元</li><li>C : 复制选中的单元</li><li>Shift-V : 粘贴到上方单元</li><li>V : 粘贴到下方单元</li><li>Z : 恢复删除的最后一个单元</li><li>D,D : 删除选中的单元</li><li>Shift-M : 合并选中的单元</li><li>Ctrl-S : 文件存盘</li><li>S : 文件存盘</li><li>L : 转换行号</li><li>O : 转换输出</li><li>Shift-O : 转换输出滚动</li><li>Esc : 关闭页面</li><li>Q : 关闭页面</li><li>H : 显示快捷键帮助</li><li>I,I : 中断Notebook内核</li><li>0,0 : 重启Notebook内核</li><li>Shift : 忽略</li><li>Shift-Space : 向上滚动</li><li>Space : 向下滚动</li></ul><h3 id="编辑模式-Enter-键启动"><a href="#编辑模式-Enter-键启动" class="headerlink" title="编辑模式 ( Enter 键启动)"></a>编辑模式 ( Enter 键启动)</h3><ul><li>Tab : 代码补全或缩进</li><li>Shift-Tab : 提示</li><li>Ctrl-] : 缩进</li><li>Ctrl-[ : 解除缩进</li><li>Ctrl-A : 全选</li><li>Ctrl-Z : 复原</li><li>Ctrl-Shift-Z : 再做</li><li>Ctrl-Y : 再做</li><li>Ctrl-Home : 跳到单元开头</li><li>Ctrl-Up : 跳到单元开头</li><li>Ctrl-End : 跳到单元末尾</li><li>Ctrl-Down : 跳到单元末尾</li><li>Ctrl-Left : 跳到左边一个字首</li><li>Ctrl-Right : 跳到右边一个字首</li><li>Ctrl-Backspace : 删除前面一个字</li><li>Ctrl-Delete : 删除后面一个字</li><li>Esc : 进入命令模式</li><li>Ctrl-M : 进入命令模式</li><li>Shift-Enter : 运行本单元，选中下一单元</li><li>Ctrl-Enter : 运行本单元</li><li>Alt-Enter : 运行本单元，在下面插入一单元</li><li>Ctrl-Shift– : 分割单元</li><li>Ctrl-Shift-Subtract : 分割单元</li><li>Ctrl-S : 文件存盘</li><li>Shift : 忽略</li><li>Up : 光标上移或转入上一单元</li><li>Down :光标下移或转入下一单元</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Jupyter-notebook-快捷键&quot;&gt;&lt;a href=&quot;#Jupyter-notebook-快捷键&quot; class=&quot;headerlink&quot; title=&quot;Jupyter notebook 快捷键&quot;&gt;&lt;/a&gt;Jupyter notebook 快捷键&lt;/h2&gt;&lt;h5 id=&quot;Jupyter-Notebook-有两种键盘输入模式。&quot;&gt;&lt;a href=&quot;#Jupyter-Notebook-有两种键盘输入模式。&quot; class=&quot;headerlink&quot; title=&quot;Jupyter Notebook 有两种键盘输入模式。&quot;&gt;&lt;/a&gt;Jupyter Notebook 有两种键盘输入模式。&lt;/h5&gt;&lt;p&gt;编辑模式，允许你往单元中键入代码或文本；这时的单元框线是绿色的。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习/深度学习基础" scheme="https://benyang0506.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="jupyter" scheme="https://benyang0506.github.io/tags/jupyter/"/>
    
  </entry>
  
  <entry>
    <title>下一个更大元素I</title>
    <link href="https://benyang0506.github.io/2021/10/26/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I/"/>
    <id>https://benyang0506.github.io/2021/10/26/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I/</id>
    <published>2021-10-26T04:26:31.000Z</published>
    <updated>2021-10-26T04:49:43.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="10-26-下一个更大元素"><a href="#10-26-下一个更大元素" class="headerlink" title="10.26 下一个更大元素"></a>10.26 下一个更大元素</h5><p>传送门：<a href="https://leetcode-cn.com/problems/next-greater-element-i/">https://leetcode-cn.com/problems/next-greater-element-i/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给你两个 <strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，其中<code>nums1</code> 是 <code>nums2</code> 的子集。</p><p>请你找出 <code>nums1</code> 中每个元素在 <code>nums2</code> 中的下一个比其大的值。</p><p><code>nums1</code> 中数字 <code>x</code> 的下一个更大元素是指 <code>x</code> 在 <code>nums2</code> 中对应位置的右边的第一个比 <code>x</code> 大的元素。如果不存在，对应位置输出 <code>-1</code> 。</p><p> <strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [4,1,2], nums2 = [1,3,4,2].</span><br><span class="line">输出: [-1,3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。</span><br><span class="line">    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。</span><br><span class="line">    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [2,4], nums2 = [1,2,3,4].</span><br><span class="line">输出: [3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。</span><br><span class="line">    对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li><li><p><code>0 &lt;= nums1[i], nums2[i] &lt;= 10^4</code></p></li><li><p><code>nums1</code>和<code>nums2</code>中所有整数 <strong>互不相同</strong></p></li><li><code>nums1</code> 中的所有整数同样出现在 <code>nums2</code> 中</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>碰到求下一个更大的元素/上一个更小的元素，用单调栈。</p><p>预处理$nums2$，倒叙遍历$nums2$，用单调栈维护当前位置右边的更大的元素列表，栈内的元素从栈底到栈顶是单调递减的。</p><p>如果存在$i&gt;j$，并且$nums2[i]&lt;nums2[j]$，则$nums2[i]$不会成为答案，要从栈中弹出。</p><p>每个数字的结果用哈希表记录一下。</p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> tt;</span><br><span class="line">    <span class="keyword">int</span> stk[<span class="number">1010</span>];</span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    <span class="comment">// 存每个元素右边第一个比它大的</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 单调栈</span></span><br><span class="line">        <span class="comment">// 如果出现i&gt;j且a[i]&lt;=a[j]，则把i出栈</span></span><br><span class="line">        <span class="comment">// 倒序遍历nums2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums2.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(tt&amp;&amp;nums2[i]&gt;=stk[tt])&#123;</span><br><span class="line">                tt--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tt)&#123;</span><br><span class="line">                mp[nums2[i]]=stk[tt];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                mp[nums2[i]]=<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stk[++tt]=nums2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(nums1.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            ans[i]=mp[nums1[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;10-26-下一个更大元素&quot;&gt;&lt;a href=&quot;#10-26-下一个更大元素&quot; class=&quot;headerlink&quot; title=&quot;10.26 下一个更大元素&quot;&gt;&lt;/a&gt;10.26 下一个更大元素&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/next-greater-element-i/&quot;&gt;https://leetcode-cn.com/problems/next-greater-element-i/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="每日一题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="单调栈" scheme="https://benyang0506.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>单调栈</title>
    <link href="https://benyang0506.github.io/2021/10/26/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <id>https://benyang0506.github.io/2021/10/26/%E5%8D%95%E8%B0%83%E6%A0%88/</id>
    <published>2021-10-26T02:43:10.000Z</published>
    <updated>2021-10-26T03:48:47.104Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="acwing830-单调栈"><a href="#acwing830-单调栈" class="headerlink" title="acwing830 单调栈"></a>acwing830 单调栈</h5><p>传送门：<a href="https://www.acwing.com/problem/content/832/">https://www.acwing.com/problem/content/832/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 N，表示数列长度。</p><p>第二行包含 N 个整数，表示整数数列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含 N 个整数，其中第 i 个数表示第 i 个数的左边第一个比它小的数，如果不存在则输出 −1。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1\leq N\leq10^5 $</p><p>$1\leq数列中元素\leq10^9$</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">3 4 2 7 5</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1 3 -1 2 2</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果$i$在$j$的左边，$a[i]\geq a[j]$，那么$a[i]$永远不会出现在答案中；</p><p>我们维护栈时，保证不包含这样的$a[i]$，最后得到的是一个单调递增的栈。</p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组模拟栈</span></span><br><span class="line"><span class="keyword">int</span> tt;</span><br><span class="line"><span class="keyword">int</span> stk[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">while</span>(tt&amp;&amp;x&lt;=stk[tt]) tt--;</span><br><span class="line">        <span class="keyword">if</span>(tt)&#123;</span><br><span class="line">            cout&lt;&lt;stk[tt]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;-1 &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stk[++tt]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;acwing830-单调栈&quot;&gt;&lt;a href=&quot;#acwing830-单调栈&quot; class=&quot;headerlink&quot; title=&quot;acwing830 单调栈&quot;&gt;&lt;/a&gt;acwing830 单调栈&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://www.acwing.com/problem/content/832/&quot;&gt;https://www.acwing.com/problem/content/832/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="模板题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%A8%A1%E6%9D%BF%E9%A2%98/"/>
    
    
    <category term="单调栈" scheme="https://benyang0506.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>统计最高分的节点数目</title>
    <link href="https://benyang0506.github.io/2021/10/25/%E7%BB%9F%E8%AE%A1%E6%9C%80%E9%AB%98%E5%88%86%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE/"/>
    <id>https://benyang0506.github.io/2021/10/25/%E7%BB%9F%E8%AE%A1%E6%9C%80%E9%AB%98%E5%88%86%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE/</id>
    <published>2021-10-25T08:47:56.000Z</published>
    <updated>2021-10-25T09:03:50.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="第264场周赛C-统计最高分的节点数目"><a href="#第264场周赛C-统计最高分的节点数目" class="headerlink" title="第264场周赛C 统计最高分的节点数目"></a>第264场周赛C 统计最高分的节点数目</h5><p>传送门：<a href="https://leetcode-cn.com/problems/count-nodes-with-the-highest-score/">https://leetcode-cn.com/problems/count-nodes-with-the-highest-score/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给你一棵根节点为 <code>0</code> 的 <strong>二叉树</strong> ，它总共有 <code>n</code> 个节点，节点编号为 <code>0</code> 到 <code>n - 1</code> 。同时给你一个下标从 <strong>0</strong> 开始的整数数组 <code>parents</code> 表示这棵树，其中 <code>parents[i]</code> 是节点 <code>i</code> 的父节点。由于节点 <code>0</code> 是根，所以 <code>parents[0] == -1</code> 。</p><p>一个子树的 <strong>大小</strong> 为这个子树内节点的数目。每个节点都有一个与之关联的 <strong>分数</strong> 。求出某个节点分数的方法是，将这个节点和与它相连的边全部 <strong>删除</strong> ，剩余部分是若干个 <strong>非空</strong> 子树，这个节点的 <strong>分数</strong> 为所有这些子树 <strong>大小的乘积</strong> 。</p><p>请你返回有 <strong>最高得分</strong> 节点的 <strong>数目</strong> 。</p><p><strong>示例 1:</strong></p><p><img src="/2021/10/25/%E7%BB%9F%E8%AE%A1%E6%9C%80%E9%AB%98%E5%88%86%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE/sample1.png" alt></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：parents = [-1,2,0,2,0]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">- 节点 0 的分数为：3 * 1 = 3</span><br><span class="line">- 节点 1 的分数为：4 = 4</span><br><span class="line">- 节点 2 的分数为：1 * 1 * 2 = 2</span><br><span class="line">- 节点 3 的分数为：4 = 4</span><br><span class="line">- 节点 4 的分数为：4 = 4</span><br><span class="line">最高得分为 4 ，有三个节点得分为 4 （分别是节点 1，3 和 4 ）。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/2021/10/25/%E7%BB%9F%E8%AE%A1%E6%9C%80%E9%AB%98%E5%88%86%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE/sample2.png" style="zoom:50%;"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：parents = [-1,2,0]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">- 节点 0 的分数为：2 = 2</span><br><span class="line">- 节点 1 的分数为：2 = 2</span><br><span class="line">- 节点 2 的分数为：1 * 1 = 1</span><br><span class="line">最高分数为 2 ，有两个节点分数为 2 （分别为节点 0 和 1 ）。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == parents.length</code></li><li><p><code>2 &lt;= n &lt;= 1e5</code></p></li><li><p><code>parents[0] == -1</code></p></li><li>对于 <code>i != 0</code> ，有 <code>0 &lt;= parents[i] &lt;= n - 1</code></li><li><code>parents</code> 表示一棵二叉树。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对二叉树来说，删去某个点，最多形成三个连通分量，即左子树，右子树，以及剩下的部分。</p><p>可以先$dfs$一次，预处理出二叉树中以每个结点为根的子树的结点数量。</p><p>然后根据拆分后的情况求得分（是否存在左右子树，是否存在双亲结点/是否为$0$号结点）。</p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// n: 节点总数</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">// 最高得分的结点数</span></span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> childnums[<span class="number">100010</span>];</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; child;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件，叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(child[k].<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            childnums[k]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> childnums[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;child[k].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u=child[k][i];</span><br><span class="line">            childnums[k]+=<span class="built_in">dfs</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">        childnums[k]++;</span><br><span class="line">        <span class="comment">// 加上自己</span></span><br><span class="line">        <span class="keyword">return</span> childnums[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getScore</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> score=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n-childnums[k]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            score=n-childnums[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;child[k].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u=child[k][i];</span><br><span class="line">            score*=childnums[u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countHighestScoreNodes</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; parents)</span> </span>&#123;</span><br><span class="line">        n=parents.<span class="built_in">size</span>();</span><br><span class="line">        child=vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;parents.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            child[parents[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dfs得到以每个节点为根的子树包含的节点数，包含根</span></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;n;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     cout&lt;&lt;childnums[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> tmp=<span class="built_in">getScore</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(tmp&gt;ans)&#123;</span><br><span class="line">                num=<span class="number">1</span>;</span><br><span class="line">                ans=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tmp==ans)&#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;第264场周赛C-统计最高分的节点数目&quot;&gt;&lt;a href=&quot;#第264场周赛C-统计最高分的节点数目&quot; class=&quot;headerlink&quot; title=&quot;第264场周赛C 统计最高分的节点数目&quot;&gt;&lt;/a&gt;第264场周赛C 统计最高分的节点数目&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/count-nodes-with-the-highest-score/&quot;&gt;https://leetcode-cn.com/problems/count-nodes-with-the-highest-score/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="周赛" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="二叉树dfs" scheme="https://benyang0506.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91dfs/"/>
    
  </entry>
  
  <entry>
    <title>并行课程 III</title>
    <link href="https://benyang0506.github.io/2021/10/25/%E5%B9%B6%E8%A1%8C%E8%AF%BE%E7%A8%8B-III/"/>
    <id>https://benyang0506.github.io/2021/10/25/%E5%B9%B6%E8%A1%8C%E8%AF%BE%E7%A8%8B-III/</id>
    <published>2021-10-25T07:33:04.000Z</published>
    <updated>2021-10-25T08:50:32.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="第264场周赛D-并行课程-III"><a href="#第264场周赛D-并行课程-III" class="headerlink" title="第264场周赛D 并行课程 III"></a>第264场周赛D 并行课程 III</h5><p>传送门：<a href="https://leetcode-cn.com/problems/parallel-courses-iii/">https://leetcode-cn.com/problems/parallel-courses-iii/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给你一个整数 <code>n</code> ，表示有 <code>n</code> 节课，课程编号从 <code>1</code> 到 <code>n</code> 。同时给你一个二维整数数组 <code>relations</code> ，其中 <code>relations[j] = [prevCoursej, nextCoursej]</code> ，表示课程 <code>prevCoursej</code> 必须在课程 <code>nextCoursej</code> <strong>之前</strong> 完成（先修课的关系）。同时给你一个下标从 <strong>0</strong> 开始的整数数组 <code>time</code> ，其中 <code>time[i]</code> 表示完成第 <code>(i+1)</code> 门课程需要花费的 <strong>月份</strong> 数。</p><p>请你根据以下规则算出完成所有课程所需要的 <strong>最少</strong> 月份数：</p><ul><li>如果一门课的所有先修课都已经完成，你可以在 <strong>任意</strong> 时间开始这门课程。</li><li>你可以 <strong>同时</strong> 上 <strong>任意门课程</strong> 。</li></ul><p>请你返回完成所有课程所需要的 <strong>最少</strong> 月份数。</p><p><strong>注意：</strong>测试数据保证一定可以完成所有课程（也就是先修课的关系构成一个有向无环图）。</p><p><strong>示例 1:</strong></p><p><img src="/2021/10/25/%E5%B9%B6%E8%A1%8C%E8%AF%BE%E7%A8%8B-III/sample1.png" style="zoom:50%;"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3, relations = [[1,3],[2,3]], time = [3,2,5]</span><br><span class="line">输出：8</span><br><span class="line">解释：上图展示了输入数据所表示的先修关系图，以及完成每门课程需要花费的时间。</span><br><span class="line">你可以在月份 0 同时开始课程 1 和 2 。</span><br><span class="line">课程 1 花费 3 个月，课程 2 花费 2 个月。</span><br><span class="line">所以，最早开始课程 3 的时间是月份 3 ，完成所有课程所需时间为 3 + 5 = 8 个月。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/2021/10/25/%E5%B9%B6%E8%A1%8C%E8%AF%BE%E7%A8%8B-III/sample2.png" style="zoom:50%;"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5, relations = [[1,5],[2,5],[3,5],[3,4],[4,5]], time = [1,2,3,4,5]</span><br><span class="line">输出：12</span><br><span class="line">解释：上图展示了输入数据所表示的先修关系图，以及完成每门课程需要花费的时间。</span><br><span class="line">你可以在月份 0 同时开始课程 1 ，2 和 3 。</span><br><span class="line">在月份 1，2 和 3 分别完成这三门课程。</span><br><span class="line">课程 4 需在课程 3 之后开始，也就是 3 个月后。课程 4 在 3 + 4 = 7 月完成。</span><br><span class="line">课程 5 需在课程 1，2，3 和 4 之后开始，也就是在 max(1,2,3,7) = 7 月开始。</span><br><span class="line">所以完成所有课程所需的最少时间为 7 + 5 = 12 个月。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 5 * 104</code></li><li><p><code>0 &lt;= relations.length &lt;= min(n * (n - 1) / 2, 5 * 104)</code></p></li><li><p><code>relations[j].length == 2</code></p></li><li><p><code>1 &lt;= prevCoursej, nextCoursej &lt;= n</code></p></li><li><p><code>prevCoursej != nextCoursej</code></p></li><li><p>所有的先修课程对 <code>[prevCoursej, nextCoursej]</code> 都是 <strong>互不相同</strong> 的。</p></li><li><p><code>time.length == n</code></p></li><li><p><code>1 &lt;= time[i] &lt;= 104</code></p></li><li><p>先修课程图是一个有向无环图。</p></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>满足拓扑序列的情况下，找出最长的一条路径就是答案。</p><p>可以用数组$f[i]$来记录到达当前节点的最长距离。</p><p>拓扑排序基础题：</p><p><a href="https://www.aben.fun/2021/10/25/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97/">https://www.aben.fun/2021/10/25/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97/</a></p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; e[<span class="number">50010</span>];</span><br><span class="line">    <span class="comment">// 记录当前入度</span></span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">50010</span>];</span><br><span class="line">    <span class="comment">// 记录到达当前节点的最长距离</span></span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">50010</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> n,vector&lt;<span class="keyword">int</span>&gt;&amp; time)</span></span>&#123;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">                f[i]=time[i<span class="number">-1</span>];</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;e[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> v=e[u][i];</span><br><span class="line">                d[v]--;</span><br><span class="line">                <span class="comment">// 每次都需要更新才能找到最长时间（不能等到入度为0才更新）</span></span><br><span class="line">                f[v]=<span class="built_in">max</span>(f[v],f[u]+time[v<span class="number">-1</span>]);</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,f[v]);</span><br><span class="line">                <span class="keyword">if</span>(d[v]==<span class="number">0</span>)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTime</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; relations, vector&lt;<span class="keyword">int</span>&gt;&amp; time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;relations.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u=relations[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> v=relations[i][<span class="number">1</span>];</span><br><span class="line">            e[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">            d[v]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">bfs</span>(n,time);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;第264场周赛D-并行课程-III&quot;&gt;&lt;a href=&quot;#第264场周赛D-并行课程-III&quot; class=&quot;headerlink&quot; title=&quot;第264场周赛D 并行课程 III&quot;&gt;&lt;/a&gt;第264场周赛D 并行课程 III&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/parallel-courses-iii/&quot;&gt;https://leetcode-cn.com/problems/parallel-courses-iii/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="周赛" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="bfs" scheme="https://benyang0506.github.io/tags/bfs/"/>
    
    <category term="拓扑排序" scheme="https://benyang0506.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>有向图的拓扑序列</title>
    <link href="https://benyang0506.github.io/2021/10/25/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97/"/>
    <id>https://benyang0506.github.io/2021/10/25/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97/</id>
    <published>2021-10-25T06:56:21.000Z</published>
    <updated>2021-10-25T07:06:54.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="acwing-848-有向图的拓扑序列"><a href="#acwing-848-有向图的拓扑序列" class="headerlink" title="acwing 848. 有向图的拓扑序列"></a>acwing 848. 有向图的拓扑序列</h5><p>传送门：<a href="https://www.acwing.com/problem/content/850/">https://www.acwing.com/problem/content/850/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给定一个 n 个点 m 条边的有向图，点的编号是 1 到 n，图中可能存在重边和自环。</p><p>请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出 −1。</p><p>若一个由图中所有点构成的序列 A 满足：对于图中的每条边 (x,y)，x在 A 中都出现在 y 之前，则称 A 是该图的一个拓扑序列。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 n 和 m。</p><p>接下来 m 行，每行包含两个整数 x 和 y，表示存在一条从点 x 到点 y 的有向边 (x,y)。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，如果存在拓扑序列，则输出任意一个合法的拓扑序列即可。</p><p>否则输出 −1。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1\leq n,m\leq 10^5$</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>拓扑排序：记录每个节点入度，从入度为0的节点开始$bfs$。</p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; e[N];</span><br><span class="line"><span class="comment">// 记录每个点的入度</span></span><br><span class="line"><span class="keyword">int</span> d[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="comment">// 拓扑排序，从入度为0的点找起</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(d[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">            ans[idx++]=i;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;e[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=e[u][i];</span><br><span class="line">            <span class="comment">// 减去一条入边</span></span><br><span class="line">            d[v]--;</span><br><span class="line">            <span class="keyword">if</span>(d[v]==<span class="number">0</span>)&#123;</span><br><span class="line">                ans[idx++]=v;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(d[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        e[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        d[y]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;-1&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;acwing-848-有向图的拓扑序列&quot;&gt;&lt;a href=&quot;#acwing-848-有向图的拓扑序列&quot; class=&quot;headerlink&quot; title=&quot;acwing 848. 有向图的拓扑序列&quot;&gt;&lt;/a&gt;acwing 848. 有向图的拓扑序列&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://www.acwing.com/problem/content/850/&quot;&gt;https://www.acwing.com/problem/content/850/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="模板题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%A8%A1%E6%9D%BF%E9%A2%98/"/>
    
    
    <category term="bfs" scheme="https://benyang0506.github.io/tags/bfs/"/>
    
    <category term="拓扑排序" scheme="https://benyang0506.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>最长递增路径</title>
    <link href="https://benyang0506.github.io/2021/10/25/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84/"/>
    <id>https://benyang0506.github.io/2021/10/25/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84/</id>
    <published>2021-10-25T05:38:14.000Z</published>
    <updated>2021-10-25T08:51:01.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="剑指-Offer-II-112-最长递增路径"><a href="#剑指-Offer-II-112-最长递增路径" class="headerlink" title="剑指 Offer II 112. 最长递增路径"></a>剑指 Offer II 112. 最长递增路径</h5><p>传送门：<a href="https://leetcode-cn.com/problems/fpTFWP/">https://leetcode-cn.com/problems/fpTFWP/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>给定一个 <code>m x n</code> 整数矩阵 <code>matrix</code> ，找出其中 <strong>最长递增路径</strong> 的长度。</p><p>对于每个单元格，你可以往上，下，左，右四个方向移动。 <strong>不能</strong> 在 <strong>对角线</strong> 方向上移动或移动到 <strong>边界外</strong>（即不允许环绕）。</p><p><strong>示例 1：</strong></p><p><img src="/2021/10/25/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84/sample1.png" style="zoom:50%;"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[9,9,4],[6,6,8],[2,1,1]]</span><br><span class="line">输出：4 </span><br><span class="line">解释：最长递增路径为 [1, 2, 6, 9]。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/2021/10/25/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84/sample2.png" style="zoom:50%;"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[3,4,5],[3,2,6],[2,2,1]]</span><br><span class="line">输出：4 </span><br><span class="line">解释：最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>0 &lt;= matrix[i][j] &lt;= 2^31 - 1</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>最朴素的方法为依次$dfs$每个点，找到从每个点开始的最长递增路径的最大值，然后求$max$。</p><p>记忆化$dfs$：由于朴素$dfs$会对同一路径进行大量重复操作，时间复杂度为指数级别。我们可以用$f[i][j]$记录从（i，j）出发可以得到的最长递增路径。下次$dfs$到这个坐标可以直接拿来用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// f[i][j]:从(i,j)出发可以获得的最长递增路径</span></span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记忆化搜索</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[x][y])&#123;</span><br><span class="line">            <span class="keyword">return</span> f[x][y];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最短为1</span></span><br><span class="line">        f[x][y]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> xx=x+dx[i];</span><br><span class="line">            <span class="keyword">int</span> yy=y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(xx&gt;=<span class="number">0</span>&amp;&amp;xx&lt;n&amp;&amp;yy&gt;=<span class="number">0</span>&amp;&amp;yy&lt;m&amp;&amp;matrix[xx][yy]&gt;matrix[x][y])&#123;</span><br><span class="line">                f[x][y]=<span class="built_in">max</span>(f[x][y],<span class="built_in">dfs</span>(matrix,xx,yy)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[x][y];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        n=matrix.<span class="built_in">size</span>();</span><br><span class="line">        m=matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,<span class="built_in">dfs</span>(matrix,i,j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(mn)$，$n$为矩阵的行数，$m$为矩阵的列数。在$dfs$中，时间复杂度为$O(V+E)$，$V$为结点数，$E$为边数$O(V)=O(mn)$，$O(E)\approx O(4mn)$，每个点上下左右四条边。</p><p>空间复杂度：$O(mn)$</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;剑指-Offer-II-112-最长递增路径&quot;&gt;&lt;a href=&quot;#剑指-Offer-II-112-最长递增路径&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer II 112. 最长递增路径&quot;&gt;&lt;/a&gt;剑指 Offer II 112. 最长递增路径&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/fpTFWP/&quot;&gt;https://leetcode-cn.com/problems/fpTFWP/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    
    <category term="记忆化搜索" scheme="https://benyang0506.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>大礼包</title>
    <link href="https://benyang0506.github.io/2021/10/25/%E5%A4%A7%E7%A4%BC%E5%8C%85/"/>
    <id>https://benyang0506.github.io/2021/10/25/%E5%A4%A7%E7%A4%BC%E5%8C%85/</id>
    <published>2021-10-25T04:46:11.000Z</published>
    <updated>2021-10-25T08:51:11.298Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><h5 id="10-25-每日一题"><a href="#10-25-每日一题" class="headerlink" title="10.25 每日一题"></a>10.25 每日一题</h5><p>传送门：<a href="https://leetcode-cn.com/problems/shopping-offers/">https://leetcode-cn.com/problems/shopping-offers/</a></p><span id="more"></span><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>在 LeetCode 商店中， 有 <code>n</code> 件在售的物品。每件物品都有对应的价格。然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。</p><p>给你一个整数数组 <code>price</code> 表示物品价格，其中 <code>price[i]</code> 是第 <code>i</code> 件物品的价格。另有一个整数数组 <code>needs</code> 表示购物清单，其中 <code>needs[i]</code> 是需要购买第 <code>i</code> 件物品的数量。</p><p>还有一个数组 <code>special</code> 表示大礼包，<code>special[i]</code> 的长度为 <code>n + 1</code> ，其中 <code>special[i][j]</code> 表示第 <code>i</code> 个大礼包中内含第 <code>j</code> 件物品的数量，且 <code>special[i][n]</code> （也就是数组中的最后一个整数）为第 <code>i</code> 个大礼包的价格。</p><p>返回 <strong>确切</strong> 满足购物清单所需花费的最低价格，你可以充分利用大礼包的优惠活动。你不能购买超出购物清单指定数量的物品，即使那样会降低整体价格。任意大礼包可无限次购买。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]</span><br><span class="line">输出：14</span><br><span class="line">解释：有 A 和 B 两种物品，价格分别为 ¥2 和 ¥5 。 </span><br><span class="line">大礼包 1 ，你可以以 ¥5 的价格购买 3A 和 0B 。 </span><br><span class="line">大礼包 2 ，你可以以 ¥10 的价格购买 1A 和 2B 。 </span><br><span class="line">需要购买 3 个 A 和 2 个 B ， 所以付 ¥10 购买 1A 和 2B（大礼包 2），以及 ¥4 购买 2A 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]</span><br><span class="line">输出：11</span><br><span class="line">解释：A ，B ，C 的价格分别为 ¥2 ，¥3 ，¥4 。</span><br><span class="line">可以用 ¥4 购买 1A 和 1B ，也可以用 ¥9 购买 2A ，2B 和 1C 。 </span><br><span class="line">需要买 1A ，2B 和 1C ，所以付 ¥4 买 1A 和 1B（大礼包 1），以及 ¥3 购买 1B ， ¥4 购买 1C 。 </span><br><span class="line">不可以购买超出待购清单的物品，尽管购买大礼包 2 更加便宜。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == price.length</code></li><li><code>n == needs.length</code></li><li><code>1 &lt;= n &lt;= 6</code></li><li><code>0 &lt;= price[i] &lt;= 10</code></li><li><code>0 &lt;= needs[i] &lt;= 10</code></li><li><code>1 &lt;= special.length &lt;= 100</code></li><li><code>special[i].length == n + 1</code></li><li><code>0 &lt;= special[i][j] &lt;= 50</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果不考虑大礼包的话需要花费的总价是固定的，所以在考虑大礼包的时候，如果发现选购某个大礼包会使花费的总价减少，就可以更新总价。</p><p>因为没有一种贪心策略，所以只能$dfs$搜索。用$needs$来记录还需要购买的物品集合，$_cache$来记录当前$needs$集合花费的钱的最小值。</p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 记录每一个need的最小价格</span></span><br><span class="line">    map&lt;vector&lt;<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; _cache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shoppingOffers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; special, vector&lt;<span class="keyword">int</span>&gt;&amp; needs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// needs：还需要购买的物品</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(needs,price,special);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; needs,vector&lt;<span class="keyword">int</span>&gt;&amp; price,vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; special)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 子问题计算过，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(_cache[needs])&#123;</span><br><span class="line">            <span class="keyword">return</span> _cache[needs];    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 直接买，不用礼包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;needs.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            ans+=needs[i]*price[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个礼包，依次尝试，看看有没有更便宜的价格</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;special.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; next=needs;</span><br><span class="line">            <span class="keyword">bool</span> valid=<span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 题目要求购买数量为needs，不能超过</span></span><br><span class="line">            <span class="comment">// 检查needs中每一件物品，都不能超过</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> item=<span class="number">0</span>;item&lt;price.<span class="built_in">size</span>();item++)&#123;</span><br><span class="line">                <span class="comment">// 会超过，不符合题意</span></span><br><span class="line">                <span class="keyword">if</span>(special[i][item]&gt;needs[item])&#123;</span><br><span class="line">                    valid=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!valid)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// next记录买过大礼包之后，每件物品还需要多少件</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> item=<span class="number">0</span>;item&lt;price.<span class="built_in">size</span>();item++)&#123;</span><br><span class="line">                next[item]-=special[i][item];</span><br><span class="line">            &#125;</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,<span class="built_in">dfs</span>(next,price,special)+special[i][price.<span class="built_in">size</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">        _cache[needs]=ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(knm^n)$，$k$表示大礼包数量，$n$表示需要多少种物品，$m$表示每种物品的需求量的可能数（0-最大需求量）即最大需求量+1。$needs$最多$m^n$种状态，对每个状态需要遍历所有大礼包，每个大礼包需要遍历所有物品。</p><p>空间复杂度：$O(nm^n)$，$needs$最多$m^n$种状态，每种状态需要存储$n$个物品。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trace&quot;&gt;&lt;a href=&quot;#Trace&quot; class=&quot;headerlink&quot; title=&quot;Trace&quot;&gt;&lt;/a&gt;Trace&lt;/h2&gt;&lt;h5 id=&quot;10-25-每日一题&quot;&gt;&lt;a href=&quot;#10-25-每日一题&quot; class=&quot;headerlink&quot; title=&quot;10.25 每日一题&quot;&gt;&lt;/a&gt;10.25 每日一题&lt;/h5&gt;&lt;p&gt;传送门：&lt;a href=&quot;https://leetcode-cn.com/problems/shopping-offers/&quot;&gt;https://leetcode-cn.com/problems/shopping-offers/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/"/>
    
    <category term="每日一题" scheme="https://benyang0506.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="记忆化搜索" scheme="https://benyang0506.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
</feed>
